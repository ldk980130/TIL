# 1장 모놀리식 지옥에서 벗어나라

## 1.1 서서히 모놀리식 지옥에 빠져들다

- FTGO는 미국 온라인 음식 배달 업계를 선도하는 회사
- 하나의 WAR 파일로 구성된 모놀리스 시스템은 점점 커지면서 복잡해졌다.

### 1.1.1 FTGO 애플리케이션 아키텍처

- FTGO 전체 구조는 코어가 비즈니스 로직으로 구성된 육각형 아키텍처 (hexagonal architecture)
    - UI 구현 및 외부 시스템 통합을 담당하는 다양한 어댑터가 코어를 감싼 형태
- 비즈니스 로직은 도메인 객체 컬렉션인 모듈로 구성
    - 외부 시스템과 연계하는 어댑터가 여러 존재
        - REST API, 웹 UI 등의 인바운드 어댑터
        - DB, 클라우드 서비스를 호출하는 아운바운드 어댑터
- 논리적으로 모듈화했지만 애플리케이션은 하나의 WAR 파일로 패키징

### 1.1.2 모놀리식 아키텍처 장점

- 개발이 간단
    - IDE 등 개발 툴은 단일 이플리케이션 구축에 초점이 맞추어져 있다.
- 변경이 용이
    - 코드, DB 스키마를 변경해서 빌드/배포하기 용이
- 테스트하기 쉽다.
    - 애플리케이션을 띄우고, REST API를 호출하는 등 종단 간 테스트 작성
- 배포하기 쉽다.
    - 서버에 접속하여 톰캣 설치 경로에 WAR 파일 복사하면 그만
    - 이제는 JAR만 있으면 된다.
- 확장하기 쉽다.
    - 부하 분산기 뒤에 인스턴스 여러 개를 실행

### 1.1.3 모놀리식 지옥의 실상

- 개발 팀이 스프린트를 할 때마다 구현 스토리가 늘어나고 오버헤드도 증가
- 개발 팀 인원도 계속 증가
- 팀별로 특화된 스크럼 팀만 여럿

### 너무 복잡해서 개발자가 주눅 든다.

- FTGO 애플리케이션은 너무 복잡하다.
    - 개발자가 완전히 이해할 수 없을 정도
- 버그 픽스, 기능 추가가 갈수록 힘들고 오래 걸린다.
- 기능 별 팀은 여러개인데 소스 코드 저장소는 하나
    - 대규모 개발 팀이 단일 소스 코드 저장소에 커밋
    - 여러 팀의 커밋 → CI → 백로그 → 수동 테스트 → 프로덕션 배포까지의 과정이 험난
    - 단일 코드베이스는 소통/조정 오버헤드를 유발

### 개발이 더디다.

- 애플리케이션이 커지면 일상적 개발 업무도 더디게 진행된다.
    - IDE 실행 속도 느려짐
    - 빌드 시간 오래 걸림
    - 한 번 시동하는 것도 적잖은 시간이 걸린다.
- 즉 코드 변경 → 빌드/실행 → 테스트까지 너무 많은 시간이 낭비되어 생산성이 떨어진다.

### 커밋부터 배포에 이르는 길고 험난한 여정

- 애플리케이션 최신 트렌드는 지속적 배포 (continuous deployment)
    - 몇 번이고 원하는만큼 변경분을 배포
    - 아마존은 2011년 사용자에게 아무 영향 없이 11.6초마다 배포했다고 한다.
- 너무 방대한 모놀리식 애플리케이션은 한 달 2회 이상 배포도 힘든 일이었다.

### 확장하기 어렵다.

- FIGO 애플리케이션은 모듈마다 리소스 요건이 맞지 않아 확장하기 어렵다.
    - 용량이 큰 음식점 데이터는 인 메모리 DB 형태로 저장되기에 메모리 칩이 많은 서버에 배포하는 것이 좋다.
    - 이미지 처리 모듈은 CPU 코어 수가 많은 서버에 배포하는 것이 최적
- 같은 애플리케이션이라도 리소스 조건이 상이해 서버 구성 시 리소스 배분을 신경 써야 한다.

### 모놀리스는 확실히 전달하기 어렵다.

- 신뢰성이 부족한 것도 문제
    - 덩치가 워낙 커서 테스트하기 어렵다.
    - 테스트성 부족은 곧 버그 발생 확률을 높인다.

### 갈수록 한물간 기술 스택

- 모놀리식 아키텍처에선 어쩔 수 없이 한물간 기술 스택을 쓸 수밖에 없다.
- 최신 기술 사용 때문에 전체 모놀리식 애플리케이션을 재작성할 수 없기 때문
    - 비용과 리스크가 높다.

## 1.4 마이크로서비스 아키텍처가 답이다

- 어떤 아키텍처든 유스 케이스는 구현할 수 있다.
- 다만 FIGO 애플리케이션은 덩치가 커지며 여러 품질 속성이 악화되었다.
    - 소프트웨어 전달 속도
    - 확장성
    - 테스트성
- 그렇다면 마이크로서비스의 정의는 무엇인가?

### 1.4.1 확장 큐브와 마이크로서비스

- 확장 큐브라는 3차원 확장 모델이 있다.
  - 애플리케이션을 확장하는 세 가지 방법을 정의
  - X축은 확장은 동일한 다중 인스턴스에 들어온 요청을 부하 분산 (스케일 아웃)
  - Z축 확장은 요청 속성에 따라 요청을 라우팅 (데이터 분할, 다중 파티션)
  - Y축 확장은 애플리케이션을 기능에 따라 서비스로 분해 (기능 분해, 마이크로서비스)

### X축 확장: 다중 인스턴스에 고루 요청 분산

- X축 확장은 일반적인 모놀리식 애플리케이션의 확장 수단
- 부하 분산기에 들어온 요청을 인스턴스들에 고루 분배

### Z축 확장: 요청 속성별 라우팅

- 인스턴스별로 주어진 데이터 하위 집합만 처리하도록 설정하는 방법
- 인스턴스 앞면의 라우터가 요청 속성에 알맞은 인스턴스로 요청을 라우팅
  - ex) userId에 따라 라우팅할 인스턴스를 선택하여 요청을 전송
- 증가하는 트랜잭션 및 데이터 볼륨을 처리하기 좋은 수단

### Y축 확장: 기능에 따라 애플리케이션을 서비스로 분해

- X, Z축 확장으로 애플리케이션 능력과 가용성은 개선되지만 복잡성은 해결되지 않는다.
- Y축 확장, 즉 기능 분해가 필요
  - ex) 주문 서비스, 고객 서비스, 리뷰 서비스
  - 각 서비스는 필요에 따라 X, Z축 확장을 진행
- 중요한 것은 각 서비스의 크기가 아니라 각 서비스가 집중된/응집된 책임을 맡고 있다는 사실

### 1.4.2 마이크로서비스는 모듈성을 갖고 있다.

- 모듈성은 크고 복잡한 애플리케이션 개발 시 필요한 특성
  - 여러 사람이 이해하고 개발할 수 있게 애플리케이션을 여러 모듈로 분해
- 마이크로서비스 아키텍처는 서비스가 모듈의 단위
  - 서비스들 사이엔 API라는 경계선을 갖기에 다른 서비스의 내부에 침투할 수 없다.
  - 각 서비스를 독립적으로 배포/확장 가능

### 1.4.3 서비스마다 DB가 따로 있다.

- 마이크로서비스는 각각 자체 DB를 가진다.
  - 다른 서비스 개발자와 일일이 협의하지 않고도 본인이 담당한 서비스 스키마 변경 가능
  - 다른 서비스가 내 서비스의 DB 락을 획득해 블로킹하는 일도 없다.

### 1.4.4 FTGO 마이크로서비스 아키텍처

- FTGO 애플리케이션 비즈니스 로직은 다양한 백엔드 서비스로 구성된다.
  - 주문 서비스
  - 배달 서비스
  - 음식점 서비스
  - 주방 서비스
  - 회계 서비스
- API 게이트웨이는 각 서비스로 요청을 라우팅한다.

### 1.4.5 마이크로서비스 아키텍처와 SOA

- SOA (Service Oriented Architecture, 서비스 지향 아키텍처)
  - 고수준에선 SOA와 MSA는 비슷해보이지만 근본적인 차이점이 존재한다.

| 구분 | SOA | MSA |
| --- | --- | --- |
| 서비스 간 통신 | SOAP, WS 표준처럼 무거운 프로토콜을 응용한 엔터프라이즈 서비스 버스 중심의 스마트 파이프 | REST나 GRPC처럼 가벼운 프로토콜을 응용한 메시지 브로커 또는 서비스 간 통신 중심의 덤 파이프 |
| 데이터 | 전역 데이터 모델 및 공유 DB | 서비스 별 데이터 모델 및 DB |
| 주요 사례  | 대규모 모놀리식 애플리케이션 | 소규모 서비스 |
