# 2장 분해 전략
## 2.1 마이크로서비스 아키텍처란 무엇인가?

- 소프트웨어 아키텍처는 구성 요소 및 디펜던시로 엮인 고수준 구조물
- 아키텍처는 다차원적이므로 기술하는 방법도 다양하다.
- MSA는 관리성, 테스트성, 배포성이 높은 애플리케이션을 구축하는 아키텍처 스타일

### 2.1.1 소프트웨어 아키텍처의 정의와 중요성

### 소프트웨어 아키텍처의 정의

- 소프트웨어 아키텍처 문서화, 바스(Bass) 등

> 컴퓨팅 시스템의 소프트웨어 아키텍처는 소프트웨어 엘리먼트와 그들 간의 관계, 그리고 이 둘의 속성으로 구성된 시스템을 추론하는 데 필요한 구조의 집합이다.
>
- 즉 핵심은 여러 파트로의 분해와 이 파트 간의 관계라는 것
    - 업무와 지식을 분리. 덕분에 전문 지식을 보유한 사람들이 함께 생산적으로 애플리케이션 작업이 가능
    - 소프트웨어 엘리먼트가 어떻게 상호 작용하는지 밝힘

### 소프트웨어 아키텍처 4+1 뷰 모델

- 필립 크러첸이 발표한 논문
- 4+1 뷰 모델은 소프트웨어 아키텍처를 바라보는 상이한 4뷰를 정의한다.
    - 논리 뷰: 개발자가 작성한 소프트웨어 엘리먼트. 클래스, 패키지 그리고 상속, 연관, 의존 등의 관계를 뜻함
    - 구현 뷰: 빌드 시스템의 결과물.
        - 모듈(패키징된 코드)과 컴포넌트(하나 이상의 모듈로 구성된 실행/배포 가능 단위)로 구성
        - 자바에선 보통 JAR
        - 모듈 간 디펜던시와 컴포넌트/모듈 간 조합 관계도 포함
    - 프로세스 뷰: 런타임 컴포넌트.
        - 각 엘리먼트는 개별 프로세스고 IPC는 프로세스 간 관계를 나타낸다.
    - 배포 뷰: 프로세스가 머신에 매핑되는 방법.
        - 프로세스와 머신 사이의 관계
- 4뷰 외에도 뷰를 구동시키는 ‘시나리오’가 있다.
    - 각 시나리오는 특정 뷰 내에서 얼마나 다양한 요소가 협동하여 요청을 처리하는지 기술

### 아키텍처의 중요성

- 애플리케이션 요건은 크게 두 가지 존재
    - 애플리케이션이 해야 할 일을 정의한 기능 요건
        - 유스케이스, 사용자 스토리
        - 기능 요건은 어느 아키텍처에서든 구현 가능
    - ‘~성’으로 끝나는 서비스 품질 요건
        - 확장성, 신뢰성 등
        - 아키텍처 선택에 따라 만족 가능한 품질 요건이 달라짐

### 2.1.2 아키텍처 스타일 개요

- 애플리케이션은 대부분 아키텍처 스타일을 조합해서 사용한다.
- 모놀리식은 구현 뷰를 하나의 컴포넌트로 구성한 스타일
- MSA는 애플리케이션을 느슨하게 결합된 여러 서비스로 구성하는 스타일

### 계층화 아키텍처 스타일

- 계층화 아키텍처
    - 소프트웨어 엘리먼트를 계층별로 구성
    - 계층 간 디펜던시는 아키텍처로 제한
- 3계층 아키텍처
    - 표현(프레젠테이션) 계층: 사용자 인터페이스, 외부 API가 구현된 계층
    - 비즈니스 로직 계층: 비즈니스 로직이 구현된 계층
    - 영속(퍼시스턴스) 계층: DB 상호 작용 로직이 구현된 계층
- 계층화 아키텍처의 단점
    - 표현 계층이 하나뿐이다.
    - 영속화 계층이 하나뿐이다.
    - 비즈니스 로직을 계층을 영속화 계층에 의존하는 형태로 정의한다.

### 육각형 아키텍처 스타일

- 육각형 아키텍처
    - 논리 뷰를 비즈니스 로직 중심으로 구성
    - 표현 계층 대신 어댑터를 둔다.
        - 외부 요청을 처리하는 인바운드 어댑터(들)
        - 외부 애플리케이션을 호출하는 아웃바운드 어댑터(들)
        - 비즈니스 로직이 어댑터에 전혀 의존하지 않고 어댑터가 비즈니스 로직을 의존
    - 비즈니스 로직에는 하나 이상의 포트가 존재
        - 비즈니스 로직이 표출된 API로서의 인바운드 포트
        - 비즈니스 로직이 외부 시스템을 호출하는 방법에 관한 아웃바운드 포트
    - 인바운드 어댑터는 외부 요청을 인바운드 포트를 호출해 처리
    - 아웃바운드 어댑터는  비즈니스 로직에서 들어온 요청을 애플리케이션/서비스를 호출해서 처리
- 육각형 아키텍처의 장점
    - 비즈니스 로직이 표현/데이터 접근 로직 어디에도 의존하지 않는다.
    - 비즈니스 로직만 따로 테스트하기 쉽다.
- 육각형 아키텍처는 MSA를 다루는 각 서비스 아키텍처를 기술하는 가장 좋은 방법

### 2.1.3 마이크로서비스 아키텍처는 일종의 아키텍처 스타일이다

- 모놀리식 아키텍처
    - 구현 뷰를 단일 컴포넌트(하나의 실행 파일)로 구성한 아키텍처 스타일
    - 모놀리식은 육각형 아키텍처 방식으로 구성한 논리 뷰를 가질 수 있다.
- 마이크로서비스 아키텍처
    - 구현 뷰를 다수의 컴포넌트로 구성
    - 컴포넌트는 곧 서비스이며 각 서비스는 자체 논리 뷰를 가진다. (전형적인 육각형 아키텍처)
    - 커넥터는 각 서비스가 협동할 수 있게 해주는 통신 플토콜

### 서비스란 무엇인가

- 서비스는 기능이 구현되어 단독 배포가 가능한 소프트웨어 컴포넌트
- 서비스 API는 내부 구현 상세를 캡슐화한다.
    - API를 우회하여 서비스에 접근할 수 없기에 MSA에서 서비스 모듈성이 보장됨
- 각 마이크로서비스는 자체 아키텍처와 기술 스택을 독자적으로 구축 가능
    - 작업 어댑터는 API 요청을 받고 비즈니스 로직을 호출
    - 비즈니스 로직 호출 후 이벤트 어댑터가 이벤트를 발행
- 서비스마다 독립적 배포가 가능해야 한다.

### 느슨한 결합

- 서비스는 클라이언트에 영향을 주지 않고 내부 구현을 변경할 수 있다.
- 느슨한 결합은 유지보수성, 테스트성, 생산성을 높여준다.
- DB도 서비스마다 다르게 사용하기에 스키마 변경, 락 획득 등과 같은 사건에 다른 팀으로부터 자유롭다.
    - 다만 여러 서비스에 걸쳐 데이터를 쿼리할 때 복잡해진다.

### 공유 라이브러리 역할

- 코드 중복 방지를 위해 재사용 가능한 라이브러리(모듈)로 패키징하는 것은 당연한 일
- 다만 서비스 간 의도치 않은 결합도를 유발할 가능성이 있다.
    - 중복을 통합했다가 한 서비스에서만 그 기능을 다르게 써야한다면?
- 바뀔 일이 거의 없는 기능은 라이브러리에 담아 쓰는 것이 좋긴 하다.

### 서비스 규모는 별로 중요하지 않다

- 마이크로서비스는 크기보다 다음을 고려해야 한다.
    - 작은 팀이 가장 짧은 시간에
    - 다른 팀과 협동하는 부분은 최소로
    - 개발 가능한 서비스

