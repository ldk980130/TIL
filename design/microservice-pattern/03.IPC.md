# 3장 프로세스 간 통신
## 3.1 마이크로서비스 아키텍처 IPC 개요

- 서비스에 적용 가능한 IPC 기술은 많다.
    - HTTP 기반 REST, gRPC 등의 동기 기반
    - AMQP, STOM 등의 비동기 기반
- 메시지 포멧 역시 많다.
    - JSON, XML 등의 텍스트 포맷
    - 아브로나 프로토콜 버퍼 등의 이진 포맷

### 3.1.1 상호 작용 스타일

- IPC 기술을 선택하기 전 클라이언트/서비스 간 상호 작용 스타일을 살펴봐야 한다.
- 상호 작용 스타일은 두 가지 기준으로 분류할 수 있다.
    - 일대일/일대다 여부
    - 동기/비동기 여부
- 일대일 상호 작용도 종류는 다양하다.
    - 요청/응답: 클라이언트는 서비스에 요청을 하고 응답을 기다린다.
    - 비동기 요청/응답: 클라이언트는 서비스에 요청을 하고 서비스는 비동기적으로 응답. 클라이언트는 블로킹하지 않는다.
    - 단방향 알림: 클라이언트는 서비스에 일방적으로 요청하고 서비스는 응답을 보내지 않는다.
- 일대다 상호 작용도 몇 가지 종류가 있다.
    - 발행/구독: 클라이언트는 알림 메시지를 발행하고 여기에 관심 있는 0개 이상의 서비스가 메시지를 소비
    - 발행/비동기 응답: 클라이언트는 요청 메시지를 발행하고 주어진 시간 동안 관련 서비스가 응답하길 기다린다.

### 3.1.2 마이크로서비스 API 정의

- API와 인터페이스는 소프트웨어 개발의 핵심이다.
    - 각 모듈마다 자신의 클라이언트가 호출하는 인터페이스가 존재
    - MSA에서도 API와 인터페이스는 똑같이 중요하다.
- MSA에서 API는 단순한 프로그래밍 언어의 일부가 아니다.
    - 함께 컴파일되지 않는다.
    - 새 버전의 서비스가 호환되지 않는 API에 맞물려 배포되면 런타임에 실패한다.
- 어떤 IPC를 사용하든 서비스 API를 IDL(Interface Definition Language)로 정확하게 정의하라
    - API를 정의, 명세서 작성 후 서비스를 구현
- API는 어떤 IPC를 사용하느냐에 따라 내용이 결정된다.

### 3.1.3 API 발전시키기

- 모놀리식에선 API 변경이 어렵지 않다.
    - 자바 같은 정적 타입 언어를 사용한다면 컴파일러를 통해 쉽게 변경부를 찾아갈 수 있다.
- 마이크로서비스 애플리케이션에선 서로 다른 서비스 팀 간 API를 변경하기가 무척 어렵다.
    - 또 요즘은 무중단 배포를 하기 때문에 규칙적인 단계로 서비스를 업그레이드하며 신구 버전을 동시에 실행한다.

### 시멘틱 버저닝

- 시멘틱 버저닝 명세는 API 버저닝에 관한 유용한 지침서다.
    - 버전 번호를 사용하고 증가시키는 규칙들이 명시되어 있다.
- 이 명세에 따르면 버전 번호를 세 파트로 구성하고 다음 규칙에 따라 증가시킨다.
    - MAJOR: 하위 호환되지 않는 변경분을 API에 적용 시
    - MINOR: 하위 호환되는 변경분을 API에 적용 시
    - PATCH: 하위 호환되는 오류 수정 시
- 버전 번호 명시 방법
    - REST API라면 URL 경로 첫 엘리먼트로 쓸 수 있다.
    - 메시징 기반이라면 발행한 메시지에 넣을 수 있다.

### 하위 호환되는 소규모 변경

- 변경이 있더라도 가급적 하위 호환성을 보장하도록 해야 한다.
    - 옵션 속성을 요청에 추가
    - 속성을 응답에 추가
    - 새 작업을 추가
- 이런 종류의 변경은 새 서비스에 적용해도 기존 클라이언트 역시 별 문제 없이 동작한다.
- 단 ‘견고성 원칙’을 지켜야 한다.
    - “당신이 하는 일은 보수적으로, 다른 사람들이 하는 일은 관대하게 바라보라”
    - ex) 요청 속성이 누락되어도 서비스는 기본값을 제공
    - ex) 서비스가 필요한 것보다 더 많은 속성을 응답하더라도 클라이언트는 간단히 무시

### 중대한 대규모 변경

- 기존 버전과 호환이 안 되는 변경을 적용해야할 때가 있다.
- 일시에 클라이언트를 강제로 업그레이드하는 것은 불가능하기에 신구 버전 API를 모두 지원해야 한다.
    - REST API의 경우 URL에 메이저 버전 번호를 삽입할 수 있다.
        - ex) /v1/posts/…
    - HTTP 컨텐츠 협상(content negotiation)을 이용하는 방법도 있다.
        - MIME 타입 내부에 버전 번호를 끼워 넣기
- 여러 API를 지원하려면 서비스 어댑터에 신구 버전을 올바르게 중계하는 로직이 있어야 한다.
    - API 게이트웨이는 거의 반드시 버저닝된 API를 사용하고 심지어 구 버전 API도 여럿 지원해야 하는 경우도 있다.

### 3.1.4 메시지 포맷

- IPC의 핵심은 메시지 교환
- 메시징이나 HTTP 프로토콜에선 메시징 포맷을 선택해야 한다.
- gRPC는 메시지 포맷이 정해져 있다.
- 메시지 포맷은 크게 텍스트와 이진 포맷으로 분류된다.

### 텍스트 메시지 포맷

- 텍스트 기반 포맷은 사람이 읽을 수 있어 자기 서술적인 장점이 있다.
    - JSON 메시지는 네임드 프로퍼티 구조
    - XML 메시지는 네임드 엘리먼트와 그 값을 모아 놓은 구조
    - 메시지 컨슈머는 관심 있는 값만 골라쓰고 나머지는 무시해도 되기에 하위 호환성이 쉽게 보장된다.
- 텍스트 메시지 포맷의 단점은 메시지가 다소 길다는 것
    - 속성 값 이외에 속성명이 추가되는 오버헤드
    - 덩치 큰 메시지는 파싱하는 오버헤드
    - 효율/성능이 중요한 경우 이진 포맷을 고려할 수 있다.

### 이진 메시지 포맷

- 이진 포맷 종류 중 프로토콜 버퍼와 아브로가 유명
    - 두 포맷 모두 메시지 구조 정의에 필요한 타입 IDL을 제공
    - 컴파일러는 메시지 직렬화/역직렬화 코드를 생성
- API 발전 측면에선 프로토콜 버퍼가 더 용이
    - 아브로 컨슈머는 스키마를 알아야 메시지를 해석할 수 있기 때문

