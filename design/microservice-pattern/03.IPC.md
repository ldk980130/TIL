# 3장 프로세스 간 통신
## 3.1 마이크로서비스 아키텍처 IPC 개요

- 서비스에 적용 가능한 IPC 기술은 많다.
    - HTTP 기반 REST, gRPC 등의 동기 기반
    - AMQP, STOM 등의 비동기 기반
- 메시지 포멧 역시 많다.
    - JSON, XML 등의 텍스트 포맷
    - 아브로나 프로토콜 버퍼 등의 이진 포맷

### 3.1.1 상호 작용 스타일

- IPC 기술을 선택하기 전 클라이언트/서비스 간 상호 작용 스타일을 살펴봐야 한다.
- 상호 작용 스타일은 두 가지 기준으로 분류할 수 있다.
    - 일대일/일대다 여부
    - 동기/비동기 여부
- 일대일 상호 작용도 종류는 다양하다.
    - 요청/응답: 클라이언트는 서비스에 요청을 하고 응답을 기다린다.
    - 비동기 요청/응답: 클라이언트는 서비스에 요청을 하고 서비스는 비동기적으로 응답. 클라이언트는 블로킹하지 않는다.
    - 단방향 알림: 클라이언트는 서비스에 일방적으로 요청하고 서비스는 응답을 보내지 않는다.
- 일대다 상호 작용도 몇 가지 종류가 있다.
    - 발행/구독: 클라이언트는 알림 메시지를 발행하고 여기에 관심 있는 0개 이상의 서비스가 메시지를 소비
    - 발행/비동기 응답: 클라이언트는 요청 메시지를 발행하고 주어진 시간 동안 관련 서비스가 응답하길 기다린다.

### 3.1.2 마이크로서비스 API 정의

- API와 인터페이스는 소프트웨어 개발의 핵심이다.
    - 각 모듈마다 자신의 클라이언트가 호출하는 인터페이스가 존재
    - MSA에서도 API와 인터페이스는 똑같이 중요하다.
- MSA에서 API는 단순한 프로그래밍 언어의 일부가 아니다.
    - 함께 컴파일되지 않는다.
    - 새 버전의 서비스가 호환되지 않는 API에 맞물려 배포되면 런타임에 실패한다.
- 어떤 IPC를 사용하든 서비스 API를 IDL(Interface Definition Language)로 정확하게 정의하라
    - API를 정의, 명세서 작성 후 서비스를 구현
- API는 어떤 IPC를 사용하느냐에 따라 내용이 결정된다.

### 3.1.3 API 발전시키기

- 모놀리식에선 API 변경이 어렵지 않다.
    - 자바 같은 정적 타입 언어를 사용한다면 컴파일러를 통해 쉽게 변경부를 찾아갈 수 있다.
- 마이크로서비스 애플리케이션에선 서로 다른 서비스 팀 간 API를 변경하기가 무척 어렵다.
    - 또 요즘은 무중단 배포를 하기 때문에 규칙적인 단계로 서비스를 업그레이드하며 신구 버전을 동시에 실행한다.

### 시멘틱 버저닝

- 시멘틱 버저닝 명세는 API 버저닝에 관한 유용한 지침서다.
    - 버전 번호를 사용하고 증가시키는 규칙들이 명시되어 있다.
- 이 명세에 따르면 버전 번호를 세 파트로 구성하고 다음 규칙에 따라 증가시킨다.
    - MAJOR: 하위 호환되지 않는 변경분을 API에 적용 시
    - MINOR: 하위 호환되는 변경분을 API에 적용 시
    - PATCH: 하위 호환되는 오류 수정 시
- 버전 번호 명시 방법
    - REST API라면 URL 경로 첫 엘리먼트로 쓸 수 있다.
    - 메시징 기반이라면 발행한 메시지에 넣을 수 있다.

### 하위 호환되는 소규모 변경

- 변경이 있더라도 가급적 하위 호환성을 보장하도록 해야 한다.
    - 옵션 속성을 요청에 추가
    - 속성을 응답에 추가
    - 새 작업을 추가
- 이런 종류의 변경은 새 서비스에 적용해도 기존 클라이언트 역시 별 문제 없이 동작한다.
- 단 ‘견고성 원칙’을 지켜야 한다.
    - “당신이 하는 일은 보수적으로, 다른 사람들이 하는 일은 관대하게 바라보라”
    - ex) 요청 속성이 누락되어도 서비스는 기본값을 제공
    - ex) 서비스가 필요한 것보다 더 많은 속성을 응답하더라도 클라이언트는 간단히 무시

### 중대한 대규모 변경

- 기존 버전과 호환이 안 되는 변경을 적용해야할 때가 있다.
- 일시에 클라이언트를 강제로 업그레이드하는 것은 불가능하기에 신구 버전 API를 모두 지원해야 한다.
    - REST API의 경우 URL에 메이저 버전 번호를 삽입할 수 있다.
        - ex) /v1/posts/…
    - HTTP 컨텐츠 협상(content negotiation)을 이용하는 방법도 있다.
        - MIME 타입 내부에 버전 번호를 끼워 넣기
- 여러 API를 지원하려면 서비스 어댑터에 신구 버전을 올바르게 중계하는 로직이 있어야 한다.
    - API 게이트웨이는 거의 반드시 버저닝된 API를 사용하고 심지어 구 버전 API도 여럿 지원해야 하는 경우도 있다.

### 3.1.4 메시지 포맷

- IPC의 핵심은 메시지 교환
- 메시징이나 HTTP 프로토콜에선 메시징 포맷을 선택해야 한다.
- gRPC는 메시지 포맷이 정해져 있다.
- 메시지 포맷은 크게 텍스트와 이진 포맷으로 분류된다.

### 텍스트 메시지 포맷

- 텍스트 기반 포맷은 사람이 읽을 수 있어 자기 서술적인 장점이 있다.
    - JSON 메시지는 네임드 프로퍼티 구조
    - XML 메시지는 네임드 엘리먼트와 그 값을 모아 놓은 구조
    - 메시지 컨슈머는 관심 있는 값만 골라쓰고 나머지는 무시해도 되기에 하위 호환성이 쉽게 보장된다.
- 텍스트 메시지 포맷의 단점은 메시지가 다소 길다는 것
    - 속성 값 이외에 속성명이 추가되는 오버헤드
    - 덩치 큰 메시지는 파싱하는 오버헤드
    - 효율/성능이 중요한 경우 이진 포맷을 고려할 수 있다.

### 이진 메시지 포맷

- 이진 포맷 종류 중 프로토콜 버퍼와 아브로가 유명
    - 두 포맷 모두 메시지 구조 정의에 필요한 타입 IDL을 제공
    - 컴파일러는 메시지 직렬화/역직렬화 코드를 생성
- API 발전 측면에선 프로토콜 버퍼가 더 용이
    - 아브로 컨슈머는 스키마를 알아야 메시지를 해석할 수 있기 때문

## 3.2 동기 RPI 패턴 응용 통신

- RPI (Remote Procedure Invocation, 원격 프로시저 호출)
  - 클라이언트가 서비스에 요청을 보내면 서비스가 처리 후 응답을 하는 회신 IPC
  - 블로킹일 수도 논블로킹일 수도 있지만 메시징과 다르게 응답이 도착한다 가정

### 3.2.1 동기 RPI 패턴: REST

- REST는 HTTP로 소통하는 IPC이고 현재 API 개발은 REST가 대세이다.
- 리소스는 REST의 핵심 개념
  - HTTP 메서드를 사용해 URL에 참조되는 리소스를 가공
- 개발자는 대부분 REST한 API라고 설계하지만 로이 필딩의 글에 의하면 실제로 그렇지 않은 API도 많다.

### REST 성숙도 모델

- 레너드 리처드슨은 REST가 얼마나 성숙한지 알 수 있는 성숙도 모델을 제시했다.
- 레벨 0
  - 클라이언트는 서비스별 유일한 URL 엔드포인트에 POST 요청을 하여 서비스를 호출
  - 요청할 때마다 어떤 액션을 어떤 대상에 수행할지 지정
  - 필요한 매개변수도 함께 전달
- 레벨 1
  - 서비스는 리소스 개념을 지원
  - 클라이언트는 수행할 액션과 매개변수가 지정된 POST 요청
- 레벨 2
  - 서비스는 HTTP 메서드로 액션을 수행 (GET: 조회, POST: 생성, PUT: 수정)
  - 요청 쿼리 매개변수 및 바디 필요 시 매개변수 지정
  - 덕분에 GET 요청을 캐싱하는 등 웹 인프라 활용 가능
- 레벨 3
  - 서비스를 HATEOAS 원칙에 기반하여 설계
  - HATEOAS는 GET 요청으로 반환된 리소스 표현형에 그 리소스에 대한 액션의 링크도 함께 태워 보내는 것
  - ex) GET으로 주문 데이터를 조회하고 이 때 반환된 표현형 내부 링크를 이용해 해당 주문을 취소 가능
  - HATEOAS를 사용하면 하드 코딩한 URL을 클라이언트 코드에 욱여 넣지 않아도 된다.

### REST 장단점

- 장점
  - 단순하고 익숙하다
  - 포스트맨 등 플러그인이나 curl 등의 CLI 도구로 간편하게 테스트 가능
  - 요청/응답 스타일의 통신을 직접 지원
  - HTTP는 방화벽 친화적
  - 중간 브로커가 필요하지 않아 시스템 아키텍처가 단순하다.
- 단점
  - 요청/응답 스타일의 통신만 지원
  - 가용성이 떨어진다.
    - 중간에서 메시지를 버퍼링하는 매개자 없이 클라/서비스가 직접 통신하기에 양쪽 다 실행 중이어야 함
  - 서비스 인스턴스들의 위치(URL)를 클라이언트가 알고 있어야 한다.
  - 요청 한 번으로 여러 리소스를 가져오기 어렵다.
    - REST는 비즈니스 객체 중심이기 때문
    - 데이터를 효율적으로 조회할 수 있게 설계된 GraphQL이나 넷플릭스 팔코 등 대체 API 기술이 존재
  - 다중 업데이트 작업을 HTTP 동사에 매핑하기 어려울 때가 많다.
    - 수정할 때 PUT을 많이 쓰지만 데이터를 수정하는 시나리오는 다양하다.

### 3.2.2 동기 RPI 패턴: gRPC

- gRPC
  - 다양한 언어로 클라이언트/서버를 작성할 수 있는 프레임워크
  - 이진 메시지 기반 프로토콜이므로 서비스를 API 우선 방식으로 설계할 수밖에 없다.
- gRPC API는 하나 이상의 서비스와 요청/응답 메시지 데피니션으로 구성된다.
  - 서비스 데피니션은 정적 타입 메서드를 모아 놓은 것으로 자바 인터페이스와 비슷하다.
  - 단순 요청/응답 뿐 아니라 스트리밍 RPC도 지원
- gRPC는 프로토콜 버퍼 메시지 포멧을 사용
  - 프로토콜 버퍼: 간결하고 효율적인 이진 포멧으로 구조화 데이터를 직렬화하는 구글의 언어 중립적 메커니즘
  - 프로토콜 버퍼 컴파일러로 클라이언트 쪽 스텁 및 서버 쪽 스켈레톤을 생성할 수 있다.
  - 프로토콜 버퍼 메시지는 각 필드마다 번호가 매겨지고 타입 코드가 할당된다.
  - 메시지 수신자는 필요한 필드만 추출하고 모르는 필드는 건너뛸 수 있어 하위 호환성이 유지된다.

```
// 주문 서비스 gRPC API 예시
service OrderService {
    rpc createOrder(CreateOrderRequest) returns (CreateORderReply) {}
    rpc cancelOrder(CancelOrderRequest) returns (CancelORderReply) {}
    rpc reviseOrder(ReviseOrderRequest) returns (ReviseOrderReply) {}
    ...
}

message CreateOrderRequest {
    int64 restaurantId = 1;
    int 64 consumerId = 2;
    repeated LineItem lineItems = 3;
    ...
}

message LineItem {
    string menuItemId = 1;
    int32 quantity = 2;
    ...
}

...
```

- gRPC 장점
  - 다양한 업데이트 작업이 포함된 API를 설계하기 쉽다.
  - 특히 큰 메시지를 교환할 때 콤팩트하고 효율적인 IPC
  - 양방향 스트리밍 덕분에 RPI, 메시징 두 통신 방식 모두 가능
  - 다양한 언어로 작성된 클라이언트/서버 간 연동이 가능
- gRPC 단점
  - 자바스크립트 클라이언트가 하는 일이 REST 기반 API보다 더 많다.
  - 구형 방화벽은 HTTP/2를 지원하지 않는다.
- gRPC는 REST처럼 동기 통신 메커니즘이기에 부분 실패 문제는 풀어야할 숙제이다.
