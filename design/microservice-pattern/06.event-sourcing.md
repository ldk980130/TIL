# 6장 비즈니스 로직 개발: 이벤트 소싱

## 6.1 이벤트 소싱 응용 비즈니스 로직 개발

- 이벤트 소싱
    - 애그리거트를 저장하는 또 하나의 방법
    - 상태 변화를 나타내는 일련의 도메인 이벤트로 애그리거트를 저장
- 이벤트 소싱 장점
    - 애그리거트 이력이 보존되기에 감사/통제 용도로 가치가 있다.
    - 도메인 이벤트를 확실하게 발행할 수 있어 MSA에서 유용
- 이벤트 소싱 단점
    - 러닝 커브가 필요
    - 이벤트 저장소를 쿼리하기가 쉽지 않아 CQRS 패턴을 적용해야 한다.

### 6.1.1 기존 영속화의 문제점

- 클래스는 DB 테이블에, 필드는 컬럼에 매핑하는 것이 기존 방식이다.
- 기존 방식의 단점 및 한계가 존재한다.
    - 객체-관계 임피던스 부정합
    - 애그리거트 이력이 없다
    - 감사 로깅을 구현하기 번거롭고 에러가 잘 난다
    - 이벤트 발행 로직이 비즈니스 로직에 추가된다

### 객체-관계 임피던스 부정합

- 관계형 스키마와 복잡한 리치 도메인 모델의 그래프 구조는 근본 개념부터 다르다.
- 이는 ORM 프레임워크 타당성에 관한 논쟁으로 이어진다.

### 애그리거트 이력이 없다

- 기존 방식은 애그리거트 상태만 저장한다.
- 애그리거트 이력을 온전히 보존하려면 코드를 추가적으로 구현해야 한다.
    - 비즈니스 로직과 동기화하는 코드를 중복 생성하게 됨

### 감사 로깅은 구현하기 힘들고 오류도 자주 발생

- 많은 애플리케이션이 감사 로그를 통해 애그리거트를 추적
    - 보안/통제가 필요한 경우 필요
    - 사용자 액션 이력 자체가 중요한 경우에 필요
- 구현하는 데 시간이 걸린다.
- 로깅 코드 및 비즈니스 로직이 계속 분화하기에 버그가 날 가능성이 높다.

### 이벤트 발행 로직이 비즈니스 로직에 추가된다

- 기존 영속화의 한계는 도메인 이벤트 발행을 지원하지 않는다.
    - ORM 프레임워크가 객체 변경 시 콜백을 호출할 수 있긴 하다.
    - 하지만 트랜잭션의 일부로 메시지를 자동 발행하는 기능은 없다.
- 이벤트 생성 로직을 추가해야 하는데 비즈니스 로직과 동기화되지 않을 위험이 있다.

### 6.1.2 이벤트 소싱 개요

- 이벤트 소싱은 애그리거트를 DB에 일련의 이벤트로 저장하는 기법
- 각 이벤트는 애그리거트의 상태 변화를 나타낸다.

### 이벤트를 이용하여 애그리거트를 저장

- 예를 들어 `Order` 애그리거트를 이벤트 소싱으로 저장한다면 `EVENTS` 테이블의 여러 로우로 저장한다.

| event_id | event_type | entity_type | entity_id | event_data |
| --- | --- | --- | --- | --- |
| 102 | OrderCreated | Order | 101 | {…} |
| 103 | OrderApproved | Order | 101 | {…} |
| 104 | OrderShipped | Order | 101 | {…} |
| 105 | OrderDelivered | Order | 101 | {…} |

- 애그리거트를 로드할 때 이벤트를 가져와 재연을 한다.
    1. 애그리거트의 이벤트를 로드
    2. 기본 생성자를 호출하여 애그리거트 인스턴스 생성
    3. 이벤트를 하나씩 순회하며 `apply()`를 호출
- 이벤추에이트 클라이언트 프레임워크에도 애그리거트 재구성 코드가 존재한다.

```java
Class aggregateClass = ...;
Aggregate aggregate = aggregateClass.newInstance();
for (Event event : events) {
    aggregate = aggregate.applyEvent(event);
}
// 애그리거트 사용
```

### 이벤트는 곧 상태 변화

- 도메인 이벤트는 애그리거트 변경을 구독자에게 알리는 장치
    - 최소한의 데이터만 넣거나 컨슈머에게 유용한 데이터까지 포함시켜 강화시킬 수도 있다.
- 이벤트 소싱에선 이벤트가 필수
    - 모든 상태 변화를 도메인 이벤트로 나타냄
    - 상태가 바뀔 때마다 이벤트를 발생시킴
- 이벤트는 애그리거트가 상태 전이를 하기 위해 필요한 데이터를 갖고 있어야 한다.

### 애그리거트 메서드의 관심사는 오직 이벤트

- 애그리거트 루트의 커맨드 메시지로 애그리거트 업데이트 로직을 처리한다.
- 이벤트 소싱에선 커맨드 메서드가 반드시 이벤트를 발생시킨다.
    - 커맨드를 처리하면 애그리거트 상태 변경 없이 이벤트가 생성된다.
    - 애그리거트는 이벤트를 적용해서 업데이트한다.
- 이벤트를 발생시켜 적용하려면 비즈니스 로직을 다시 구성해야 한다.
    - 커맨드 메서드 하나를 둘 이상의 메서드로 리팩터링해야 한다.
    - 첫 번째 메서드는 커맨드 객체를 매개변수로 받아 어떻게 변경해야 할지를 결정
        - 애그리거트 상태는 바꾸지 않고 상태 변경을 나타낸 이벤트 목록을 반환
    - 두 번째 메서드는 이벤트 타입을 받아 애그리거트를 업데이트
    - 이벤추에이트 클라이언트라는 이벤트 소싱 프레임워크에선 각각 `process()`, `apply()`라는 이름으로 명명했다.

```java
// 기존 로직
public class Order {
    public List<DomainEvent> revise(OrderRevision orderRevision) {
        switch (state) {
            case AUTHORIZED:
                LineItemQuantityChange change = 
                    orderLineItems.lineItemQuantityChange(orderRevision);
                if (change.newOrderTotal.isGreaterThanOrEqual(orderMinimum) {
                    throw new OrderMinimumNotMetException();
                }
                this.state = REVISION_PENDING;
                return ...;
            default:
                throw new UnsupportedStateTransitionException(state);
        }
    }
}

// 이벤트 소싱 로직
public class Order {
    
    public List<Event> process(ReviseOrder command) { // Order 업데이트 없이 이벤트 반환
        OrderRevision orderRevision = command.getOrderRevision();
        switch (state) {
            case AUTHORIZED:
                LineItemQuantityChange change = 
                    orderLineItems.lineItemQuantityChange(orderRevision);
                if (change.newOrderTotal.isGreaterThanOrEqual(orderMinimum) {
                    throw new OrderMinimumNotMetException();
                }
                return singletonList(
                    new OrderRevisionProposed(...));
            default:
                throw new UnsupportedStateTransitionException(state);
        }        
    }
    
    public void apply(OrderRevisionProposed event) { // 이벤트를 적용하여 Order 업데이트
        this.state = REVISION_PENDING;
    }
}
```

- 애그리거트는 다음 순서대로 생성된다.
    1. 기본 생성자로 애그리거트 루트 초기화
    2. `process()`를 호출하여 새 이벤트 발생
    3. 새 이벤트를 하나씩 순회하며 `apply()`를 호출하여 애그리거트 수정
    4. 이벤트 저장소에 새 이벤트를 저장
- 애그리거트는 다음 순서대로 업데이트된다.
    1. 이벤트 저장소에서 애그리거트 이벤트 로드
    2. 기본 생성자로 애그리거트 루트 초기화
    3. 가져온 이벤트를 순회하며 애그리거트 루트의 `apply()` 호출
    4. `process()`를 호출하여 새 이벤트를 발생시킴
    5. 새 이벤트를 순회하며 `apply()`를 호출하여 애그리거트 수정
    6. 이벤트 저장소에 새 이벤트를 저장
