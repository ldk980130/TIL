# 7장 마이크로서비스 쿼리 구현

- 여러 DB에 분산된 데이터를 조회하는 쿼리 작업은 구현하기 어렵다.
- 마이크로서비스 아키텍처에서 다음 두 가지 패턴으로 쿼리를 구현한다.
    - API 조합 패턴: 서비스 클라이언트가 데이터를 가진 여러 서비스를 직접 호출하여 그 결과를 조합
        - 가장 단순한 방법으로 가급적으로 이 방법이 좋음
    - CQRS 패턴: 쿼리만 지원하는 하나 이상의 뷰 전용 DB를 유지하는 패턴
        - API 조합 패턴보다 강력한 만큼 구현이 복잡

## 7.1 API 조합 패턴 응용 쿼리

### 7.1.1 findOrder() 쿼리

- `findOrder()`
    - 기본키로 주문 정보를 조회하는 메서드
    - 주문/지불 정보, 배달 정보 등이 포함
- 마이크로서비스 아키텍처이기에 여러 서비스에 데이터가 뿔뿔이 흩어져 있다.
    - 주문 서비스: 주문 기본 정보 (주문 내역, 주문 상태 등)
    - 주방 서비스: 음식점 관점의 주문 상태, 픽업 준비까지 예상 소요 시간
    - 배달 서비스: 주문 배달 상태, 배달 예상 정보, 현재 배달원 위치
    - 회계 서비스: 주문 지불 상태

### 7.1.2 API 조합 패턴 개요

- API 조합 패턴이 각 서비스를 호출 후 결과를 조합하는 과정에는 두 종류의 참여자가 개입한다.
    - API 조합기: 프로바이더 서비스를 쿼리하여 데이터를 조회한다.
        - API 조합기는 클라이언트, API 게이트웨이 또는 프런트엔드를 위한 백엔드 패턴의 변형일 수도 있다.
    - 프로바이더 서비스: 최종 결과로 반환할 데이터 일부를 갖고 잇는 서비스

### 7.1.3 API를 조합 패턴으로 findOrder() 쿼리 구현

- `findOrder()`는 단순히 기본키로 EQUI 조인 작업
- 주문 검색 조합기는 총 4개 서비스를 호출한 결과를 조합한다.
    - 주문 서비스: `GET /orders/{orderId}`
    - 주방 서비스: `GET /tickets?orderId={orderId}`
    - 배달 서비스: `GET /deliveries?orderId={orderId}`
    - 회계 서비스: `GET /charges?orderId={orderId}`
- 주문 서비스는 기본키로 `Order`를 조회하고, 다른 서비스는 `orderId`를 외래키로 자신의 애그리거트를 조회하는 것

### 7.1.4 API 조합 설계 이슈

- 어느 컴포넌트를 쿼리 작업 API 조합기로 선정할 것인가
- 어떻게 해야 효율적으로 취합 로직을 작성할 것인가

### 누가 API 조합기 역할을 맡을 것인가?

- 서비스 클라이언트(웹 애플리케이션)
    - 주문 상태 뷰를 구현한 웹 애플리케이션
    - 이 같은 클라이언트가 같은 LAN에서 실행 중이면 효과적으로 조회가 가능
    - 하지만 클라이언트가 방화벽 외부에 있고 네트워크가 느리다면 실용적이지 못하다.
- 애플리케이션의 외부 API가 구현된 API 게이트웨이
    - 쿼리 작업이 애플리케이션 외부 API 중 일부라면 이 방법이 타당
    - 방화벽 외부에서 접근하는 클라이언트(모바일 앱) 등가 API 한 번 호출로 조회 가능하기에 효율적
- 스탠드얼론 서비스
    - ex) 주문 검색 서비스
    - 내부적으로 여러 서비스가 사용하는 작업인 경우
    - 취합 로직이 너무 복잡해 게이트웨이의 일부로 만들기 곤란한 경우
    - 외부에서 접근 가능한 작업을 구현할 경우

### API 조합기는 리액티브 프로그래밍 모델을 사용해야 한다

- 쿼리 작업의 반응 시간을 최대한 줄이려면 API 조합기가 프로바이더 서비스를 병렬 호출해야 한다.
- 하지만 어떤 프로바이더 서비스를 호출하기 위해 다른 서비스의 결과를 먼저 가져와야 하는 경우엔 일부는 순차 호출해야 한다.
- 순차/병렬 서비스 호출이 뒤섞인 로직은 복잡해질 수 있다.
- 성능/확장성 우수한 API 조합기를 작성하기 위해선 리액티브 설계 기법을 동원해야 한다.
    - 자바의 `CompletableFuture`, RxJava의 옵저버블 등

### 7.1.5 API 조합 패턴의 장단점

- 오버헤드 증가
    - 여러 서비스 호출, 여러 DB 쿼리는 오버헤드가 불가피
    - 컴퓨팅/네트워크 리소스가 많이 소모되고 운영 비용도 증가
- 가용성 저하 우려
    - 가용성은 더 많은 서비스가 개입할수록 감소한다.
    - 프로바이더 서비스 불능인 경우 가용성 증가 전략
        - 이전에 캐시한 데이터를 반환
        - 미완성된 데이터를 반환
- 데이터 일관성 결여
    - 여러 DB를 대상으로 쿼리를 실행하기에 일관되지 않은 데이터가 반환될 수 있다.
    - ex) 주문 상태가 `CANCELLED`이지만 주문의 티켓은 아직 취소되지 않았을 수도 있다.

## 7.2 CQRS 패턴

- 엔터프라이즈 애플리케이션 대부분은
  - RDBMS에 트랜잭션을 걸어 레코드를 관리
  - 검색 쿼리는 일래스틱서치나 솔라 등 검색 DB를 이용
- 커맨드 쿼리 책임 분리
  - 여러 서비스의 데이터를 가져오는 쿼리는 이벤트를 이용해 해당 서비스의 데이터를 복제한 읽기 전용 뷰를 유지한다.

### 7.2.1 CQRS의 필요성

- API 조합 패턴만으로는 다중 서비스의 데이터 쿼리를 효율적으로 구현하기 어렵다.

### findOrderHistory() 쿼리 구현

- `findOrderHistory()`는 다음 매개변수를 통해 주문 이력을 조회한다.
  - `consumerId`
  - `OrderHistoryFilter` (시간, 상태, 음식점 및 메뉴 항목을 검색할 키워드 등)
- 모든 서비스가 필터/정렬 용도의 속성을 보관하는 것이 아니기에 API 조합기로 구현하기 까다롭다.
  - ex) 메뉴 항목을 저장하는 서비스는 주문, 주방 서비스 뿐이고 배달, 회계 서비스에선 메뉴 정보가 없기에 키워드로 필터링할 수 없다.
- API 조합기로 키워드 문제 해결하기
  - 배달, 회계 서비스의 모든 데이터를 가져온 후 주문, 주방 서비스 데이터와 인메모리에서 조인
  - 주문, 주방 서비스의 데이터를 조회하고 주문 ID를 통해 다른 서비스의 데이터를 요청
  - API 조합기로 해결하는 방법은 효율성이 많이 떨어진다.

### 어려운 단일 서비스 쿼리: findAvaliableRestaurants()

- 한 서비스의 쿼리도 구현하기 어려울 때가 있다.
  - 데이터를 가진 서비스에 쿼리를 구현하는 것이 부적절한 경우
  - DB 또는 데이터 모델이 효율적인 쿼리를 지원하지 않는 경우
- `findAvailableRestaurants()`
  - 주어진 시점, 위치로 배달 가능한 음식점을 검색하는 기능
  - 어려운 부분이 효율적으로 지리 공간 쿼리를 수행하는 작업이고 이는 DB 능력에 구현이 좌우된다.
  - MongoDB, Postgres, MySQL처럼 지리 공간 데이터를 지원하는 인덱스나 쿼리가 존재한다면 쉽다.
  - 하지만 DB가 지리 공간 기능을 지원하지 않는다면 그런 기능을 지원하는 DB 레플리카를 유지해야 한다.

### 관심사를 분리할 필요성

- 데이터를 가진 서비스에 쿼리를 구현하면 안 될 때도 있다.
  - 어떤 서비스에 쿼리할 데이터의 소유권이 있다고 쿼리를 구현해야한다는 보장은 없다.
- 한 서비스에 너무 많은 책임을 부여하지 않도록 고민해야 한다.
  - 가령 음식점 서비스 개발 팀의 주 임무는 음식점을 잘 관리하는 것이지 성능 좋은 대용량 쿼리를 구현하는 일은 아닐 것이다.

### 7.2.2 CQRS 개요

- MSA에서 쿼리를 구현할 때의 세 가지 난관
  - 여러 서비스의 데이터를 API 조합을 이용해 쿼리하면 비효율적인 인-메모리 조인이 필요
  - 데이터를 가진 서비스는 효율적인 쿼리를 지원하지 않는 DB에 데이터를 저장
  - 데이터를 가진 서비스가 쿼리 작업을 구현할 장소로 적합하지 않아 관심사 분리가 필요

### CQRS는 커맨드와 쿼리를 서로 분리한다.

- CQRS (커맨드 쿼리 책임 분리)
  - 조회(HTTP GET)는 쿼리
  - 생성/수정/삭제(HTTP POST, PUT, DELETE)는 커맨드
  - 양쪽 데이터 모델 사이 동기화는 커맨드가 발행한 이벤트를 쿼리에서 구독하는 식으로 이루어진다.
- 비 CQRS에서는 CRUD 작업을 DB에 매핑된 도메인 모델로 구현한다.
  - 하나의 영속적 데이터 모델은 커맨드, 쿼리를 모두 지원
- CQRS 커맨드 도메인 모델은 CRUD 작업을 처리하고 자체 DB에 매핑한다.
  - 데이터가 바뀔 때마다 도메인 이벤트를 발행한다.
- CQRS 쿼리 모델은 다소 복잡한 쿼리를 처리하며 자체 DB를 가진다.
  - 도메인 이벤트를 구독하고 DB를 수정하는 핸들러가 있다.

### CQRS와 쿼리 전용 서비스

- 쿼리 서비스
  - 커맨드 작업이 없는 오직 쿼리만으로 구성된 API가 존재
  - 이벤트를 구독하여 DB를 항상 최신으로 유지하는 로직 존재
  - 특정 서비스에 종속되지 않기에 스탠드얼론 서빗스로 구현하는 것이 좋다.
- CQRS는 RDBMS를 기록 시스템으로 활용하며너 텍스트 검색 엔진을 이용해 쿼리를 처리하는 방식을 이벤트 기반으로 일반화한 것

### 7.2.3 CQRS의 장점

- MSA에서 쿼리를 효율적으로 구현 가능
  - API 조합 패턴의 비효율적 쿼리를 효율적으로 구현할 수 있다.
- 다양한 쿼리를 효율적으로 구현 가능
  - 각 쿼리가 효율적으로 구현된 하나 이상의 뷰를 정의해 단일 데이터 저장소의 한계를 극복할 수 있다.
- 이벤트 소싱 애플리케이션에서 쿼리가 가능
  - 쿼리 서비스는 이벤트 스트림을 구독해 항상 최신 상태를 유지한다.
- 관심사가 더 분리된다.
  - 커맨드/쿼리 양쪽 모두 관리하기 간편해진다.

### 7.2.4 CQRS의 단점

- 아키테처가 더 복잡하다.
  - 별도의 데이터 저장소를 관리해야 하하기에 운영 복잡도 가중
- 복제 시차를 처리해야 한다.
  - 쿼리 쪽이 이벤트를 받아 뷰를 업데이트하면서 지연이 발생한다.
  - 이전 버전의 애그리거트를 쿼리하게 될 수도 있는 것
