# 04 트랜잭션 관리: 사가

## 4.1 마이크로서비스 아키텍처에서의 트랜잭션 관리

- 단일 DB에 접근하는 모놀리식에서 트랜잭션 관리는 어렵디 않다.
- 다중 DB, 다중 메시지 브로커를 사용하는 모놀리식 애플리케이션이나 MSA에서는 트랜잭션 관리가 어렵다.

### 4.1.1 분산 트랜잭션의 필요성

- `createOrder()`를 예로 설명한다.
    - 주문 내역을 확인하고
    - 소비자 신용카드를 승인하고
    - DB에 주문을 생성하는 작업
- 모놀리식에서 그리고 스프링을 사용한다면 `@Transactional` 어노테이션만으로 ACID 트랜잭션을 보장할 수 있다.
- 하지만 MSA에서는 여러 서비스의 데이터에 접근해야 한다.

### 4.1.2 분산 트랜잭션의 문제점

- 예전에는 분산 트랜잭션으로 여러 서비스, DB, 메시지 브로커에 걸쳐 데이터 일관성을 유지했다.
    - X/Open DTP (Distributed Transaction Processing) 모델 (X/Open XA)
    - XA는 2단계 커밋(2PC)을 이용하여 전체 트랜잭션 참여자가 반드시 커밋 또는 롤백을 하도록 보장한다.
- 분산 트랜잭션은 문제점이 많다.
    - NoSQL, 현대 메시지 브로커는 분산 트랜잭션을 지원하지 않는다.
    - 동기 IPC이기에 가용성이 떨어진다.
- MSA에서 데이터 일관성 유지를 위해선 느슨하게 결합된 비동기 서비스 개념을 토대로 다른 메커니즘이 필요하다.

### 4.1.3 데이터 일관성 유지: 사가 패턴

- 사가 패턴
    - 비동기 메시징을 이용하여 편성한 일련의 로컬 트랜잭션
    - 여러 서비스의 데이터를 업데이트하는 시스템 커맨드마다 사가를 하나씩 정의
    - 각 사가(로컬 트랜잭션)은 ACID 트랜잭션을 적용하여 서비스별 데이터를 업데이트한다.
    - 어느 로컬 트랜잭션이 완료되면 이어서 그다음 로컬 트랜잭션이 실행된다.
- 사가와 기존 ACID 트랜잭션의 차이점
    - 사가에는 ACID 중 격리성(I)이 없다.
    - 사가는 로컬 트랜잭션마다 변경분을 커밋하므로 보상 트랜잭션을 걸어 롤백해야 한다.

### 예제: 주문 생성 사가

- 주문 생성 사가는 6개의 로컬 트랜잭션으로 구성된다.
    1. 주문 서비스: 주문을 `APPROVAL_PENDING` 상태로 생성
    2. 소비자 서비스: 주문 가능한 소비자인지 확인
    3. 주방 서비스: 주문 내역을 확인하고 티켓을 `CREATE_PENDING` 상태로 생성
    4. 회계 서비스: 소비자 신용카드를 승인
    5. 주방 서비스: 티켓 상태를 `AWAITTING_ACCEPTANCE`로 변경
    6. 주문 서비스: 주문 상태를 `APPROVED`로 변경
- 서비스는 로컬 트랜잭션이 완료되면 메시지를 발행하여 다음 사가 단계를 트리거한다.
    - 메시지 수신자가 일시 불능 상태라면 메시지 브로커가 메시지를 버퍼링하여 전달 가능할 때 전달한다.
    - 메시지를 통해 사가 참여자를 느슨하게 결합하고 사가가 반드시 완료되도록 보장하는 것

### 사가는 보상 트랜잭션으로 변경분을 롤백한다.

- (N + 1)번째 사가 트랜잭션이 실패하면 이전 N개 트랜잭션을 언두해야 한다.
    - 개념적으로 단계 Ti에는 Ti의 작용을 언두하는 보상 트랜잭션 Ci가 대응된다.
    - 처음 N개 단계 작용을 언두하려면 사가는 각 Ci를 역순으로 실행하면 된다.
    - Ti … Tn → Tn+ 1 (실패) → Cn … C1
- 주문 생성 사가의 단계별 보상 트랜잭션

| 단계 | 서비스 | 트랜잭션 | 보상 트랜잭션 |
| --- | --- | --- | --- |
| 1 | 주문 서비스 | createOrder() | rejectOrder() |
| 2 | 소비자 서비스 | verifyConsumerDetail() | - |
| 3 | 주방 서비스 | createTicket() | rejectTicket() |
| 4 | 회계 서비스 | authorizeCreditCard() | - |
| 5 | 주방 서비스 | approveTicket() | - |
| 6 | 주문 서비스 | approveOrder() | - |
- 모든 단계에 보상 트랜잭션이 필요한 것은 아니다.
    - 1, 3번째 단계는 다음 단계들이(2, 4) 실패할 가능성이 있으므로 보상 트랜잭션
    - 2단계처럼 읽기 전용 단계인 경우에는 보상 트랜잭션이 필요 없다.
    - 4번째 단계는 절대로 실패하지 않는 단계 다음에 있으므로 피봇 트랜잭션
    - 5, 6번째 단계는 항상 성공하기 때문에 재시도 가능 트랜잭션

## 4.2 사가 편성

- 사가는 단계를 편성하는 로직으로 구성된다.
  - 첫 번째 사가 참여자를 정해 로컬 트랜잭션 실행
  - 트랜잭션이 완료되면 그 다음 사가 참여자를 호출
  - 모든 단계가 실행될 때까지 반복
  - 도중 하나라도 실패하면 보상 트랜잭션을 역순으로 실행
- 사가 편성 로직 종류
  - 코레오그래피: 의사 결정과 순서화를 사가 참여자에게 맡기고 이벤트 교환 방식으로 통신
  - 오케스트레이션: 사가 편성 로직을 사가 오케스트레이터에 중앙화

### 4.2.1 코레오그래피 사가

### 주문 생성 사가 구현: 코레오그래피 스타일

- 주문 정상 처리 흐름

  <img width=600 height=500 src="https://github.com/ldk980130/TIL/assets/78652144/f2a034e5-0ac8-484b-8db7-f6c08c707310">

  1. 주문 서비스: 주문을 `APPROVAL_PENDING` 상태로 생성 → 주문 생성 이벤트 발행
  2. 소비자서비스: 주문 생성 이벤트 수신 → 소비자가 주문 가능한지 확인 → 소비자 확인 이벤트 발행
  3. 회계 서비스: 주문 생성 이벤트 수신 → 신용카드 승인을 `PENDING` 상태로 생성
  4. 주방 서비스: 주문 생성 이벤트 수신 → 주문 내역 확인 → 티켓을 `CREATE_PENDING` 상태로 생성 → 티켓 생성됨 이벤트 발행
  5. 회계 서비스: 티켓 생성 및 소비자 확인 이벤트 수신 → 소비자 신용카드 과금 → 신용카드 승인됨 이벤트 발행
  6. 주방 서비스: 신용카드 승인 이벤트 수신 → 티켓 상태를 `AWAITING_ACCEPTANCE`로 변경
  7. 주문 서비스: 신용카드 이벤트 수신 → 주문 상태를 `APPROVED`로 변경 → 주문 승인됨 이벤트 발행
- 신용카드 과금에서 실패가 발생하는 흐름
  - 1 ~ 4까지는 같음
  1. 회계 서비스: 티켓 생성 및 소비자 확인 이벤트 수신 → 소비자 신용카드 과금 → 신용카드 승인 실패 이벤트 발행
  2. 주방 서비스: 신용카드 승인 실패 이벤트 수신 → 티켓 상태를 `REJECT`로 변경
  3. 주문 서비스: 신용카드 승인 실패 이벤트 수신 → 주문 상태를 `REJECT`로 변경

### 확실한 이벤트 기반 통신

- 코레오그래피 방식 사가는 두 가지 통신 이슈를 고려해야 한다.
  - 사가 참여자가 자신의 DB를 업데이트하고 DB 트랜잭션 일부로 이벤트를 발행하도록 해야 한다.
  - 사가 참여자는 자신이 수신한 이벤트와 자신이 가진 데이터를 연관 지을 수 있어야 한다. (상관관계 ID 이용)

### 코레오그래피 사가의 장단점

- 장점
  - 단순함: 비즈니스 객체를 생성, 수정, 삭제할 때 서비스가 이벤트를 발행
  - 느슨한 결합: 참여자는 이벤트를 구독할 뿐 서로를 직접 알지 못한다.
- 단점
  - 이해하기 어렵다: 사가를 어느 한 곳에 정의한 게 아니라 여러 서비스에 구현 로직이 흩어져 있다.
  - 서비스 간 순환 의존성: 참여자가 서로 이벤트를 구독하면서 순환 의존성이 발생하기 쉽다.
  - 단단히 결합될 위험성: 사가 참여자는 자신에게 영향을 미치는 이벤트를 모두 구독해야 한다.
    - 회계 서비스만 해도 소비자 신용카드를 과금/환불 처리하게 만드는 모든 이벤트를 구독해야 한다.
    - 회계 서비스는 주문 서비스의 주문 주기와 맞물려 업데이트되어야 하는 위험이 있다.

### 4.2.2 오케스트레이션 사가

- 사가 참여자가 할 일을 알려주는 오케스트레이터 클래스를 정의
- 사가 오케스트레이터는 커맨드/비동기 응답 상호 작용을 통해 참여자와 통신한다.
- 오케스트레이터는 사가 참여자에게 할 일을 커맨드 메시지에 적어 보내고 응답을 처리하면 다음 사가 참여자를 호출한다.

### 주문 생성 사가 구현: 오케스트레이션 스타일

- 주문 서비스는 주문 및 주문 생성 사가 오케스트레이터를 생성 후 문제가 없다면 아래와 같이 진행될 것이다.

  <img width=600 height=500 src="https://github.com/ldk980130/TIL/assets/78652144/9906041c-e95f-4ce3-9419-7375f227c425">

  1. 사가 오케스트레이터가 소비자 확인 커맨드를 소비자 서비스에 전송
  2. 소비자 서비스는 소비자 확인 메시지를 응답
  3. 사가 오케스트레이터는 티켓 생성 커맨드를 주방 서비스에 전송
  4. 주방 서비스는 티켓 생성 메시지를 응답
  5. 사가 오케스트레이터는 신용카드 승인 메시지를 회계 서비스에 전송
  6. 회계 서비스는 신용카드 승인됨 메시지를 응답
  7. 사가 오케스트레이터는 티켓 승인 커맨드를 주방 서비스에 전송
  8. 사가 오케스트레이터는 주문 승인 커맨드를 주문 서비스에 전송
- 위 시나리오 마지막 단계에서 사가 오케스트레이터는 주문 승인 커맨드를 주문 서비스(자기 자신)에 전송한다.
  - 비록 자기 자신이 주문 서비스이지만 일관성 차원에서 주문 서비스가 다른 참여자인 것처럼 취급하는 것

### 사가 오케스트레이터를 상태 기계로 모델링

- 상태 기계는 상태와 이벤트에 의해 트리거되는 상태 전이로 구성된다.
  - 전이가 발생할 때마다 액션이 일어난다.
  - 사가의 액션은 사가 참뎌자를 호출하는 작용
  - 상태 간 전이는 사가 참여자가 로컬 트랜잭션을 완료하는 시점에 트리거된다.
- 상태 기계는 효율적으로 테스트할 수 있다.
  - 상태 기계로 사가를 모델링하면 설계, 구현, 테스트가 더 쉬워진다.
- 상태 기계로 모델링한 주문 생성 사가
  - 소비자 확인: 초기 상태. 사가는 소비자 서비스가 검증할 때까지 기다린다.
  - 티켓 생성: 사가는 티켓 생성 커맨드에 대한 응답을 기다린다.
  - 신용카드 승인: 회계 서비스가 소비자 신용카드를 승인할 때까지 기다린다.
  - 주문 승인됨: 사가가 성공적으로 완료되었음을 나타내는 최종 상태
  - 주문 거부됨: 참여자 중 하나가 주문을 거부했음을 나타내는 최종 상태

### 사가 오케스트레이션과 트랜잭셔널 메시징

- 오케스트레이션 사가는 DB를 업데이트하는 서비스와 메시지를 발행하는 서비스가 단계마다 존재한다.
  - 사가 오케스트레이터가 사가 참여자에게 메시지를 보내면 사가 참여자는 자신의 DB를 업데이트 후 응답 메시지를 보낸다.
- 이 때 서비스는 트랜잭셔널 메시지를 사용해 DB 업데이트와 메시지 발행 작업을 원자적으로 처리해야 한다.

### 오케스트레이션 사가의 장단점

- 장점
  - 의존 관계 단순화
    - 오케스트레이터는 참여자를 호출하지만 참여자는 오케스트레이터를 호출하지 않는다.
  - 낮은 결합도
    - 각 서비스는 오케스트레이터가 호출하는 API를 구현할 뿐 사가 참여자의 이벤트 발행은 몰라도 된다.
  - 관심사를 더 분리하고 비즈니스 로직을 단순화
    - 사가 편성 로직이 오케스트레이터 한곳에만 있기에 도메인 객체가 더 단순해진다.
    - 자신이 참여한 사가에 대해서 알지 못한다.
    - 사가 단계에 대응되는 중간 상태가 거의 사라지기에 비즈니스 로직이 단순해진다.
- 단점
  - 비즈니스 로직을 오케스트레이터에 너무 많이 중앙화하면 똑똑한 오케스트레이터 하나가 깡통 서비스에 일일이 할 일을 지시하는 모양새가 될 수 있다.
  - 이 문제는 오케스트레이터가 순서화만 담당하고 여타 비즈니스 로직은 갖고 있지 않도록 설계하면 해결할 수 있다.
- 아주 단순한 사가가 아니라면 오케스트레이션 방식을 권장한다.
