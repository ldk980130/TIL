# 04 트랜잭션 관리: 사가

## 4.1 마이크로서비스 아키텍처에서의 트랜잭션 관리

- 단일 DB에 접근하는 모놀리식에서 트랜잭션 관리는 어렵디 않다.
- 다중 DB, 다중 메시지 브로커를 사용하는 모놀리식 애플리케이션이나 MSA에서는 트랜잭션 관리가 어렵다.

### 4.1.1 분산 트랜잭션의 필요성

- `createOrder()`를 예로 설명한다.
    - 주문 내역을 확인하고
    - 소비자 신용카드를 승인하고
    - DB에 주문을 생성하는 작업
- 모놀리식에서 그리고 스프링을 사용한다면 `@Transactional` 어노테이션만으로 ACID 트랜잭션을 보장할 수 있다.
- 하지만 MSA에서는 여러 서비스의 데이터에 접근해야 한다.

### 4.1.2 분산 트랜잭션의 문제점

- 예전에는 분산 트랜잭션으로 여러 서비스, DB, 메시지 브로커에 걸쳐 데이터 일관성을 유지했다.
    - X/Open DTP (Distributed Transaction Processing) 모델 (X/Open XA)
    - XA는 2단계 커밋(2PC)을 이용하여 전체 트랜잭션 참여자가 반드시 커밋 또는 롤백을 하도록 보장한다.
- 분산 트랜잭션은 문제점이 많다.
    - NoSQL, 현대 메시지 브로커는 분산 트랜잭션을 지원하지 않는다.
    - 동기 IPC이기에 가용성이 떨어진다.
- MSA에서 데이터 일관성 유지를 위해선 느슨하게 결합된 비동기 서비스 개념을 토대로 다른 메커니즘이 필요하다.

### 4.1.3 데이터 일관성 유지: 사가 패턴

- 사가 패턴
    - 비동기 메시징을 이용하여 편성한 일련의 로컬 트랜잭션
    - 여러 서비스의 데이터를 업데이트하는 시스템 커맨드마다 사가를 하나씩 정의
    - 각 사가(로컬 트랜잭션)은 ACID 트랜잭션을 적용하여 서비스별 데이터를 업데이트한다.
    - 어느 로컬 트랜잭션이 완료되면 이어서 그다음 로컬 트랜잭션이 실행된다.
- 사가와 기존 ACID 트랜잭션의 차이점
    - 사가에는 ACID 중 격리성(I)이 없다.
    - 사가는 로컬 트랜잭션마다 변경분을 커밋하므로 보상 트랜잭션을 걸어 롤백해야 한다.

### 예제: 주문 생성 사가

- 주문 생성 사가는 6개의 로컬 트랜잭션으로 구성된다.
    1. 주문 서비스: 주문을 `APPROVAL_PENDING` 상태로 생성
    2. 소비자 서비스: 주문 가능한 소비자인지 확인
    3. 주방 서비스: 주문 내역을 확인하고 티켓을 `CREATE_PENDING` 상태로 생성
    4. 회계 서비스: 소비자 신용카드를 승인
    5. 주방 서비스: 티켓 상태를 `AWAITTING_ACCEPTANCE`로 변경
    6. 주문 서비스: 주문 상태를 `APPROVED`로 변경
- 서비스는 로컬 트랜잭션이 완료되면 메시지를 발행하여 다음 사가 단계를 트리거한다.
    - 메시지 수신자가 일시 불능 상태라면 메시지 브로커가 메시지를 버퍼링하여 전달 가능할 때 전달한다.
    - 메시지를 통해 사가 참여자를 느슨하게 결합하고 사가가 반드시 완료되도록 보장하는 것

### 사가는 보상 트랜잭션으로 변경분을 롤백한다.

- (N + 1)번째 사가 트랜잭션이 실패하면 이전 N개 트랜잭션을 언두해야 한다.
    - 개념적으로 단계 Ti에는 Ti의 작용을 언두하는 보상 트랜잭션 Ci가 대응된다.
    - 처음 N개 단계 작용을 언두하려면 사가는 각 Ci를 역순으로 실행하면 된다.
    - Ti … Tn → Tn+ 1 (실패) → Cn … C1
- 주문 생성 사가의 단계별 보상 트랜잭션

| 단계 | 서비스 | 트랜잭션 | 보상 트랜잭션 |
| --- | --- | --- | --- |
| 1 | 주문 서비스 | createOrder() | rejectOrder() |
| 2 | 소비자 서비스 | verifyConsumerDetail() | - |
| 3 | 주방 서비스 | createTicket() | rejectTicket() |
| 4 | 회계 서비스 | authorizeCreditCard() | - |
| 5 | 주방 서비스 | approveTicket() | - |
| 6 | 주문 서비스 | approveOrder() | - |
- 모든 단계에 보상 트랜잭션이 필요한 것은 아니다.
    - 1, 3번째 단계는 다음 단계들이(2, 4) 실패할 가능성이 있으므로 보상 트랜잭션
    - 2단계처럼 읽기 전용 단계인 경우에는 보상 트랜잭션이 필요 없다.
    - 4번째 단계는 절대로 실패하지 않는 단계 다음에 있으므로 피봇 트랜잭션
    - 5, 6번째 단계는 항상 성공하기 때문에 재시도 가능 트랜잭션
