# 02 객체지향 프로그래밍
## 01 영화 예매 시스템

<img src="https://github.com/ldk980130/TIL/assets/78652144/438b2d51-1312-49ec-83e4-a0153309363a" width=700 height=250>

- ‘영화’
    - 영화에 대한 기본 정보 (제목, 상영시간, 가격 정보 등)
- ‘상영’
    - 실제 영화를 관람하는 사건 (상영 일자, 시간, 순번 등)
    - 하나의 영화는 하루에 여러번 상영될 수 있다.
    - 사람들은 영화를 예매한다고 표현하지만 실제로는 상영되는 영화를 관람할 수 있는 권리를 구매하는 것
- ‘할인 조건’
    - 가격의 할인 여부를 결정
    - ‘순서 조건’ - 상영 순번을 이용해 할인 여부 결정
    - ‘기간 조건’ - 영화 상영 시작 시간을 이용해 할인 여부 결정
    - 다수의 할인 조건을 함께 지정할 수 있고 순서 조건과 기간 조건을 섞는 것도 가능하다.
- ‘할인 정책’
    - 할인 요금을 결정
    - ‘금액 할인 정책’ - 일정 금액을 할인하는 방식
    - ‘비율 할인 정책’ - 일정 비율의 요금을 할인하는 방식
    - 영화별로 하나의 할인 정책만 할당 가능
    - 할인 정책은 1인 기준으로 책정된다.
- 할인 정책과 할인 조건이 적용된 영화 예시
    - 하나의 할인 조건이라도 만족하면 할인 정책을 적용

| 영화 | 할인 정책 | 할인 조건 |
| --- | --- | --- |
| 아바타 | 금액 할인 정책 | 순번 조건 (조조 상영)
순번 조건 (10회 상영)
기간 조건(월 10시 ~ 12시 사이 상영 시작)
기간 조건(목 18시 ~ 21시 사이 상영 시작) |

## 02 객체지향 프로그래밍을 향해

- 어떤 클래스(class)가 필요한지 먼저 고민한다면 그것은 객체지향의 본질과는 거리가 멀다.
- 클래스를 고민하기 전에 어떤 객체들이 필요한지 고민하라
    - 어떤 객체가 어떤 상태와 행동을 가지는지
- 객체를 독립적인 존재가 아닌 협력하는 공동체의 일원으로 봐야 한다.

### 도메인의 구조를 따르는 프로그램 구조

- 도메인
    - 소프트웨어를 만들 때 문제를 해결하기 위해 사용하는 분야를 뜻한다.
- 객체지향 패러다임이 강력한 이유
    - 요구사항을 분석하는 초기 단계부터 구현하는 마지막 단계까지 객체라는 동일한 추상화 기법을 사용할 수 있기 때문

### 클래스 구현하기

- `Screening` (상영)

    ```java
    public class Screening {
        private Movie movie;
        private int sequence;
        private LocalDateTime whenScreened;
    
        public Screening(Movie movie, int sequence, LocalDateTime whenScreened) {
            this.movie = movie;
            this.sequence = sequence;
            this.whenScreened = whenScreened;
        }
    
        public LocalDateTime getStartTime() {
            return whenScreened;
        }
    
        public boolean isSequence(int sequence) {
            return this.sequence == sequence;
        }
    
        public Money getMovieFee() {
            return movie.getFee();
        }
    
        public Reservation reserve(Customer customer, int audienceCount) {
            return new Reservation(customer, this, calculateFee(audienceCount),
                    audienceCount);
        }
    
        private Money calculateFee(int audienceCount) {
            return movie.calculateMovieFee(this).times(audienceCount);
        }
    }
    ```

    - 인스턴스 변수는 `private`, 메서드는 `public`

> 클래스를 구현하거나 사용할 때 가장 중요한 것은 클래스 경계를 구분 짓는 것. 훌륭한 설계의 핵심은 어떤 부분을 공개하고 숨길지 결정하는 것. 경계의 명확성이 객체의 자율성을 보장한다.
>
- 자율적인 객체
    - 객체는 ‘상태’와 ‘행동’을 함께 지니는 복합적 존재
    - 상태와 행동을 캡슐화해야 한다.
    - 캡슐화와 접근 제어 메커니즘을 통해 객체를 자율적인 존재로 만들 수 있다.
    - 캡슐화와 접근 제어의 측면에서 객체는 ‘퍼블릭 인터페이스’와 ‘구현’으로 나뉜다.
    - 인터페이스와 구현의 분리(separation of interface and implementation) 원칙을 따라야 한다.
    - 객체는 상태는 숨기고 행동만 외부에 공개해야 한다.
- 프로그래머의 자유
    - 프로그래머는 ‘클래스 작성자’와 클라이언트 프로그래머’로 구분된다.
    - ‘클라이언트 프로그래머’의 목표는 필요한 클래스를 엮어 애플리케이션을 빠르고 안정적으로 구축하는 것
    - ‘클래스 작성자’의 목표는 ‘클라이언트 프로그래머’에게 필요한 부분만 공개하고 나머지는 숨기는 것 → 구현 은닉

### 협력하는 객체들의 공동체

- 영화 예매 기능을 만들어보자.
    - `Screening.reserve()` 메서드는 예매 후 예매 정보를 가지는 `Reservation` 인스턴스를 반환한다.

    ```java
    public Reservation reserve(Customer customer, int audienceCount) {
        return new Reservation(
                    customer, 
                    this, 
                    calculateFee(audienceCount),
                    audienceCount
        );
    }
    
    private Money calculateFee(int audienceCount) {
        return movie.calculateMovieFee(this).times(audienceCount);
    }
    ```

    - `Movie.cacluateFee()` 메서드로 반환된 Money 객체가 `times()` 메서드를 통해 인원 수만큼의 가격을 곱한다.
        - [Money 코드](https://github.com/eternity-oop/object/blob/master/chapter02/src/main/java/org/eternity/money/Money.java)
        - `Money` 객체를 통해 돈과 관련된 로직의 중복 구현을 막고 도메인 의미를 풍부하게 표현할 수 있다.
- `Reservation` 클래스

    ```java
    public class Reservation {
        private Customer customer; // 고객
        private Screening Screening; // 상영 정보
        private Money fee; // 예매 요금
        private int audienceCount; // 인원 수
    
        public Reservation(Customer customer, Screening Screening, Money fee, int audienceCount) {
            this.customer = customer;
            this.Screening = Screening;
            this.fee = fee;
            this.audienceCount = audienceCount;
        }
    }
    ```

    - `Screening`, `Movie`, `Reservation` 인스턴스들은 서로 호출하며 상호작용하는데 이를 ‘협력’이라 부른다.
    - `Screening` → `Reservation` 생성
    - `Screening` → `Movie` 사용 (calculateFee)
- 객체지향 프로그램을 작성할 때는
    - 협력 관점에서 어떤 객체가 필요할지 결정하고
    - 공통 상태와 행위를 구현하기 위해 클래스를 작성한다.

### 협력에 관한 짧은 이야기

- 객체 내부 상태는 외부에서 접근하지 못하지만 퍼블릭 인터페이스를 통해선 내부 상태에 접근 가능하다.
- 객체는 다른 객체의 인터페이스를 통해 행동을 ‘요청’할 수 있고 요청 받은 객체는 자율적으로 행동한 후 ‘응답’한다.
- 객체 간 상호작용의 유일한 방법은 ‘메시지 전송’과 ‘매시지 수신’이다.
    - 수신된 메시지를 처리하기 위한 자신만의 방법을 ‘메서드(method)’라 부른다.
- 메서드와 메시지를 구분하는 것은 매우 중요
    - 다형성 개념의 출발
