# 01 객체, 설계 

## 01 티켓 판매 애플리케이션 구현하기

- 상황
    - 추첨을 통해 선정된 관람객에게 공연을 무료로 관람할 수 있는 이벤트
- 기능 요구 사항
    - 이벤트 당첨자는 초대장을 티켓으로 교환 후 입장 가능
    - 이벤트 당첨자가 아니면 티켓 판매 후 입장 가능

### 객체 설계

- `Invitation`
    - [코드](https://github.com/eternity-oop/object/blob/master/chapter01/src/main/java/org/eternity/theater/step01/Invitation.java)
    - 이벤트 당첨자에게 발송되어 티켓과 교환 가능
    - `when`: 공연을 관람할 수 있는 초대일자
- `Ticket`
    - [코드](https://github.com/eternity-oop/object/blob/master/chapter01/src/main/java/org/eternity/theater/step01/Ticket.java)
    - 공연을 관람하려는 모든 사람은 티켓을 소지해야 한다.
    - 이벤트 당첨자가 아니면 티켓을 구매해야 한다.
- `Bag`
    - [코드](https://github.com/eternity-oop/object/blob/master/chapter01/src/main/java/org/eternity/theater/step01/Bag.java)
    - 관람객의 소지품을 보관하는 용도
    - 초기 `Bag`의 상태는 다음 두 가지다.
        - 현금과 초대장을 함께 보관
        - 초대장 없이 현금만 보관

      → 생성자를 통해 제약 구현

- `Audience`
    - [코드](https://github.com/eternity-oop/object/blob/master/chapter01/src/main/java/org/eternity/theater/step01/Audience.java)
    - 관람객은 가방을 소지
- `TicketOffice`
    - [코드](https://github.com/eternity-oop/object/blob/master/chapter01/src/main/java/org/eternity/theater/step01/TicketOffice.java)
    - 판매하거나 교환해줄 티켓 목록 소지
- `TicketSeller`
    - [코드](https://github.com/eternity-oop/object/blob/master/chapter01/src/main/java/org/eternity/theater/step01/TicketSeller.java)
    - 판매원은 자신이 일하는 매표소를 알고 있다.
    - 초대장을 티켓으로 교환하거나 판매한다.
- `Theater`

    ```java
    public class Theater {
        private TicketSeller ticketSeller;
    
        public Theater(TicketSeller ticketSeller) {
            this.ticketSeller = ticketSeller;
        }
    
        public void enter(Audience audience) {
            if (audience.getBag().hasInvitation()) {
                Ticket ticket = ticketSeller.getTicketOffice().getTicket();
                audience.getBag().setTicket(ticket);
            } else {
                Ticket ticket = ticketSeller.getTicketOffice().getTicket();
                audience.getBag().minusAmount(ticket.getFee());
                ticketSeller.getTicketOffice().plusAmount(ticket.getFee());
                audience.getBag().setTicket(ticket);
            }
        }
    }
    ```

    - 소극장이 관람객을 맞이하는 `enter` 메서드를 구현
    - 관람객의 초대장 소지 유무에 따라 티켓을 알맞게 교환

## 02 무엇이 문제인가

- 로버트 마틴에 따르면 모든 모듈은
    - 제대로 실행돼야 한다.
    - 변경이 용이해야 한다.
    - 이해하기 쉬워야 한다.
- 앞서 작성한 코드는 변경 용이성과 가독성이 좋지 않다.

### 예상을 빗나가는 코드

- 관람객과 판매원이 소극장의 통제를 받는 수동적인 존재
    - 관람객 입장에선 소극장이 자신의 가방을 마음대로 뒤지는 것
    - 판매원 입장에서도 소극장이 매표소에 보관 중인 티켓과 현금에 마음대로 접근 가능
- 이해 가능한 코드란 동작이 우리 예상에서 벗어나지 않는 코드
    - 현실에선 관람객이 직접 자신의 가방에서 초대장을 꺼내 건낸다.
    - 판매원은 티켓을 직접 꺼내 관람객에게 전달한다.
    - 현재 코드는 우리 상식과 너무 다르다.
- 위 코드를 이해하기 위해선 여러 세부 사항을 많이 알고 있어야 한다.
    - `Audience`가 `Bag`을 가지고 있고
    - `Bag` 안에는 현금과 티켓이 있고
    - `TicketSeller`는 `TicketOffice`에서 티켓을 판매하고
- 가장 큰 문제는 변경에 취약하다는 것
    - `Audience`와 `TicketSeller`를 변경할 경우`Theater`도 함께 변경해야 함

### 변경에 취약한 코드

- 관람객이 가방을 들고 있다는 가정이 바뀌는 경우
    - `Audience` 클래스에서 `Bag` 제거 (당연히 변경됨)
    - `Theater`의 `enter` 메서드 수정 (변경이 당연하지 않음)
- 객체가 다른 객체의 내부에 대해서 더 많이 알수록 더 변경하기 어려워진다.
- 이는 객체 사이의 의존성과 관련된 문제
    - 의존성은 변경에 대한 영향을 암시
- 우리의 목표는 애플리케이션을 구현하는 데 필요한 최소한의 의존성만 유지하는 것
    - 의존성 정도를 낮춘다 → 결합도를 낮추는 것
    - 결합도가 높으면 변경될 확률도 높아진다.

## 03 설계 개선하기

- `Theater`가 `Audience`와 `TicketSeller`에 관해 너무 자세히 알지 못하도록 정보를 차단하면 된다.
- 즉 관람객과 판매원을 자율적인 존재로 만들면 된다.

### 자율성을 높이자

- `Theater`에서 `TicketOffice`에 접근하는 모든 코드를 `TicketSeller` 내부로 숨기기

    ```java
    public class Theater {
        private TicketSeller ticketSeller;
    
        public Theater(TicketSeller ticketSeller) {
            this.ticketSeller = ticketSeller;
        }
    
        public void enter(Audience audience) {
            ticketSeller.sellTo(audience);
        }
    }
    
    public class TicketSeller {
        private TicketOffice ticketOffice;
    
        public TicketSeller(TicketOffice ticketOffice) {
            this.ticketOffice = ticketOffice;
        }
    
        public void sellTo(Audience audience) {
            if (audience.getBag().hasInvitation()) {
                Ticket ticket = ticketSeller.getTicketOffice().getTicket();
                audience.getBag().setTicket(ticket);
            } else {
                Ticket ticket = ticketSeller.getTicketOffice().getTicket();
                audience.getBag().minusAmount(ticket.getFee());
                ticketSeller.getTicketOffice().plusAmount(ticket.getFee());
                audience.getBag().setTicket(ticket);
            }
    
        }
    }
    ```

    - `Theater`에서 `TicketOffice`에 대한 의존성이 사라졌다.
    - 캡슐화를 통해 결합도를 낮춰 변경하기 쉬운 객체를 만들자.
    - `Theater`는 `TicketSeller`가 `Audience`에게 티켓을 교환해준다는 사실만 알면 된다.

> 객체를 인터페이스와 구현 부로 나누고 인터페이스만 공개하는 것은 객체 사이 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 기본적인 설계 원칙
>
- `TicketSeller`에서 `Audience`에 대한 캡슐화를 개선할 수도 있다.
    - `Audience`에 `buy` 메서드를 추가하고 `getBag` 메서드에 접근하는 부분을 `buy`로 옮기면 `Bag`을 감출 수 있다.

    ```java
    public class TicketSeller {
        private TicketOffice ticketOffice;
    
        public TicketSeller(TicketOffice ticketOffice) {
            this.ticketOffice = ticketOffice;
        }
    
        public void sellTo(Audience audience) {
            Long amount = audience.buy(ticketOffice.getTicket());
            ticketOffice.plusAmount(amount);
        }
    }
    
    public class Audience {
        private Bag bag;
    
        public Audience(Bag bag) {
            this.bag = bag;
        }
    
        public Long buy(Ticket ticket) {
            if (bag.hasInvitation()) {
                bag.setTicket(ticket);
                return 0L;
            } else {
                bag.setTicket(ticket);
                bag.minusAmount(ticket.getFee());
                return ticket.getFee();
            }
        }
    }
    ```
