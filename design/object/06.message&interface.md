# 06 메시지와 인터페이스

## 01 협력과 메시지

### 클라이언트-서버 모델

- 클라이언트-서버 모델
    - 두 객체 사이 협력 관계를 설명하기 위해 사용하는 메타포
    - 협력은 클라이언트가 서버의 서비스를 요청하는 단방향 상호작용
- 협력 관점에서 객체는 두 가지 종류의 메시지 집합으로 구성된다.
    - 객체가 수신하는 메시지 집합
    - 외부의 객체에게 전송하는 메시지 집합

### 메시지와 메시지 전송

- 메시지는 객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단
    - 메시지는 오퍼레이션명과 인자로 구성된다.
- 객체가 다른 객체에 도움을 요청하는 것을 메시지 전송이라 부른다.
    - 메시지 전송은 메시지 수신자, 오퍼레이션명, 인자의 조합
    - ex) `condition.isSatisfiedBy(screening)`에서 `수신자.오퍼레이션명(인자)`로 볼 수 있다.

### 메시지와 메서드

- 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 메서드라고 부른다.
    - 코드 상에서 동일한 이름의 변수(`condition`)에게 메시지를 전송하더라도 객체 타입에 따라 실행되는 메서드는 달라질 수 있다.
- 메시지와 메서드의 구분은 메시지 전송자와 수신자가 느슨하게 결합될 수 있게 한다.
    - 결합도를 낮춤으로써 유연하고 확장 가능한 코드를 작성할 수 있게 한다.

### 퍼블릭 인터페이스와 오퍼레이션

- 퍼블릭 인터페이스
    - 객체가 의사소통을 위해 외부에 공개하는 메시지 집합
    - 퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션이라 부른다.
- 퍼블릭 인터페이스 관점에선 ‘메서드 호출’보다는 ‘오퍼레이션 호출’이라는 용어가 더 적절하다.
    - 오퍼레이션 호출을 해석하고 메시지를 수신한 객체의 실제 타입 기반으로 적절한 메서드를 찾아 실행하기 때문

### 시그니처

- 시그니처
    - 오퍼레이션(또는 메서드)의 이름과 파라미터 목록을 합친 것
    - 오퍼레이션은 실행 코드 없이 시그니처만을 정의한 것
    - 메서드는 시그니처에 구현을 더한 것
- 오퍼레이션 관점에서 다형성이란 동일한 오퍼레이션 호출에 서로 다른 메서드들이 실행되는 것

## 02 인터페이스와 설계 품질

- 좋은 인터페이스는 ‘최소한의 인터페이스’와 ‘추상적인 인터페이스’라는 조건을 만족해야 한다.
    - 최소한의 인터페이스 - 꼭 필요한 오퍼레이션만을 인터페이스에 포함
    - 추상적인 인터페이스 - 어떻게 수행하는지가 아니라 무엇을 하는지를 표현
    - 이 둘을 잘 지키려면 책임 주오 설계 방법을 사용
- 퍼블릭 인터페이스의 품질에 영향을 미치는 원칙
    - 디미터 법칙
    - 묻지 말고 시켜라
    - 의도를 드러내는 인터페이스
    - 명령-쿼리 분리

### 디미터 법직

- 디미터 법칙을 요약하면 객체 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것이다.
    - “낯선 자에게 말하지 말라”, “오직 인접한 이웃하고만 말하라.”
    - 자바에선 “오직 하나의 도트(`.`)만 사용하라”라는 말로 요약되기도 한다.
- 디미터 법칙을 따르기 위해선 클래스가 특정 조건을 만족하는 대상에게만 메시지를 전송하도록 해야 한다.
- 클래스 C와 C의 모든 메서드 M에 대해 M이 메시지를 전송할 수 있는 모든 객체는 아래와 같다.
    - M의 인자로 전달된 클래스 (C 자체 포함)
    - C의 인스턴스 변수의 클래스
- 다르게 말해서 클래스 내부 메서드가 아래 조건을 만족하는 인스턴스에게만 메시지를 전송하도록 해야 한다.
    - this 객체
    - 메서드의 매개변수
    - this의 속성
    - this의 속성인 컬렉션 요소
    - 메서드 내에 생성된 지역 객체
- 디미터의 법칙을 따르면 메시지 수신자 내부 구조가 전송자에게 노출되지 않고 전송자는 수신자 내부 구현에 결합되지 않는다.
    - 낮은 결합도를 유지할 수 있다.
- 디미터 법칙 위반 사례
    - `screening.getMovie().getDiscountConditions()`
- 하지만 무비판적으로 디미터 법칙을 수용하면 응집도가 낮아질 수도 있다.

### 묻지 말고 시켜라

- 훌륭한 메시지는 객체 상태에 관해 묻지 않고 원하는 것을 시켜야 한다는 사실을 강조한다.
    - 메시지 전송자는 수신자의 상태를 기반으로 결정을 내린 후 수신자 상태를 바꿔서는 안 된다. (캡슐화 위반)
- 훌륭한 인터페이스는 객체가 어떻게 작업을 수행하는지를 노출해서는 안 된다.

### 의도를 드러내는 인터페이스

- 켄트 벡에 의하면 메서드를 명명하는 두 가지 방법이 있다.
    - 메서드가 작업을 어떻게 수행하는지 나타내도록 하기
    - ‘어떻게’가 아닌 ‘무엇’을 하는지 드러내기
- 메서드가 작업을 어떻게 수행하는지 나타내면 문제가 발생한다.

    ```java
    public class PeriodCondition {
        public boolean isSatisfiedByPeriod(Screening screening) {...}
    }
    
    public class SequenceCondition {
        public boolean isSatisfiedBySequence(Screening screening) {...}
    }
    ```

    - 메서드에 대해 제대로 커뮤니케이션하지 못한다.
        - 클라이언트 관점에서 위 두 메서드는 동일한 작업을 수행하지만 이름이 다르다.
        - 내부 구현을 정확하게 이해하지 못한다면 동일한 작업을 수행한다는 것을 알아채기 어렵다.
    - 메서드 수준에서 캡슐화를 위반한다.
        - 클라이언트로 하여금 협력 객체 종류를 알도록 강요한다.
        - 할인 조건을 변경하려면 참조 객체를 변경해야할 뿐만 아니라 메서드 이름도 변경해야 한다.
        - 로직이 달라져도 메서드 이름이 변경되어야 한다.
- ‘무엇’을 하는지 드러내는 메서드 이름은 코드를 이해하기 쉽고 유연하게 만든다.

    ```java
    public interface DiscountCondition {
        boolean isSatisfiedBy(Screening screening);
    }
    ```

    - 클라이언트 입장에서 어떤 할인 조건 방법을 선택하든 동일한 메서드를 동일한 방식으로 사용할 수 있다.
    - 이처럼 무엇을 하느냐에 따라 이름 짓는 패턴을 ‘의도를 드러내는 선택자’라 부른다.
- 도메인 주도 설계에서 에릭 에반스는 이를 인터페이스 레벨로 확장한 ‘의도를 드러내는 인터페이스’를 제시했다.
    - 구현과 관련된 모든 정보를 캡슐화해야 한다.
    - 퍼블릭 인터페이스에는 협력과 관련된 의도만을 표현해야 한다.
