# APPENDIX B. 타입 계층의 구현

- 타입은 다양한 방법으로 구현할 수 있다.
    - 클래스는 타입을 구현하는 한 가지 방법일 뿐이다.
- 타입 계층은 다양한 방식으로 구현된 타입들을 하나의 타입 계층 안에 조합할 수 있어 상황이 더 복잡하다.
    - 자바에선 인터페이스와 클래스로 개별 타입 구현 후 이 두 가지 타입 구현체를 함께 포함하도록 계층을 구성할 수 있다.
- 타입 계층은 동일한 메시지에 대한 행동 호환성을 전제로 하기에 타입 계층 구현은 다형성을 구현하는 방법이기도 하다.
- 타입과 타입 계층을 구현한다고 서브타이핑 관계가 보장되는 것은 아니다.
    - 서브 타입이 슈퍼 타입을 대체하는 리스코프 치환 원칙을 준수해야 올바른 타입 계층이다.
    - 리스코프 치환 원칙을 지키는 것은 개발자의 책임이다.

## 클래스를 이용한 타입 계층 구현

- 타입은 객체의 퍼블릭 인터페이스를 가리킨다.
    - 대부분 객체지향 언어에서 결과적으로 클래스는 객체 타입과 구현을 동시에 정의하는 것과 같다.
- 타입을 구현할 수 있는 방법이 단 한가지만 존재한다면 타입과 클래스를 동일하게 취급해도 무방하다.
    - 구현체가 하나밖에 없는 경우, 앞으로도 그럴 것 같은 경우
- 퍼블릭 인터페이스는 동일하지만 다른 방식으로 구현해야 한다면 상속을 이용할 수 있을 것이다.
    - 자식 클래스가 부모 클래스의 구현과 퍼블릭 인터페이스를 재사용할 수 있기에 쉽게 타입 계층을 구현할 수 있다.
    - 하지만 상속은 부모, 자식 간 강결합을 유발하기에 구체 클래스를 상속 받는 것은 피해야 한다.

## 인터페이스를 이용한 타입 계층 구현

- 게임 개발을 한다고 가정해보자. 게임 플레이에 영향을 끼치는 객체들을 동일 타입으로 분류해야 한다. (`GameObject`)
    - 화면에 표시 되어야 하는 타입 - `Displayable`
        - 다른 유닛과 부딪힐 수 있는 타입 - `Collidable`
        - 직접 조작 가능한 타입 - `Player`
        - 적대적 유닛 타입 - `Monster`
    - 효과 타입 - `Effect`
        - 사운드 효과 - `Sound`
    - `Displayable`이면서 `Effect`인 것
        - 폭발 효과 - `Explosion`
- 위 타입들을 클래스와 상속을 통해 구현하려면 문제가 있다.
    - `Explosion`을 구현하기 위한 다중 상속이 불가능하다.
    - 게다가 이들을 동일한 상속 계층에 구현하고 싶지도 않다.
- 인터페이스를 사용해 타입 계층을 구현할 수 있다.
    - 인터페이스가 다른 인터페이스를 화장하도록 만들면 슈퍼 타입과 서브 타입 간 계층을 구성할 수 있다.

```java
public interface GameObject {
  String getName();
}

public interface Displayable extends GameObject {
  Point getPosition();
  void update(Graphics graphics);
}

public interface Effect extends GameObject {
  void activate()
}

public interface Collidable extends Displayable {
  boolean collideWith(Collidable other);
}
```

- 인터페이스와 클래스를 조합하면 다중 상속의 딜레마에 빠지지 않고 단일 상속 계층으로 인한 결합도 문제도 피할 수 있다.

```java
public class Player implements Collidable {
// ...
}

public class Monster implements Collidable {
// ...
}

public class Sound implements Effect {
// ...
}

public class Explosion implements Displayable, Effect {
// ...
}
```

- 타입과 타입을 구현한 클래스 사이의 관계를 보니 아래 사실을 알 수 있다.
    - 여러 클래스가 동일 타입을 구현할 수 있다.
    - 하나의 클래스가 여러 타입을 구현할 수 있다.
- 객체지향의 중심은 클래스가 아닌 타입이다.
- 중요한 것은 객체가 외부에 제공하는 행동, 즉 타입을 중심으로 객체 간 계층을 설계하는 것이다.

## 추상 클래스를 이용한 타입 계층 구현

- 클래스 상속으로 구현을 공유하면서 결합도로 인한 부작용을 피하는 방법으로 추상 클래스가 있다.
- 구체 클래스로 상속 받는 것과 추상 클래스로 타입을 정의해 상속 받는 것엔 두 가지 차이점이 있다.
    - 의존 대상의 추상화 정도
    - 상속의 의도

### 추상 클래스 상속의 장점 1. 추상화 정도

- 추상 클래스를 상속하면 내부 구현이 아닌 추상 메서드 시그니처에만 의존한다.
    - 구체 클래스를 상속하면 부모 클래스에게 강하게 결합된다. (부모의 변경이 자식에게 전파)
    - 추상 클래스 상속을 통해 부모의 구현을 알 필요가 없게 된다.
- 자식 클래스가 부모 클래스의 추상 메서드에 의존하기에 추상화에 의존하는 의존성 역전 원칙을 따른다고 할 수 있다.
- 추상 메서드의 명세가 달라지지 않는 한 변경에 영향을 받지 않는다.

### 추상 클래스 상속의 장점 2. 상속의 의도

- 추상 클래스가 아닌 클래스는 상속을 염두해 두고 설계된 것이 아닐 가능성이 크다.
    - 이러한 구체 클래스 상속은 코드 재사용을 위한 트릭을 쓴 것에 가깝다.
- 반면 추상 클래스는 상속을 염두해 두고 설계되었다.
    - 추상 클래스로 인스턴스를 생성할 수도 없다.
- 추상 클래스는 추상 메서드를 제공함으로써 상속 계층을 쉽게 확장할 수 있는 안전망을 제공한다.

## 추상 클래스와 인터페이스 결합하기

- 인터페이스로 다중 상속을 할 수 있지만 구현 코드를 포함시킬 수 없기에 중복 코드를 제거하기 어렵다.
- 이를 해결하기 위해 골격 구현 추상 클래스를 사용할 수 있다.
    - skeletal implementation abstract class
    - 인터페이스로 타입을 정의하고 특정 상속 계층에 국한된 코드를 공유해야할 때 추상 클래스를 사용하는 방법
- 인터페이스와 추상 클래스를 함께 사용하는 방법의 장점
    - 다양한 구현 방법이 필요한 경우 새로운 추상 클래스를 추가해 해결할 수 있다.
    - 이미 부모 클래스가 존재하는 클래스라 하더라도 인터페이스를 추가해 새로운 타입으로 확장할 수 있다.
        - 추상 클래스가 부모라면 상속 계층을 재조정할 수밖에 없지만 말이다.
