## 07 객체 분해

- 사람의 기억은 단기 기억과 장기 기억으로 분류 가능
    - 장기 기억엔 직접 접근이 불가능하고 먼저 단기 영역으로 옮긴 후 처리해야 한다.
    - 단기 기억은 장기 기억에 비해 정보를 보관할 수 있는 속도와 공간 측면에서 모두 제약을 받는다.
- 사람은 문제를 해결할 때 단기 기억을 사용한다.
    - 문제 해결에 필요한 요수 수가 단기 기억 용량을 초과하면 인지 부조화가 일어나 문제 해결 능력이 떨어진다.
- 인지 부조화를 방지하는 방법은 단기 기억에 보관할 정보 양을 조절하는 것이다.
    - 문제 해결에 필요한 핵심만 남기는 ‘추상화’
    - 큰 문제를 해결 가능한 작은 문제로 나누는 ‘분해’

## 01 프로시저 추상화와 데이터 추상화

- 현대 프로그래밍 언어를 특징 짓는 중요한 추상화 메커니즘
    - 프로시저 추상화 - 소프트웨어가 무엇을 해야 하는지를 추상화
    - 데이터 추상화 - 소프트웨어가 무엇을 알아야 하는지 추상화
- 프로시저 중심으로 시스템을 분해하기로 결정했다면 기능 분해를 하는 것이다.
    - 알고리즘 분해라고 부르기도 한다.
- 데이터를 중심으로 시스템을 분해하기로 결정했다면 두 가지 중 하나를 선택해야 한다.
    - 추상 데이터 타입 - 타입을 추상화
    - 객체지향 - 프로시저를 추상화
- 프로그래밍 언어 관점에서 객체지향
    - 데이터를 중심으로 데이터 추상화와 프로시저 추상화를 통합한 객체를 이용해 시스템을 분해하는 방법
    - 이를 구현하기 위해 클래스라는 도구를 이용

## 02 프로시저 추상화와 기능 분해

### 메인 함수로서의 시스템

- 기능 분해 관점에서 추상화 단위는 프로시저이며 시스템은 프로시저를 단위로 분해된다.
- 기능 분해 관점에서 추강화 단위는 프로시저
    - 프로시저는 반복되거나 유사하게 실행되는 작업들을 한 장소에 모아놓음으로써 로직을 재사용하고 중복을 방지할 수 있는 추상화 방법
    - 프로시저만 알면 구현을 모르더라도 사용할 수 있기에 추상화라고 부른다. (정보은닉)
- 전통적 기능 분해 방법은 하향식 접근법을 따른다.
    - 시스템을 구성하는 최상위 기능을 정의하고, 이 기능을 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법
    - 분해는 세분화된 마지막 하위 기능이 프로그래밍 언어로 구현 가능한 수준이 될 때까지 계속된다.
    - 각 단계는 바로 위 단계보다 더 구체적이어야 한다.

### 급여 관리 시스템

- 급여 관리 시스템 요구 사항
    - 연초에 회사는 매달 지급해야하는 기본급을 직원과 협의하여 12개월 동안 동일하게 지급한다.
    - 급여 지급 시 소득세율에 따라 일정 금액의 세금을 공제한다.
        - `급여 = 기본급 - (기본급 * 소득세율)`
- 급여 관리 시스템 구현을 위해 기능 분해 방법을 이용하기 위해 최상위 문장을 기술한다.
    - `직원의 급여를 계산한다.`
    - 위 최상위 문장은 급여 관리 시스템을 시작하는 메인 프로시저로 구현될 것이다.
- 기능 분해 방법에 따라 이 프로시저를 더 세분화된 절차로 구체화해야 한다.

    ```
    직원의 급여를 계산한다.
        사용자로부터 소득세율을 입력받는다.
            "세율을 입력하세오: "라는 문장을 화면에 출력한다.
            키보드를 통해 세율을 입력받는다.
        직원의 급여를 계산한다.
            전역 변수에 저장된 직원의 기본급 정보를 얻는다.
            급여를 계산한다.
        양식에 맞게 결과를 출력한다.
            "이름: {직원명}, 급여: {계산된 금액}" 형식에 따라 출력 문자열을 생성한다.
    ```

    - 각 정제 단계는 이전 문장의 추상화 수준을 감소시켜야 한다.
    - 더 정제 가능한 문장이 존재하면 동일한 과정을 거쳐 구현 가능할 정도로 충분히 저수준 문장이 될 때까지 분해한다.
- 급여 관리 시스템을 입력을 받아 출력을 생성하는 하나의 메인 함수로 간주하고 기능 분해를 시작했다.
    - 입력 정보는 직원 정보와 소득세율이며 출력은 계산된 급여 정보
- 전통적 하향식 기능 분해 방식은 유지보수에서 다양한 문제를 야기한다.

### 급여 관리 시스템 구현

- 구현 예제는 루비를 사용한다.
- `직원의 급여를 계산한다.`라는 최상위 문장은 아래 함수 정의로 바꿀 수 있다.

    ```ruby
    def main(name)
    end
    ```

- 이제 첫 번째 하위 단계의 세분화 내용을 이용해 함수 내부를 채울 차례다.

    ```
    직원의 급여를 계산한다.
        사용자로부터 소득세율을 입력받는다.
    
        직원의 급여를 계산한다.
    
        양식에 맞게 결과를 출력한다.
    ```

    ```ruby
    def main(name)
      taxRate = getTaxRate()
      pay = calculatePayFor(name, taxRate)
      puts(describeResult(name, pay))
    end
    ```

- 그 다음 하위 단계 세분화 내용에 맞게 각 함수를 구현해 나가면서 기능을 구현할 수 있다.
- 하향식 분해 방식으로 설계한 시스템은 메인 함수를 루트로 하는 트리로 표현할 수 있다.

### 하향식 기능 분해의 문제점

- 시스템은 하나의 메인 함수로 구성돼 있지 않다.
    - 시스템은 시간이 지남에 따라 새로운 기능을 추가하게 된다.
    - 어느 시점에 이르면 유일 메인 함수라는 개념은 없어지고 여러 동등 수준의 함수 집합으로 성장하게 된다.
    - 하나의 알고리즘을 구현하거나 배치 처리 구현에는 적합하지만 현대적인 상호작용 시스템에는 적합하지 않다.
- 기능 추가나 요구사항 변경으로 인해 메인 함수를 빈번하게 수정해야 한다.
    - 시스템에 여러 정상이 존재하기에 새로운 기능을 추가할 때마다 매번 메인 함수를 수정해야 한다.
    - 새 함수의 적절 위치를 확보해야 하기 때문에 메인 함수 구조가 급격히 변경될 수밖에 없다.
    - 기존 코드의 빈번한 수정으로 버그 발생 확률이 높아진다.
- 비즈니스 로직이 사용자 인터페이스와 강하게 결합된다.
    - 로직 설계 초기 단계부터 입력 방법과 출력 양식을 함께 고민하도록 강요한다.
    - 문제는 비즈니스 로직과 사용자 인터페이스 변경 빈도가 다르다는 것
- 하향식 분해는 너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하된다.
    - 하향식 분해 과정은 설계 시작 시점부터 시스템이 무엇을 해야 하는지가 아니라 어떻게 동작해야 하는지에 집중하도록 만든다. (설계 처음부터 구현을 염두에 둠)
    - 함수들의 실행 순서를 미리 결정하지 않는 한 기능 분해를 진행할 수 없다.
    - 문제는 중요한 설계 걸정사항인 함수의 제어 구조가 빈번한 변경 대상이라는 점
    - 하향식 설계와 관련된 모든 문제 원인은 결합도이다.
- 데이터 형식이 변경될 경우 파급 효과를 예측할 수 없다.
    - 어떤 데이터를 어떤 함수가 사용하고 있는지를 추적하기 어렵다.
    - 즉 데이터 변경으로 인해 어떤 함수가 영향을 받을지 예상하기 어렵다.
