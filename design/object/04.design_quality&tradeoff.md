# 04 설계 품질과 트레이드 오프
- 객체지향 설계란 올바른 객체에게 올바른 책임을 할당하며 낮은 결합도와 높은 응집도를 가진 구조를 창조하는 활동
    - 핵심은 “책임”
    - 책임 할당이 응집도와 결합도 등의 설계 품질과 깊이 연관되어 있다.
- 객체의 상태가 아닌 행동에 집중함으로써 결합도와 응집도를 합리적인 수준으로 유지할 수 있다.
    - 상태에 집중하면 설계가 변경에 취약해진다.

## 01 데이터 중심의 영화 예매 시스템

- 데이터 중심 관점에서 객체는 자신이 포함하는 데이터를 조작하는 데 필요한 오퍼레이션을 정의한다.
- 객체 상태는 구현에 속하고 구현은 불안정하다.
    - 데이터 초점 설계는 변경에 취약

### 데이터를 준비하자

- 데이터 중심 설계에서는 객체가 포함하는 데이터에 집중한다.
- 데이터에 집중한 `Movie` 클래스가 책임에 집중한 클래스와 다른 점

    ```java
    @Getter
    @Setter
    public class Movie {
        private String title;
        private Duration runningTime;
        private Money fee;
        private List<DiscountCondition> descountConditions;
    
        private MovieType: movieType; //금액 할인 정책인지, 비율 할인 정책인지
        private Money discountAmount;
        private double discountPercent;
    }
    ```

    - `DiscountConditions`이 인스턴수 변수로 포함되어 있다.
    - `discountAmount`와 `discountPercent`가 인스턴스로 포함되어 있다.
    - `MovieType`에 따라 `discountAmount`와 `discountPercent` 중 하나만 사용될 것
    - 객체의 종류를 저장하는 변수와 종류에 따라 베타적으로 사용될 변수를 한 클래스에 포함시키는 방식은 데이터 중심 설계에서 흔하다.

### 영화를 예매하자

- 다른 클래스도 다 데이터 중심으로 설계했다고 가정하면 예매 절차는 다음과 같아진다.
- `ReservationAgency`는 영화 예매 절차를 구현하는 클래스다.

    ```java
    public class ReservationAgency {
        public Reservation reserve(Screening screening, Customer customer,
                                   int audienceCount) {
            Movie movie = screening.getMovie();
    
            boolean discountable = false;
            for(DiscountCondition condition : movie.getDiscountConditions()) { // 할인 적용 여부 판단
                if (condition.getType() == DiscountConditionType.PERIOD) {
                    discountable = screening.getWhenScreened().getDayOfWeek().equals(condition.getDayOfWeek()) &&
                            condition.getStartTime().compareTo(screening.getWhenScreened().toLocalTime()) <= 0 &&
                            condition.getEndTime().compareTo(screening.getWhenScreened().toLocalTime()) >= 0;
                } else {
                    discountable = condition.getSequence() == screening.getSequence();
                }
    
                if (discountable) {
                    break;
                }
            }
    
            Money fee;
            if (discountable) { // 할인 적용 대상이면 금액 계산
                Money discountAmount = Money.ZERO;
                switch(movie.getMovieType()) {
                    case AMOUNT_DISCOUNT:
                        discountAmount = movie.getDiscountAmount();
                        break;
                    case PERCENT_DISCOUNT:
                        discountAmount = movie.getFee().times(movie.getDiscountPercent());
                        break;
                    case NONE_DISCOUNT:
                        discountAmount = Money.ZERO;
                        break;
                }
    
                fee = movie.getFee().minus(discountAmount).times(audienceCount);
            } else {
                fee = movie.getFee().times(audienceCount);
            }
    
            return new Reservation(customer, screening, fee, audienceCount);
        }
    }
    ```


## 02 설계 트레이드 오프

### 캡슐화

- 구현 - 변경될 가능성이 높은 부분
- 인터페이스 - 상대적으로 안정적인 부분
- 설계가 필요한 이유는 요구사항이 변경되기 때문
    - 구현과 인터페이스를 분리하고 외부에서는 인터페이스에만 의존하도록 해야 한다.
- 즉 캡슐화란 변경 가능성이 높은 부분을 객체 내부로 숨기는 추상화 기법

### 응집도와 결합도

- 응집도
    - 모듈에 포함된 내부 요소들이 연관돼 있는 정도
    - 모듈 내 요소가 서로 다른 목적을 가진다면 응집도가 낮다.
    - 객체에 얼마나 관련 높은 책임들을 할당했는가
- 결합도
    - 다른 모듈에 얼마나 많은 지식을 갖고 있는지의 척도
    - 모듈이 다른 모듈에 꼭 필요한 지식만 알고 있다면 결합도가 낮다.
    - 객체가 협력에 필요한 적절한 수준의 관계만을 유지했는가
- 높은 응집도와 낮은 결합도를 추구하는 이유
    - 설계를 변경하기 쉽게 만들기 때문
- 응집도란 변경 발생 시 모듈 내부에서 발생하는 변경의 정도
    - 모듈 전체가 함께 변경된다면 높은 응집도, 모듈 일부만 변경된다면 낮은 응집도
    - 응집도가 낮다면 한 변경에 의해 여러 모듈을 동시에 수정해야 한다.
- 결합도는 한 모듈이 변경되기 위해 다른 모듈의 변경을 요구하는 정도
    - 결합도가 높다면 변경해야 하는 모듈 수가 많이 변경이 어렵다.
- 캡슐화를 지키면 응집도는 높아지고 결합도는 낮아진다.
