# Chapter2 아키텍처 개요

## 2.1 네 개의 영역

‘표현’, ‘응용’, ‘도메인’, ‘인프라스트럭처’는 아키텍처를 설계할 때 출현하는 전형적인 네 가지 영역이다.

### 표현 영역

- UI 영역이라고도 불린다.
- 표현 영역은 사용자 요청을 받아 응용 영역에 전달하고 결과를 받아 다시 사용자에게 보여주는 역할을 한다.
    - HTTP 요청을 응용 영역이 필요로 하는 형식으로 변환하고 응답을 다시 HTTP 응답으로 변환하여 전송한다.
- 스프링 MVC 프레임워크가 표현 영역을 위한 기술에 해당한다.
- 표현 영역의 사용자는 사람일 수도, REST API를 호출하는 외부 시스템일 수도 있다.

### 응용 영역

- 응용 영역은 시스템이 사용자에게 제공해야 할 기능을 구현한다.
    - ‘주문 등록’, ‘주문 최소’ 등
- 응용 영역은 기능 구현을 위해 도메인 영역의 도메인 모델을 사용한다.
    - 로직을 직접 수행하기보다 도메인 모델에 로직 수행을 위임

```java
public class OrderService {
	
	@Transactional
	public void cancelOrder(String orderId) {
		Order order = getOrderById(orderId);
		order.cancel();
	}

	// ...
}
```

### 도메인 영역

- 도메인 영역은 도메인 모델을 구현한다.
- 도메인 모델은 도메인의 핵심 로직을 구현한다.

### 인프라스트럭처 영역

- 인프라스트럭처 영역은 논리적 개념을 표현하기보다 실제 구현 기술에 대한 것을 다룬다.
    - RDBMS, 메시징 큐, 레디스 등
- 도메인 영역, 응용영역, 표현 영역은 구현 기술을 사용한 코드를 직접 만들지 않는다.

## 2.2 계층 구조 아키텍처

- 네 영역을 구성할 때 일반적으로 표현 영역과 응용 영역은 도메인 영역을 사용하고, 도메인 영역은 인프라스트럭처 영역을 사용한다.
    - 도메인 복잡도에 따라 응용과 도메인을 분리하기도 하고 합치기도 한다.
- 계층 구조를 엄격하게 하면 의존 방향이 상위 계층에서 하위 계층으로만 흐른다.
    - 표현 → 응용 → 도메인 → 인프라스트럭처

### 인프라스트럭처 계층에 종속되는 문제

- 구현의 편리함을 위해 응용 계층이 인프라스트럭처 계층에 의존하기도 한다.
- 이 때 발생하는 두 가지 문제점이 있다.
    - 응용 계층을 테스트하기 어렵다.
    - 구현 방식을 변경하기 어렵다.
- 아래 코드는 가격 할인을 담당하는 응용 계층이 인프라 계층인 `RuleEngine` 클래스를 의존하는 예시이다.

    ```java
    public class CalculateDiscountServie {
    
    	private final DroolsRuleEngine ruleEngine;
    
    	// ...
    
    	public Money calculateDiscount(OrderLine orderLines, String customerId) {
    		Customer customer = findCustomer(customerId);
    
    		MutableMoney money = new MutableMoney(0);
    		List<?> facts = Arrays.asList(customer, money);
    		facts.addAll(orderLines);
    		ruleEngine.evalute("discountCalculation", facts);
    		return money.toImmutableMoney();
    	}
    ```

    - `CalculateDiscountService`를 테스트하려면 `RuleEngine`이 완벽하게 동작해야 하기에 테스트가 번거롭다.
    - `caculateDiscount()` 메서드 안의 코드는 `RuleEngine` 클래스를 사용하기위해 필요한 코드들이기 때문에 다른 구현 기술을 사용하려면 이 코드들을 다 고쳐야 한다.

## 2.3 DIP

가격 할인 도메인 예제를 계속해서 살펴보자.

- `CalculateDiscountService`
  - **고수준 모듈**로 ‘가격 할인 계산’이라는 단일 기능을 구현
  - 하위 기능으로 ‘고객 정보 조회’와 ‘룰을 이용한 할인 적용’이 필요하다.
- 고수준 모듈이 제대로 동작하려면 저수준 모듈을 사용해야 한다.
  - 하지만 위에서 언급했던 두 가지 문제가 발생하게 된다.
  - ‘테스트하기 어려움’, ‘구현 방식 변경의 어려움’

### DIP 적용

```java
public interface RuldDiscounter {
	Money applyRules(Customer customer, List<OrderLine> orderLines);
}
```

```java
public class CalculateDiscountServie {

	private final RuleDiscounter ruleDiscounter;

	public CalculateDiscountService(RuleDiscounter ruleDiscounter) {
		this.ruleDiscounter = ruleDiscounter;
	}

	public Money calculateDiscount(OrderLine orderLines, String customerId) {
		Customer customer = findCustomer(customerId);
		return ruleDiscounter.applyRules(customer, orderLines);
	}
```

- `CaculateDiscountService`가 Drools이라는 구현을 알지 못하게 `RuleDiscounter`라는 인터페이스를 의존하도록 변경했다.
  - `RuleDiscounter`의 구현 객체는 생성자를 통해 외부에서 주입 받는다.
- 저수준 모듈이 고수준 모듈에 의존하는 이 원칙을 **의존성 역전 원칙**(DIP, Dependency Inversion Principle)이라고 한다.
- DIP를 이용하면 `RuleDiscounter`를 구현한 대역 객체를 사용해 고수준 모듈의 테스트를 쉽게 진행할 수 있다.
- DIP를 이용하면 의존성 주입을 통해 다른 구현체를 쉽게 설정할 수 있기에 구현 교체가 용이하다.
  - 고수준 모듈의 코드를 수정할 필요도 없다.

### 2.3.1 DIP 주의사항

- DIP는 단순히 인터페이스와 구현 클래스를 분리하는 정도로 받아들이면 안 된다.
- **인터페이스의 위치가 저수준 모듈이 아닌 고수준 모듈에 위치해야 한다.**
  - 저수준 모듈에 인터페이스가 위치하게 되면 여전히 고수준 모듈이 저수준 모듈을 의존하는 형태가 된다.
- 쉽게 얘기해서 Service 클래스와 Service 클래스가 의존하는 인터페이스는 고수준 모듈로서 한 패키지에 있어야 하고, 인터페이스의 구현체인 세부 사항은 저수준 모듈의 패키지에 위치해야 한다.

### 2.3.2 DIP와 아키텍처

- DIP를 적용하면 인프라스트럭처 영역이 응용 영역과 도메인 영역에 의존(상속)하는 구조가 된다.
  - 응용 계층이 인프라 계층을 의존하며 인프라 계층이 가장 하단에 위치하는 계층형 구조와는 달라진다.
- 도메인과 응용 영역에 대한 영향을 최소화하면서 인프라 계층의 구현 기술을 변경하는 것이 가능해진다.

> 무조건 DIP를 적용할 필요는 없다. 구현 기술에 따라 구현 기술에 의존적인 코드를 도메인 일부에 포함하는 게 효과적일 때도 있고, 추상화 대상이 잘 떠오르지 않을 때도 있다. 이런 경우 DIP의 이점을 얻는 수준에서 적용 범위를 검토해 보자.
>

## 2.4 도메인 영역의 주요 구성 요소

도메인 영역을 구성하는 요소는 다음과 같다.

| 요소 | 설멍 |
| --- | --- |
| 엔티티 | 고유의 식별자를 갖는 객체로 자신의 라이프 사이클을 갖고 도메인의 고유한 개념을 표현한다. 도메인 모델의 데이터를 포함하며 관련된 기능을 함께 제공한다. |
| 밸류 | 식별자를 갖지 않는 객체로 주로 개념적인 하나의 값을 표현할 때 사용된다. 엔티티의 속성 또는 다른 밸류 타입의 속성으로도 사용할 수 있다. |
| 애그리거트 | 연관된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것이다. |
| 리포지터리 | 도메인 모델의 영속성을 처리한다. |
| 도메인 서비스 | 특정 엔티티에 속하지 않은 도메인 로직을 제공한다. 도메인 로직이 여러 엔티티와 밸류를 필요로 하면 도메인 서비스에서 로직을 구현한다. |

### 2.4.1 엔티티와 밸류

- **DB 테이블의 엔티티와 도메인 모델의 엔티티는 같은 것이 아니다.**

    ```java
    public class Order {
    	private OrderNo number;
    	private Orderer orderer;
    	private ShippingInfo shippingInfo;
    
    	// ...
    
    	public void changeShippingInfo(ShippingInfo newInfo) {
    		// ...
    	}
    
    // ...
    }
    ```

  - 도메인 모델의 엔티티는 데이터와 함께 기능을 제공하는 객체이다.
  - 도메인 모델의 엔티티는 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용해서 표현할 수 있다.

### 2.4.2 애그리거트

- **애그리거트는 관련 있는 엔티티와 밸류 객체들을 하나로 묶은 군집이다.**
  - ‘주문’이라는 도메인 개념의 ‘주문’, ‘배송지 정보’, ‘주문자’, ‘주문 목록’, ‘총 결제 금액’ 등의 묶음
  - 애그리거트를 통해 객체를 군집 단위로 바라볼 수 있게 되어 큰 틀에서 도메인 모델을 관리할 수 있다.
- 애그리거트를 구성하지 않고 도메인 모델이 복잡해지면 큰 수준에서 모델을 이해하지 못해 큰 틀에서 모델을 관리할 수 없는 상황에 빠질 수 있다.
  - 지도를 볼 때도 상세하게 나온 대축척 지도로는 이해하기 어려워 큰 수준에서 보여주는 소축척 지도를 함께 봐야 이해하기 쉽다.
- 애그리거트는 군집을 관리하는 **루트 엔티티**를 갖는다.
  - 루트 엔티티는 엔티티와 밸류 객체를 이용해 애그리거트가 구현해야 할 기능을 제공한다.
  - 애그리거트를 사용하는 클라이언트는 루트 엔티티가 제공하는 기능을 실행하고, 루트를 통해 간접적으로 애그리거트 내 다른 엔티티나 밸류 객체에 접근한다.
  - 루트 엔티티를 통해 애그리거트 내부 구현을 숨겨 애그리거트 단위로 캡슐화하도록 할 수 있다.

### 2.4.3 리포지터리

- **리포지터리는 애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의한다.**
  - 엔티티나 밸류가 요구사항에서 도출되는 도메인 모델이라면 리포지터리는 구현을 위한 도메인 모델이다.
- 도메인 모델을 사용해야 하는 코드는 리포지터리를 통해 도메인 객체를 조회한 뒤 도메인 기능을 실행한다.
- 도메인 모델 관점에서 `XXXRepository`는 도메인 객체를 영속화하는 고수준 모듈이다.
  - 저수준 모듈에는 기반 기술을 이용하여 `XXXRepository`를 구현한 클래스를 둔다.
- 응용 서비스와 리포지터리는 밀접한 관련이 있다.
  - 응용 서비스는 필요한 도메인 객체에 리포지터리를 통해 접근한다.
  - 응용 서비스는 트랜잭션을 관리하는데, 트랜잭션 처리는 리포지터리 구현 기술에 영향을 받는다.

## 2.5 요청 처리 흐름

1. 사용자가 애플리케이션에 기능 실행 요청을 한다.
2. 표현 영역은 사용자가 전송한 데이터 형식이 올바른지 검사하고 응용 서비스에 기능 실행을 위임한다.
3. 응용 서비스는 도메인 객체를 리포지터리에서 가져와 실행하거나 신규 도메인 객체를 생성해 리포지터리에 저장한다.
4. 응용 서비스는 결과를 표현 계층에 리턴하고 표현 계층은 알맞은 형식으로 다시 사용자에게 리턴한다.

## 2.6 인프라스트럭처 개요

- 인프라스트럭처는 표현, 응용, 도메인 영역을 지원한다.
- DIP를 사용하면 인프라스트럭처 영역에 대한 의존을 없애고 시스템을 더 유연하고 테스트하기 쉽게 만들 수 있다.
- 하지만 무조건 인프라 계층에 대한 의존을 없앨 필요는 없다.
  - JPA를 사용할 경우 관련 애너테이션 들을 도메인 영역에 사용하는 것이 XML 매핑 설정보다 훨씬 편리하다.
  - 프레임워크 의존성을 없애려고 `@Transactional`을 사용하지 않는다면 복잡한 스프링 설정을 사용해야 한다.
  - **구현의 편리함은 DIP가 주는 장점만큼 중요하기에 둘 사이의 균형을 찾는 것이 중요하다.**

## 2.7 모듈 구성

- 아키텍처 각 영역은 별도 패키지에 위치한다.
  - ui
  - application
  - domain
  - infrastructure
- 도메인이 크다면 도메인마다 패키지를 구성한다.
  - catalog
    - ui
    - applciation
    - domain
    - infrastructure
  - order
    - ui
    - application
    - domain
    - infrastructure
  - etc…
- 도메인 모듈은 도메인에 속한 애그리거트를 기준으로 다시 패키지를 구성한다.
  - catalog
    - ui
    - application
    - domain
      - product
      - category
    - infrastructure
- 모듈 구조 세분화에 대한 정해진 규칙은 없다.
  - 한 패키지에 타입이 너무 많아 불편한 정도만 아니면 된다.
  - 한 패키지에 10~15개 미만으로 타입 개수를 유지해보자.
