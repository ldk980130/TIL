# Chapter1 도메인 모델 시작하기

## 1.1 도메인이란?

- 온라인 서점을 구현해야할 소프트웨어 대상으로 바라보면 다음의 기능을 제공해야 한다.
    - 상품 조회
    - 상품 구매
    - 상품 결제
    - 상품 배송 추적
    - etc…
- 온라인 서점은 소프트웨어로 해결하고자 하는 문제 영역, 즉 **도메인**(domain)에 해당한다.
- 한 도메인은 다시 하위 도메인으로 나눌 수 있다.
    - 한 하위 도메인은 다른 도메인과 연동하여 완전한 기능을 제공한다.
    - 하위 도메인을 어떻게 구성할지 여부는 상황에 따라 달라진다.
- 특정 도메인을 소프트웨어가 모두 제공하는 것은 아니다.
    - 배송 도메인의 경우 외부 배송 업체 시스템을 이용하는 경우가 많다.
    - 결제 시스템도 대행 업체를 이용하는 경우가 많다.

## 1.2 도메인 전문가와 개발자 간 지식 공유

- 코딩에 앞서 요구사항을 올바르게 이해하는 것이 중요하다.
- 개발자와 전문가가 직접 대화하면 요구사항을 비교적 올바르게 이해할 수 있다.
- 개발자도 어느정도 도메인 지식을 갖춰야 한다.
- 도메인 전문가, 관계자, 개발자가 같은 지식을 공유하고 직접 소통할수록 원하는 제품을 만들 가능성이 높아진다.

## 1.3 도메인 모델

- 다양한 의미가 있지만 기본적으로 도메인 모델은 특정 도메인을 개념적으로 표현한 것이다.
    - 객체를 이용해 모델링할 수도 있고 상태 다이어그램을 통해 모델링할 수도 있다.
    - 그래프를 이용할 수도 있고 계산 규칙이 중요하다면 수학 공식을 활용할 수도 있다.
- 도메인을 이해하는 데 도움이 된다면 표현 방식은 중요하지 않다.

> **하위 도메인과 모델**
> 
> 도메인은 다수의 하위 도메인으로 구성되고, **각 도메인이 다루는 영역은 서로 다르기에, 같은 용어라도 의미가 달라질 수 있다**. 카탈로그 도메인의 ‘상품’은 가격, 내용 등을 담지만 배송 도메인의 ‘상품’은 실제 배송되는 물리적인 상품을 의미한다. 모델의 각 요소는 특정 도메인으로 한정할 때 의미가 완전해지기 때문에 **각 하위 도메인마다 별도로 모델을 만들어야 한다.**
>

## 1.4 도메인 모델 패턴

일반적인 애플리케이션 아키텍처는 다음과 같이 네 개의 영역으로 구성된다.

| 영역 | 설멍 |
| --- | --- |
| 사용자 인터페이스 또는 표현(Presentation) | 사용자의 요청을 처리하고 사용자에게 정보를 보여준다. 사용자는 사람 뿐 아니라 외부 시스템일 수도 있다. |
| 응용(Application) | 사용자가 요청한 기능을 실행한다. 업무 로직을 직접 구현하지 않으며 도메인 계층을 조합해서 기능을 실행한다. |
| 도메인 | 시스템이 제공할 도메인 규칙을 구현 |
| 인프라스트럭처(infrastrcture) | 데이터베이스나 메시징 시스템 같은 외부 시스템과의 연동을 처리한다. |

### 도메인 계층

- 도메인 계층은 도메인의 핵심 규칙을 구현한다.
- 업무 규칙을 도메인 모델에 위치시켜야 규칙을 바꾸거나 확장할 때 다른 코드에 영향을 덜 주고 모델에 반영할 수 있게 된다.

> **도메인 모델**이란 용어는 도메인 자체를 표현하는 개념적인 모델을 의미하지만, 도메인 계층을 구현할 때 사용하는 객체 모델에도 **도메인 모델**이란 용어를 사용한다.
>

> **개념 모델과 구현 모델**
> 
> **개념 모델**은 순수하게 문제를 분석한 결과물로 DB, 성능, 기술을 고려하지 않는다. 그래서 개념 모델을 구현 가능한 모델로 전환하는 과정을 거치게 된다. **처음부터 완벽한 개념 모델을 만드는 것은 거의 불가능**하다. 이는 프로젝트를 진행하면서 해당 도메인을 더 잘 이해하게 되고 다른 의미로 해석하는 경우도 발생하기 때문이다. 그래서 전반적인 개요를 알 수 있는 수준으로 개념 모델을 작성해야 한다. 구현하는 과정에서 개념 모델을 구현 모델로 점진적으로 발전시켜 나가야 한다.
>

## 1.6 엔티티와 밸류

도메인 모델은 크게 **엔티티**와 **밸류**로 구분할 수 있다.

### 1.6.1 엔티티

- 엔티티의 가장 큰 특징은 **식별자**를 가진다는 것이다.
  - 식별자는 객체마다 고유한 값
  - 식별자는 엔티티를 생성하고 변경하고 삭제할 때까지 유지된다.
  - 식별자가 같으면 두 엔티티는 같다고 판단할 수 있다.

### 1.6.2 엔티티의 식별자 생성

- 식별자 생성 시점은 도메인 특징과 사용 기술에 따라 달라진다.
  - 특정 규칙에 따라 생성
  - UUID나 Nano ID 같은 고유 식별자 생성기 사용
  - 값을 직접 입력
  - 일련번호 사용(시퀀스나 DB의 자동 증가 칼럼)

### 1.6.3 밸류 타입

- 밸류 타입은 개념적으로 완전한 하나를 표현할 때 사용한다.
- 아래 예는 ‘돈’이라는 개념을 표현한 `Money` 밸류 타입이다.

    ```java
    public class Money {
    	private int value;
    
    	// ...
    
    	public Money add(Money money) {
    		return new Money(this.value + money.value);
    	}
    
    	public int getValue() {
    		return this.value;
    	}
    }
    
    public class OrderLine {
    	private Money price;
    	// ...
    }
    ```

- 밸류 타입을 사용함으로써 ‘돈’이라는 개념을 명확하게 표현하여 코드에 대한 이해를 높이고 있다.
- 밸류 타입을 위한 기능을 추가할 수도 있다. (`Money.add()`)
- 밸류 객체는 **불변 객체**로 구현해서 사용하기를 선호한다.
  - 밸류 객체 데이터를 변경할 때 기존 데이터를 변경하기 보다 새로운 객체를 생성하도록 한다.
  - 불변 객체는 참조 투명성과 스레드에 안전하다는 특징이 있다.
- 밸류 타입을 비교할 땐 `equals()`와 `hashCode()`를 재정의해서 내부 값이 같다면 `true`를 반환하도록 구현해야 한다.

### 1.6.4 엔티티 식별자와 밸류 타입

- 엔티티 식별자에 `String`이나 `Integer` 같은 타입이 아닌 밸류 타입을 사용해서 의미가 잘 드러나도록 할 수도 있다.

```java
public Order {
	private OrderNo id;
}
```

### 1.6.5 도메인 모델에 set 메서드 넣지 않기

- `setter`는 도메인의 핵심 개념이나 의도를 코드에서 사라지게 한다.
  - 주문 도메인에서 `completePayment()` 메서드로 여러 제약 사항을 구현해서 처리하는 것과 단순히 `setOrderState()`로 상태 값만 변경하는 것만 비교해도 의미 차이는 명확하다.
  - 필드값만 변경하고 끝나기 때문에 상태 변경과 관련된 도메인 지식이 코드에서 사라지게 된다.
- `setter`가 있으면 도메인 객체를 생성할 때 온전하지 않은 상태가 될 수도 있다.
  - 이를 막으려면 생성 시점에 생성자를 통해 필요한 것을 전달해 적절한 검증을 거치게 해야 한다.

## 1.7 도메인 용어와 유비쿼터스 언어

- 코드를 작성할 때 도메인에서 사용하는 용어는 매우 중요하다.
- 아래는 `OrderState` enum을 도메인 용어로 작성한 예이다.

    ```java
    public enum OrderState {
    	PAYMENT_WAITING, PREPARING, SHIPPED, DELIVERING, DELIVERY_COMPLETED
    }
    ```

- 도메인 용어를 코드에 담으면 다음과 같은 장점이 있다.
  - 코드를 해석하는 과정이 줄어든다.
  - 코드의 가독성을 높여 코드 분석, 이해하는 시간을 줄인다.
  - 최대한 도메인 용어를 사용해 도메인 규칙을 작성하게 되므로 버그도 줄어든다.

### 유비쿼터스 언어

- **유비쿼터스 언어**는 도메인 주도 설계에서 에릭 에반스가 강조한 용어이다.
- 전문가, 관계자, 개발자가 도메인과 관련된 공통의 언어를 만들고 이를 대화, 문서, 도메인 모델, 코드, 테스트 등 모든 곳에서 같은 용어를 사용하게 한다.
- 이렇게 하면 소통 과정에서 용어의 모호함을 줄일 수 있고 개발자는 도메인과 코드 사이에서 불필요한 해석을 줄일 수 있다.
- 적절한 용어를 영단어로 치환해 코드로 표현하는 것은 어렵지만 시간을 들여 찾는 노력을 해야 한다.
  - 도메인과 어울리지 않은 단어를 사용하면 코드는 도메인과 점점 멀어지게 된다.
