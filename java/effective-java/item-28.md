# 아이템 28. 배열보다는 리스트를 사용하라

## 배열과 제네릭 타입의 차이

### 배열은 공변(covariant)이다

- 공변, 즉 함께 변한다는 듯이다.
- 만약 `Sub`가 `Super`의 하위 타입이라면 배열 `Sub[]`는 `Super[]`의 하위타입이 된다.
- 반면 제네릭은 불공변이기에 `List<Super>`는 `List<Sub>`의 상위 타입도, 하위 타입도 아니다.
- 이런 이유 때문에 배열에선 타입이 안맞으면 런타임에 예외를 던지지만 제네릭을 사용하는 리스트에선 컴파일조차 되지 않는다.

    ```java
    // 런타임에 실패하는 코드
    Object[] objects = new Long[1];
    objects[0] = "타입이 달라 넣을 수 없다."; // ArrayStoreException 발생
    
    // 컴파일조차 되지 않는 코드
    List<Object> ol = new ArrayList<Long>(); // 호환되지 않는 타입, 컴파일 에러!
    ```

- 예외는 컴파일 시점에 잡는게 더 좋다.

### 배열은 실체화된다.

- 배열은 런타임에도 자신이 담기로 한 원소 타입을 인지하고 확인한다.
    - 런타임에 넣을 수 없는 타입이면 예외가 발생
- 반면 제네릭은 타입 정보가 런타임에는 소거된다.
    - 원소 타입을 컴파일 타임에만 검사
    - 제네릭 지원 전 레거시 코드와 제네릭 타입을 함께 사용할 수 있게 해주는 메커니즘

## 배열과 제네릭은 함께 쓰지 못한다.

- 위와 같은 차이 때문에 배열과 제네릭은 잘 어우러지지 못한다.
    - 배열은 제네릭 타입, 매개변수화 타입, 타입 매개변수로 사용할 수 없다.
    - `new List<E>[]`, `new List<String>[]`, `new E[]`는 컴파일 오류
- 제네릭 배열을 만들지 못하게 하는 이유
    - 타입 안전하지 않다.
    - 이를 허용하면 런타임에 `ClassCastException`이 발생할 수 있다.
    - 런타임에 타입 예외가 발생하지 않게 하겠다는 제네릭 타입 시스템 취지에 어긋난다.
- `E`, `List<E>,` `List<String>` 같은 타입을 실체화 불가 타입이라 한다.
    - 런타임에 컴파일타임보다 타입 정보를 적게 가지는 타입
    - `List<?>`와 `Map<?, ?>`와 같은 비한정적 와일드카드 타입은 실체화될 수 있다.
    - 배열을 비 한정적 와일드카드 타입으로 만들 수는 있지만 유용하게 쓰일 일은 거의 없다.

## 제네릭 배열보단 컬렉션을 사용하자

- 제네릭 배열을 사용해야할 때가 있다.
- 제네릭 배열 생성 오류나 비검사 형변환 경고가 뜨는 경우 대부분 `List<E>`를 사용하면 해결된다.
- 코드가 좀 복잡해지고 성능이 살짝 나빠질 수도 있지만 타입 안정성과 상호 운용성은 좋아진다.
