# 아이템 42. 익명 클래스보다는 람다를 사용하라

## 람다의 등장

- 자바 8 이전에는 함수 객체를 만드는 주요 수단은 **익명 클래스**였다.
    - ex) 문자열을 길이순으로 정렬하기 위한 익명 클래스 사용

    ```java
    Collections.sort(words, new Comparator<String>() {
    	public int compare(String s1, String s2) {
    		return Integer.compare(s1.length(), s2.length());
    	}
    });
    ```

- 자바 8 이후 **함수형 인터페이스**라는 개념이 등장하고 이를 이용해 **람다식**을 사용할 수 있게 되었다.

    ```java
    Collections.sort(words, 
    		(s1, s2) -> Integer.compare(s1.length(), s2.length()));
    ```

    - **타입을 명시해야 코드가 더 명확할 때 이외에는 람다의 모든 매개변수, 반환값 타입은 생략하면 된다.**
        - 컴파일러가 문맥에 따라 타입을 추론해준다.
        - 컴파일러가 결정하지 못할 때만 직접 명시하면 된다.
    - 코드가 훨씬 간결해지고 어떤 동작을 하는지가 명확하게 드러난다.

## 열거 타입에서 람다 활용

람다를 이용하면 열거 타입에서 상수별로 다르게 동작하는 코드를 쉽게 구현할 수 있다.

### ex) 계산식 열거 타입

```java
public enum Operation {
	PLUS("+", (x, y) -> x + y),
	MINUS("-", (x, y) -> x - y),
	TIMES("*", (x, y) -> x * y).
	DIVDE("/", (x, y) -> x / y);

	private final String symbol;
	private final DoubleBinaryOperator op;

	//...
}
```

## 람다와 익명 클래스

그렇다고 모든 곳에 람다를 사용하면 되는 것은 또 아니다.

### 람다 제약 사항

- **람다는 이름이 없고 문서화도 못한다.**
    - 코드 자체로 동작이 명확하지 않거나 코드 줄 수가 많아지면 람다가 더 이해하기 어려워진다.
- **열거 타입 생성자 안의 람다는 열거 타입의 인스턴스 멤버에 접근할 수 없다.**
    - 열거 타입 생성자 안 람다는 컴파일 타임에 추론되지만 인스턴스 멤버는 런타임에 만들어지기 때문이다.
- **추상 메서드가 2개 이상인 (함수형 인터페이스가 아닌) 인터페이스에는 익명 클래스를 쓸 수밖에 없다.**
- **람다는 자기 자신을 참조할 수 없다.**
    - 익명 클래스에서 `this` 키워드는 익명 클래스 자신을 가리키지만 람다에서의 `this`는 바깥 인스턴스를 가리킨다.
- **람다를 직렬화하는 일은 극히 삼가야 한다.**
    - 가상 머신별로 직렬화 형태가 다를 수 있다.
    - 익명 클래스도 마찬가지
    - 직렬화해야하는 함수 객체가 있다면 private 정적 중첩 클래스 인스턴스를 사용하자.
