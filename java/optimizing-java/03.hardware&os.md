# Chapter 3. 하드에어와 운영체제

> 무어의 법칙 - 대량 생산한 칩상의 트랜지스터의 수는 약 18개월마다 2배씩 증가한다. 즉 시간이 흐르면서 컴퓨터 파워가 기하급수적으로 증가하는 현상을 나타낸 말
>

## 3.1 최신 하드웨어 소개

- 1990년대 이후 애플리케이션 개발자 세상은 대부분 인텔 x86/x64 아키텍처 위주로 돌아갔다.
- 프로세서 작동 원리를 단순화한 멘탈 모델은 전혀 맞지 않게 되었다.

## 3.2 메모리

- 급증한 트랜지스터는 처음에 CPU 클록 속도를 높이는 데 쓰였다.
    - Clock Speed: 컴퓨터 프로세서의 동작 속도. "초당 주기"로 측정하며 헤르츠(Hz) 단위를 사용
    - 클록 속도가 증가하면 초당 많은 명령어를 처리 가능
- 하지만 메인 메모리가 프로세서 코어의 데이터 수요를 따라가기 버거워졌다.
    - 프로세서/메모리 간 성능 차이가 커짐
    - 결국 데이터가 도착할 때까지 기다려야 하기에 CPU 사용률이 낮아진다.

### 3.2.1 메모리 캐시

- CPU 캐시
    - CPU/메모리 성능 차를 개선하기 위해 고안되었다.
    - 레지스터보다는 느리지만 메인 메모리보다 훨씬 빠르다.
- CPU 캐시는 엑세스 빈도에 따라 프로세서 코어와 가까이 위치하면서 여러 계층이 존재한다.

  ![image](https://github.com/ldk980130/TIL/assets/78652144/b87bd3f0-4adb-4b29-92a0-06ccace190d5)

    - CPU 코어마다 전용 L1, L2 캐시가 있고 모든 코어가 공유하는 L3 코어가 존재
    - 메인 메모리는 노스브리지 컴포넌트를 거쳐 엑세스 가능
    - 이 버스를 관통함으로 메인 메모리 엑세스 시간이 확 줄어듦

### 캐시 일관성 프로토콜 (cache consistency protocol

- MESI 프로토콜: 메모리의 데이터와 캐시 데이터의 일관성을 해결하기 위한 프로토콜
- MESI 프로토콜은 캐시 라인 상태를 다음 네 가지로 정의한다.
    - Modified (수정): 데이터가 수정된 상태
    - Exclusive (베타): 이 캐시에만 존재하고 메인 메모리 내용과 동일한 상태
    - Shared (공유): 둘 이상의 캐시에 존재하고 메모리 내용과 동일한 상태
    - Invalid (무효): 다른 프로세스가 데이터를 수정하여 무효한 상태
- 멀티 프로세서가 동시에 공유 상태에 있을 수 있지만 한 프로세서가 베타나 수정 상태로 바뀌면 다른 모든 프로세서는 강제로 무효 상태가 된다.
- MESI 프로토콜에서 프로세서가 상태를 바꾸겠다는 의사를 브로드캐스팅 한다. (공유 메모리 버스를 통해)
- 캐시, 메모리 기록 방법
    - write-through: 매번 캐시 연산 결과를 바로 메모리에 기록, 효율이 낮아 요즘 거의 안 씀
    - write-back: 캐시 블록을 교체해도 프로세서가 변경된 캐시 블록만 메모리에 기록

## 3.3 최신 프로세서의 특징

메모리 캐시 말고도 최신 프로세서에 다양한 기술이 등장했다.

### 3.3.1 변환 색인 버퍼 (TLB)

- TLB(Translation Lookaside Buffer)는 가상 메모리 주소를 물리 메모리 주소로 매핑하는 페이지 테이블 캐시 역할을 수행
    - 가상 주소를 참조해 물리 주소에 엑세스하는 작업 속도 향상
- TLB가 없다면 L1 캐시에 데이터가 있어도 가상 주소 룩업에 16 사이클이나 걸려 성능이 나오지 않는다.

### 3.3.2 분기 에측과 추측 실행

- 프로세서는 다단계 명령 파이프라인을 이용해 CPU 1사이클로 여러 단계로 나누어 실행
    - 이 모델에서 조건문을 다 평가하기 전까지 분기 이후 다음 명령을 알 수 없는 문제가 있음
    - 분기문 뒤의 다단계 파이프라인을 비우는 동안 프로세서는 멎게 된다.
- 분기 예측을 통해 프로세서가 조건 분기 하는 기준값을 평가하느라 대기하는 현상을 방지
- 프로세서는 발생 가능성이 가장 큰 브랜치를 미리 결정하는 휴리스틱을 형성
    - 예측이 맞다면 CPU는 다음 작업을 진행
    - 예측이 틀리면 실행한 명령을 모두 폐기하고 파이프라인을 비우는 대가를 치른다.

### 3.3.3 하드웨어 메모리 모델

- JIT 컴파일러인 javac와 CPU는 일반적으로 코드 실행 순서를 바꿀 수 있다.
    - 순서를 바꿔도 결과에 영향이 없다는 전제가 필요
- 코드 실행 순서 변경에 의해 다른 스레드 입장에서 부정확한 값을 읽을 수도 있다.
- JMM은 명시적으로 약한 메모리 모델로 설계되었다.
    - 프로세서 타입별 상이한 메모리 엑세스 일관성을 고려
    - 멀티스레드 코드가 제대로 작동하려면 락과 `volatile`을 정확히 알고 사용해야 한다.

## 3.4 운영체제

- OS의 주 임무는 프로세스가 공유하는 리소스 엑세스를 관장하는 일
- 메모리 관리 유닛(Memory Management Unit, MMU)을 통한 가상 주소 방식과 페이지 테이블은 메모리 엑세스 제어의 핵심
- TLB는 물리 메모리 주소 룩업 시간을 줄이는 하드웨어 기능

### 3.4.1 스케줄러

- 최신 시스템은 항상 가능한 수준보다 더 많은 스레드/프로세스로 가득하기에 CPU 경합을 해소해야만 한다.
- 프로세스 스케줄러는 CPU 엑세스를 통제
    - 스케줄러는 인터럽트에 응답하고 CPU 코어 엑세스를 관리
    - 실행 큐(run queue): CPU 차례를 기다리는 스레드 혹은 프로세스 대기 큐
- OS는 특성상 CPU에서 코드가 실행되지 않는 시간을 유발한다.
    - I/O 또는 소프트웨어 락에 걸려 블로킹되는 경우
- 스케줄러 움직임을 확인하는 가장 쉬운 방법은 오버헤드를 관측하는 것이다.
    - OS마다 오버헤드는 천차만별
    - 1밀리초씩 총 1000회 스레드를 재우는 아래 코드에서 총 실행 시간을 보면 오버헤드를 짐잘할 수 있다.
    - 스레드를 재우면 실행 큐 맨 뒤로 가고 새로 시간을 할당받을 때까지 기다린다.

    ```java
    long start = System.currentTimeMills();
    for (int i = 0; i < 1000; i++) {
    	Thread.sleep(1);
    }
    long end = System.currentTimeMills();
    System.out.println(end - start)
    
    // 만약 위 코드 실행 시간이 2.8초라면 오버헤드는 180%
    // 순수 코드 실행 시간은 1000밀리초, 즉 1초지만 1.8초에 오버헤드가 발생
    ```


### 3.4.2 시간 문제

- POSIX(portable operating system interface, 이식 가능 운영체제 인터페이스) 같은 업계 표준이 있어도 OS 동작 방식은 상이
    - `os::javaTimeMills()`의 경우 OS가 제공하는 기능이기에 네이티브 메서드로 구현하는데 OS마다 다르게 구현된다.

### 3.4.3 컨텍스트 교환

- Context Switch: OS 스케줄러가 현재 실행 중인 스레드/태스크를 없애고 대기 중인 다른 스레도/태스크로 전환하는 프로세스
    - 스레드 실행 명령과 스택 상태를 교체하는 모든 일에 연관
- 컨텍스트 교환은 비싼 작업
    - 유저 스레드 사이에서의 교환보다 유저 모드에서 커널 모드로 바뀌면서 일어나는 교환이 더 비싸다
    - 유저 공간에 있는 코드가 접근하는 메모리 영역은 커널 코드와 공유할 부분이 없기에 캐시를 강제로 비워야 하기 때문
    - 커널 모드 컨텍스트 교환이 일어나면 TLB를 비롯한 다른 캐시까지 무효화된다.
    - 커널 코드 교환 여파는 후에 유저 모드로 제어권이 넘어가도 당분간 이어진다.
- 가상 동적 공유 객체(virtual Dynamically Sahred Object)
    - 리눅스가 커널 코드 컨텍스트 교환의 오버헤드를 만회하기 위해 제공
    - 커널 프리빌리지(특권)이 필요 없는 시스템 콜 속도를 높이려고 사용하는 유저 공간의 메모리 영역
    - ex) 부수 효과를 일으키지 않는 클록 시간을 얻는 시스템 콜의 경우 프리빌리지드 엑세스가 필요 없으므로 이 때 사용하는 자료 구조를 vDSO로 매핑한다면 커널 모드로 변경할 이유가 없다. (`gettimeofday(`)
    - 타이밍 자료를 빈번히 반환하는 자바에선 이런 식으로 성능을 올릴 수 있다.
