# Chapter 9. JVM의 코드 실행

- JVM이 제공하는 중요한 서비스
    - 메모리 관리
    - 사용하기 쉬운 애플리케이션 코드 실행 컨테이너

> VMSpec - 표준 자바 구현체가 코드를 실행하는 방법을 기술한 자바 가상 머신 명세
>
- VMSpec을 보면 인터프리터로 자바 바이트 코드를 실행하는 사양이 나온다.
    - 그러나 인터프리터로 해석하여 구동하는 환경은 기계어를 직접 실행하는 것보다 성능이 떨어진다.
    - 대부분 최신 자바 환경은 동적 컴파일 기능을 통해 이 문제를 해결 (JIT 컴파일)

## 9.1 바이트코드 해석

- JVM 인터프리터는 일종의 스택 머신처럼 작동
    - 물리적 CPU와 달리 계산 결과를 보관하는 레지스터는 없다.
    - 작업할 값을 모두 평가 스택에 놓고 스택 머신 명령어로 스택 최상단의 값을 변환하는 식으로 작동
- JVM은 다음 세 공간에 주로 데이터를 담는다.
    - 평가 스택: 메서드별로 하나씩 생성
    - 로컬 변수: 결과를 임시 저장(특정 메서드별로 존재)
    - 객체 힙: 메서드끼리, 스레드끼리 공유된다.

### 9.1.1 JVM 바이트코드 개요

- JVM에서 각 스택 머신 작업 코드(옵코드)는 1바이트이다.
    - 옵코드는 0 ~ 255까지 지정 가능하며 약 200개를 사용하고 있다. (자바 10 기준)
- 바이트코드 명령어는 스택 상단의 두 값의 기본형을 구분할 수 있게 표기한다.
    - ex) `iadd`(int 값 덧셈), `dadd`(double 값 덧셈)

> 바이트코드 명령어는 대부분 한쪽은 각 기본형, 다른 한 쪽은 참조형으로 쓸 수 있게 ‘패밀리’ 단위로 구성
>
- JVM은 빅 엔디언, 리틀 엔디언 모두에서 바이트코드 변경 없이 실행 가능하도록 명세에 지정되어 있다.
    - 자바는 이식성을 염두하고 설계되었기 때문
    - [빅 엔디언과 리틀 엔디언이란](http://www.tcpschool.com/c/c_refer_endian)
    - 바이트코드는 빅 엔디언
- `load` 같은 옵코드 군엔 단축형이 존재해 인수를 생략할 수 있다.
    - 그만큼 클래스 파일 인수 바이트 공간을 절약
    - `aload_0`: 현재 객체(`this`)를 스택 상단에 넣는 명령어. 자주 쓰이기에 클래스 파일 크기가 상당이 준다.
- 바이트코드는 개념적으론 단순하지만 기본 작업보다 훨씬 많은 옵코드가 할당되어 있다.
    - 여러 옵코드가 개념상 동일한 작업을 나타내는 경우도 있기 때문

### 주요 바이트코드 명령어

- 앞으로 표시하는 테이블에서 사용할 기호
    - `c1` - 2바이트짜리 상수 풀 인덱스
    - `i1` - 현재 메서드의 지역 변수
    - `()` - 해당 옵코드 패밀리 중 단축형을 지닌 옵코드가 있음
- 스택에 데이터를 넣고 빼는 로드/스토어 카테고리 옵코드

    | 패밀리 명 | 인수 | 설명 |
    | --- | --- | --- |
    | load | (i1) | 지역 변수 i1 값을 스택에 로드 |
    | store | (i1) | 스택 상단을 지역 변수 i1에 저장 |
    | ldc | c1 | CP#c1이 가리키는 값을 스택에 로드 |
    | const |  | 단순 상숫값을 스택에 로드 |
    | pop |  | 스택 상단에서 값을 제거 |
    | dup |  | 스택 상단에 있는 값을 복제 |
    | getField | c1 | 스택 상단에 위치한 객체에서 CP#c1이 가리키는 필드명을 찾아 스택에 로드 |
    | putField | c1 | 스택 상단 값을 CP#c1이 가리키는 필드에 저장 |
    | getstatic | c1 | CP#c1이 가리키는 정적 필드값을 스택에 로드 |
    | putstatic | c1 | 스택 상단 값을 CP#c1이 가리키는 정적 필드에 저장 |
- 산술 바이트코드
    - 기본형에만 적용
    - 순수 스택 기반 연산을 수행하므로 인수는 없다.

  | 페밀리 명 | 설명 |
      | --- | --- |
  | add | 스택 상단의 두 값을 더한다 |
  | sub | 스택 상단의 두 값을 뺀다 |
  | div | 스택 상단 두 값을 나눈다 |
  | mul | 스택 상단 두 값을 곱한다 |
  | (cast) | 스택 상단 값을 다른 기본형으로 캐스팅 |
  | neg | 스택 상단 값을 부정 |
  | rem | 스택 상단 두 값을 나눈 나머지를 구한다 |
- 흐름을 제어하는 바이트코드 (for, if, while, switch 등)

    | 페밀리 명 | 인수 | 설명 |
    | --- | --- | --- |
    | if | (i1) | 조건이 참일 경우 인수가 가리키는 위치로 분기 |
    | goto | i1 | 주어진 오프셋으로 무조건 분기 |
    - 몇 개 없어 보이지만 `if` 옵코드 페밀리에 속한 옵코드가 상당이 많다.

- 메서드 호출 바이트코드

    | 옵코드 명 | 인수 | 설명 |
    | --- | --- | --- |
    | invokevirtual | c1 | CP#c1이 가리키는 메서드를 가상 디스패치로 호출 |
    | invokespecial | c1 | CP#c1이 가리키는 메서드를 특별한 디스패치로 호출 |
    | invokeinterface | c1, count, 0 | CP#c1이 가리키는 인터페이스 메서드를 인터페이스 오프셋 룩업으로 호출 |
    | invokestatic | c1 | CP#c1이 가리키는 정적 메서드 호출 |
    | invokedynamic | c1, 0, 0 | 호출해서 실행할 메서드를 동적으로 찾는다 |
    - JVM 설계 구조상 메서드 호출 옵코드를 명시적으로 사용해야 하고 기계어에는 이와 동일한 호출 작업이 없다.
    - 대신 JVM 바이트코드엔 몇 전문 용어를 사용
        - 호출부 - 메서드(호출자) 내부에서 다른 메서드(피호출자)를 호출한 지점
        - 수신자 객체 - 호출되는 비정적 메서드를 가지고 있는 객체
        - 수신자 타입 - 수신자 객체의 런타임 타입
    - 자바 객체가 메서드를 호출할 때 실제 호출 컨텍스트에 따라 세 바이트코드 중 하나로 변환된다.
        - `invokevirtual` - 인스턴스 메서드 호출
        - `invokespecial` - 프라이빗 메서드나 슈퍼 클래스를 호출하는 경우. 컴파일 타임에 디스패치할 메서드를 특정할 수 있는 경우
        - `invokeinterface` - 인터페이스 메서드 호출
    - 정적 메서드 호출은 항상 `invokestatic`으로 컴파일되며 수신자 객체는 없다.
    - `invokedynamic`은 자바 8 이후 자바 언어 핵심으로 급부상하여 고급 기능을 지원하는 데 활용된다.
        - ex) 람다 표현식
- 플랫폼 옵코드
    - 객체별로 힙 저장 공간을 새로 할당
    - 고유 락(모니터 락)을 다루는 명령어

  | 옵코드 명 | 인수 | 설명 |
      | --- | --- | --- |
  | new | c1 | CP#c1이 가리키는 타입의 객체에 공간을 할당 |
  | newarray | prim | 기본형 배열에 공간 할당 |
  | anewarray | c1 | CP#c1이 가리키는 타입 객체 배열에 공간을 할당 |
  | arraylength |  | 스택 상단 객체를 그 길이로 치환 |
  | monitorenter |  | 스택 상단 객체 모니터를 잠금 |
  | monitorexit |  | 스택 상단 객체 모니터를 잠금 해제 |
    - `newarray`, `anewarray` 실행 시 할당할 배열 길이가 스택 상단에 있어야 한다.
- 바이트코드는 구현 복잡도에 따라 대단위, 소단위 바이트코드로 구분된다.
    - 산술 연산은 매우 소단위 작업이라 핫스팟에서 순수 어셈블리어로 구현된다.
    - 대단위 연산(상수 풀 룩업, 메서드 디스패치)은 핫스팟 VM을 다시 호출할 수밖에 없다.

### 바이트코드 개별 의미와 세이프포인트

- 세이프포인트 - JVM이 어떤 관리 작업을 수행하고 내부 상태를 일관되게 유지하는 데 필요한 지점
    - 객체 그래프가 들어있다.
    - 일관된 상태를 유지하려면 JVM이 관리 작업 수행 도중 공유 힙이 변경되지 않도록 STW가 필요하다.
- JVM 애플리케이션 스레드 하나하나는 진짜 OS 스레드
- 스레드에 대해 옵코드가 디스패치되는 시점에 스레드는 유저 코드가 아닌 JVM 인터프리터 코드를 실행한다.
    - 따라서 힙 상태 일관성이 보장되며 애플리케이션 스레드를 멈출 수 있다.
    - ‘바이트코드 사이사이’가 애플리케이션 스레드를 멈추기에 이상적인 시점
- JIT 컴파일드 메서드는 해결 방법이 더 복잡하지만 기본적으로 기계어에도 동일한 배리어를 끼워넣는다.

### 9.1.2 단순 인터프리터

- 가장 단순한 인터프리터는 `switch` 문이 포함된 `while` 루프 형태
- 이 인터프리터의 `execMethod()` 메서드는 단일 메서드 바이트코드를 해석한다.
    - 정수 계산, “Hello World” 출력 정도를 할 수 있는 옵코드가 구현되어 있음

### 9.1.3 핫스팟에 특정한 내용

- 핫스팟은 상용 제품급 JVM이자 완전한 구현체
- 핫스팟은 탬플릿 인터프리터라 시작할 때마다 동적으로 인터프리터를 구축한다.
    - 때문에 이해하기 훨씬 복잡하고 인터프리터 소스 코드 분석도 만만치 않다.
    - 게다가 성능 때문에 상당히 많은 어셈블리어 코드로 작성돼 있다.
- VMSpec에 없는 핫스팟 전용 바이트코드까지 정의해서 사용한다.
    - 특정 옵코드의 일반적인 유스케이스와 핫(hot)하게 쓰는 경우를 차별화하기 위해
- 핫스팟 전용 바이트코드가 처리하는 특이 사례
    - `final` 메서드는 오버라이드할 수 없기에 컴파일하면 `invokespecial` 옵코드가 나온다.
    - 그러나 자바 언어 명세에 ‘final 메서드를 final 아닌 메서드로 변경하는 건 기존 바이너리와의 호환성을 깨뜨리지 않는다.’라는 문구가 있다.

    ```java
    public class A {
        public Final void fMethod() {
            // ...
        }
    }
    
    public class CallA {
        public void otherMethod(A obj) {
            obj.fMethod();
        }
    }
    ```

    - `final` 메서드 호출부가 `invokespecial`로 컴파일되면 `CallA::otherMehtod`는 아래와 같이 컴파일된다.

    ```java
    public void otherMethod()
      Code:
        0: aload_1
        1: invokespecial #4
        4: return
    ```

    - 이 때 `A::fMethod`를 논 `final`로 바꾸면 이 메서드는 서브 클래스에서 오버라이드가 가능하다.
    - 서브 클래스 B 인스턴스를 `otherMehtod()` 메서드의 인수로 넘기면 바이트코드 수준에선 `invokespecial` 명령이 실행되니 메서드가 잘못 호출된다.
    - 이는 자바의 객체지향을 위반, 특히 리스코프 치환 원칙을 위반한다.
    - 때문에 `final` 메서드는 반드시 `invokevirtual` 명령으로 컴파일되야 한다.
    - 하지만 final은 오버라이드가 안되기 때문에 JVM의 핫스팟엔 `final` 메서드를 디스패치하는 전용 프라이빗 바이트코드가 존재한다.
