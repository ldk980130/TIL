# Chapter 12 동시 성능 기법

- 최신 하드웨어는 멀티코어 프로세서가 일반적이라 잘 만든 애플리케이션은 멀티코어에 부하를 고루 분산시킨다.
- JVM은 여러 프로세서 코어를 십분 활용 가능 VM 스레드 덕에 애플리케이션 스레드가 하나뿐이라도 멀티코어의 혜택을 누린다.
- 자바 개발자는 최신 하드웨어를 오롯이 활용하려면 동시성이 무엇인지, 애플리케이션 성능에 끼치는 영향을 무엇인지 알아야 한다.

## 12.1 병렬성이란

- 암달의 법칙에 의해 프로세서 수를 늘려도 순차 작업 시간 이상 총 소요 시간을 줄일 수 없다.
    - 병렬 태스크와 순차 태스크 간 소통의 필요가 전혀 없다면 이론적으론 속도를 무한히 높일 순 있다고 한다.
- 보통은 데이터 공유 없이 워크로드를 나누어 여러 스레드에 분산시킨다.
- 스레드끼리 상태나 데이터를 공유하기 시작하면 워크로드가 복잡해지고 일부 테스크는 순차 처리하게 된다.
    - 통신 오버헤드 발생
- 상태를 공유하는 워크로드는 무조건 정교한 보호/제어 장치가 필요하다.

### 12.1.1 자바 동시성 기초

- 아래 카운터를 락으로 적절히 보호하지 않은 상태로 멀티스레드 환경에서 실행하면 다른 스레드가 수정한 결과가 소실될 수도 있다.

    ```java
    public class Counter {
        private int i = 0;
    
        public int increment() {
            return i = i + 1;
        }
    }
    ```

    - 스레드는 메서드 개별 진입 시 각자 전용 평가 스택을 소유
    - 객체 필드는 힙에 위치하기에 모든 스레드가 공유 가능하기 때문
    - `synchronized` 키워드로 해결할 수 있고 자바 5 이전엔 이 방법이 유일했다.
- 동시 프로그램은 버그를 재연하기도 어렵다.
- 동기화를 사용할 땐 신중해야 하는데 `synchronized` 때문에 프로그램이 더 느려질 수도 있기 때문
    - 처리율 향상은 동시성과 상충되는 목표
    - 성능 테스트가 수반되어야 함

## 12.2 JMM의 이해

- JMM은 다음 질문에 답을 찾는 모델이다.
    - 두 코어가 같은 데이터를 엑세스하면 어떻게 되는가?
    - 언제 두 코어가 같은 데이터를 바라본다고 장담할 수 있는가?
    - 메모리 캐시는 위 두 질문에 답에 어떤 영향을 미치는가?
- 자바 플랫폼은 공유 상태를 어디서 엑세스하든 JMM이 약속한 내용을 반드시 이행한다.
    - 순서에 관한 보장
    - 여러 스레드에 대한 업데이트 가시성 보장

### 강한 메모리 모델과 약한 메모리 모델

- 고수준에서 JMM 같은 메모리 모델은 두 가지 방식으로 접근한다.
    - 강한 메모리 모델: 전체 코어가 항상 같은 값을 바라본다.
    - 약한 메모리 모델: 코어마다 다른 값을 바라볼 수 있고 그 시점을 제어하는 특별한 캐시 규칙이 있다.
- 최신 멀티 CPU 시스템에서 강한 메모리 모델의 문제
    - 사실상 메모리를 후기록(write-back)하는 것과 같다.
    - 캐시 무효화 알림이 메모리 버스를 잠식
    - 실제 메인 메모리 전송률 급락
    - 코어 수를 늘리는 건 상황을 악화시킬 뿐
- 강한 메모리 모델은 자바의 아키텍처 독립적 환경으로 설계된 플랫폼이라는 취지에도 맞지 않는다.
    - 네이티브 수준에서 강한 메모리 모델을 지원하지 않는다면 별도의 구현 작업이 필요해진다.
- JMM은 아주 약한 메모리 모델이기에 실제 CPU 아키텍처 추세와 잘 어울린다.
    - 또 JMM은 보장하는 내용이 거의 없어 이식 작업이 쉽다.
- 강한 메모리 모델 기반 플랫폼에서 개발한 애플리케이션은 동시성 버그를 갖고 있을 가능성이 있다.
    - 하드웨어가 보장해주는 탓에 동시성 버그가 드러나지 않음
    - 약한 메모리 모델에 배포하면 동시성 문제가 터질 수도 있는 것
    - 개발자가 그릇된 보안 감각에 빠지기 쉽다.

### JMM 기본 개념

- JMM은 다음 기본개념을 기반으로 애플리케이션을 보호한다.
    - Happens-Before: 한 이벤트는 무조건 다른 이벤트보다 먼저 발생한다.
    - Synchronizes-With: 이벤트가 객체 뷰를 메인 메모리와 동기화시킨다.
    - As-If-Serial: 실행 스레드 밖에서는 명령어가 순차 실행되는 것처럼 보인다.
    - Release-Before-acquire: 한 스레드에 걸린 락을 다른 스레드가 그 락을 획득하기 전에 해제한다.
- 자바에서 스레드는 객체 상태 정보를 스스로 들고 다닌다.
    - 스레드가 변경 내용은 메모리로 곧장 반영된다.
    - 같은 데이터를 엑세스하는 다른 스레드가 반영된 데이터를 다시 읽는 구조
- 위와 같은 맥락에서 `sychronized` 키워드가 나타내는 의미
    - ‘모니터를 장악한 스레드의 로컬 뷰가 메인 메모리와 동기화(Sychronizes-With)되었다.’
- 동기화 메서드, 동기화 블록은
    - 스레드가 반드시 동기를 맞춰야할 접점
    - 다른 동기화 메서드/블록이 시작되기 전 반드시 완료되어야 할 코드 블록
- JMM은 동기화되지 않은 엑세스에 대해선 동시성을 전혀 보장하지 않는다.
    - 쓰기에 그런 보장이 필요하면 동기화 블록으로 감싸 캐시된 값을 메모리에 후기록해야 한다.
    - 읽기 엑세스도 동기화 블록 내부에 넣어 강제로 메모리를 읽도록 해야 한다.

### synchronized 락의 한계

- 락에 걸린 객체에서 일어나는 동기화 작업은 모두 균등하게 취급된다.
    - 때문에 쓰기 작업에만 `synchronized`를 적용하면 소실된 업데이트 현상이 나타난다.
- 락 획득/해제는 반드시 메서드 수준이나 메서드 내부 동기화 블록 안에서 이루어져야 한다.
- 락을 얻지 못한 스레드는 블로킹되어 락을 얻지 못하면 실행이 불가능하다.

## 12.3 동시성 라이브러리 구축

- JMM은 성공적인 작품이긴 하지만 이해가 어렵고 응용은 더 어렵다.
    - 인트린직 락킹의 유연성도 흠이다.
- 자바 5부터 고급 동시성 라이브러리와 툴을 지원하기 시작했다.
- `java.util.concurrent` 패키지는 멀티스레드 애플리케이션을 더 쉽게 개발할 수 있게 설계된 라이브러리다.
    - 락, 세마포어(semaphore)
    - 아토믹스(atomics)
    - 블로킹 큐
    - 래치
    - 실행자(executor)
- 일반적으로 라이브러리는 OS 품에서 벗어나 유저 공간에서 더 많은 일을 하려고 한다.
    - 플랫폼 독립적으로 전역 범위에서 일관성을 보장한다는 측면에서 중요
- 일부 라이브러리는 CAS(compare and swap) 기법을 구현하기 위해 저수준 프로세서 명령어 및 OS 특성을 활용한다.
    - 락, 아토믹스 등
    - CAS: 예상되는 현재 값을 메모리 위치의 콘텐츠와 비교한 후 일치하면 현재 값을 원하는 새 값으로 교체하는 아토믹 유닛

### 12.3.1 Unsafe

- CAS 하드웨어는 s`un.misc.Unsafe` 클래스를 통해 엑세스한다.
    - 표준 자바 플랫폼 API는 아니다.
    - 개발자가 직접 사용할 일은 거의 없다.
    - 이 클래스는 핫스팟 VM에 직접 연결되고 깨질 우려가 높다.
- JVM 표준 로직을 무너뜨리는 `Unsafe`는 거의 모든 주요 프레임워크의 구현 핵심부가 됐다.
    - 객체는 할당하지만 생성자는 아직 실행하지 않는다.
    - 원메모리에 엑세스하고 포인터 수준의 연산을 수행
    - 프로세서별 하드웨어 특성(CAS)를 이용한다.
- 덕분에 같은 고수준의 프레임워크 기능을 구현 가능
    - 신속한 (역)직렬화
    - thread-safe한 네이티브 메모리 엑세스
    - 아토믹 메모리 연산
    - 효율적인 객체/메모리 레이아웃
    - 커스텀 메모리 펜스
    - 네이티브 코드와의 신속한 상호작용
    - JNI에 관한 다중 운영체제 대체물
    - 배열 원소에 volatile하게 엑세스
- 그러나 위와 같은 것들은 자바 9부터 영향을 받게 되어 자바 버전 몇 개에 걸쳐 크게 변할 가능성이 크다.

### 12.3.2 아토믹스와 CAS

- 아토믹스는 값을 더하고 증감하는 복합 연산을 통해 `get()`으로 계산한 결과를 돌려 받는다.
    - 아토믹 변수는 `volatile` 확장판이라고 할 수 있으며 더 유연해서 상태 의존적 업데이트가 가능
- 아토믹스는 자신이 감싸는 베이스 타입을 상속하지 않는다.
    - ex) `AtomicInteger`는 `Integer`를 상속하지 않음
- `Unsafe`를 이용한 아토믹 구현 원리

    ```java
    public class AtomicIntegerExample extends Number {
    
        private volatile int value;
    
        // Unsafe.compareAndSwapInt로 업데이트하기 위해 설정
        private static final Unsafe unsafe = Unsafe.getUnsafe();
        private static final long valueOffset;
    
        static {
            try {
                valueOffset = unsafe.objectFieldOffset(
                    AtomicIntegerExample.class.getDeclaredField("value"));
            } catch (Exception ex) {
                throw new Error(ex);
            }
        }
    
        public final int get() {
            return value;
        }
    
        public final void set(int newValue) {
            value = newValue;
        }
    
        public final int getAndSet(int newValue) {
            return unsafe.getAndSetInt(this, valueOffset, newValue);
        }
        // 생략
    }
    ```

    - `Unsafe`의 `getAndSetInt()` 메서드를 사용했고 JVM을 호출하는 네이티브 코드가 핵심

    ```java
    public final int getAndSetInt(Object o, long offset, int newValue) {
        int v;
        do {
            v = getIntVolatile(o, offset);
        } while (!compareAndSwapInt(o, offset, v, newValue));
        return v;
    }
    
    public native int getIntVolatile(Object o, long offset);
    
    public final native boolean compareAndSwapInt(Object o, long offset, 
                                                  int expected, int x);
    ```

    - `Unsafe` 내부에서 루프를 이용해 CAS를 반복 시도한다.
    - 루프를 이용한 아토믹 증분 연산이 `Unsafe`에 이미 존재하는 것
- 아토믹은 락-프리하므로 데드락은 있을 수 없다.
- 변수 업데이트를 위해 여러 차례 재시도를 하면 횟수만큼 성능이 나빠진다.
    - 처리율을 높게 유지하려면 경합 수준을 잘 모니터링 해야 한다.

### 12.3.3 락과 스핀락

- 인트린직 락은 OS를 이용해 스레드가 신호를 줄 때까지 기다리기 만들기 때문에 막대한 오버헤드를 유발할 수 있다.
- 스핀락(spinlock)은 완전히 상호 베타적인 락보다 가볍게 쓸 수 있는 락이다.
    - 블로킹된 스레드를 CPU에 활성 상태로 놔두고 아무 일도 시키지 않은 채 락을 얻을 때까지 ‘CPU를 태워가며’ 재시도하게 만드는 락
    - 최신 시스템은 CAS로 스핀락을 구현한다.
- 스핀락을 구현하는 코드는 CPU마다 다르겠지만 핵심 개념은 동일하다.
    - ‘테스트하고 세팅’하는 작업은 반드시 아토믹해야 한다.
    - 스핀락에 경합이 발생하면 대기 중인 프로세서는 tight loop를 실행하게 된다. (명령어는 별로 없는데 아주 많이 반복되는 루프)
- CAS는 값이 정확하다면 한 명령어로 값을 안전하게 업데이트하며 락 구성요소를 형성한다.
