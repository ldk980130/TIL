# Chapter 4. 성능 테스트 패턴 및 안티패턴

## 4.1 성능 테스트 유형

- 성능 테스트를 진행하는 경우 가장 많은 실수는 구체적인 내용을 정하지 않는 것이다.
- 테스트로 확인하고 싶은 정량적 질문과 그 테스트가 해당 애플리케이션 입장에서 중요한지 생각해야 한다.
    - 지연 테스트: 종단 트랜잭션에 걸리는 시간은?
    - 처리율 테스트: 현재 시스템이 처리 가능한 동시 트랜잭션 개수는?
    - 부하 테스트: 특정 부하를 감당할 수 있는가?
    - 스트레스 테스트: 이 시스템의 한계점은 어디인가?
    - 내구성 테스트: 시스템을 장시간 실행할 경우 성능 이상 증상이 나타나는가?
    - 용량 계획 테스트: 리소스를 추가한만큼 시스템이 확장되는가?
    - 저하 테스트: 시스템이 부분적으로 실패할 경우 어떤 일이 벌어지나?

### 4.1.1 지연 테스트

- 고객이 트랜잭션(또는 페이지 로딩)을 얼마나 오래 기다려야 하는지 측정
- 지연을 튜닝하는 목적은 유저 경험을 개선하거나 서비스 수준 협약서(service-level agreement, SLA) 조항을 이행하는 것
- 그러나 단순 평균값은 애플리케이션의 요청 응답성을 측정하는 지표로 별로 소용이 없기에 주의해야 한다.

### 4.1.2 처리율 테스트

- 어떤 측면에서 처리율은 지연과 동등한 개념
    - 지연 테스트를 수행할 때는 처리율도 반드시 명시(그리고 제어)해아 한다. (반대도 마찬가지)
    - 지연 분포가 갑자기 변하는 시점, 한계점이 바로 ‘최대 처리율’이라고 할 수 있다.
    - 스트레스 테스트의 목표는 이 지점과 그 시점의 부하 수준을 포착하는 것
- 반면 처리율 테스트는 시스템 성능이 급락하기 직전, 최대 처리율 수치를 측정하는 것이 목표이다.

### 4.1.3 부하 테스트

- ‘시스템이 이 정도 부하는 견딜 수 있을까’에 대한 답을 구하는 과정
    - ex) 신규 고객을 유치하기 전 예상되는 트래픽 확인

### 4.1.4 스트레스 테스트

- 시스템 여력이 어느 정도인지 알아보는 수단
- 특정 처리율을 기준으로 시간이 갈 수록 동시 트랜잭션은 증가하고 시스템 성능이 저하될텐데 측정값이 나빠지기 시작하기 직전 값이 바로 최대 처리율이다.

### 4.1.5 내구 테스트

- 메무리 누수, 캐시 오염, 메모리 단편화 등은 한참 시간이 지나서 드러나는 문제점이다.
- 위 종류의 문제는 내구 테스트로 감지한다.
- 내구 테스트는 빠른 응답을 요구하는 (지연이 낮은) 시스템에서 많이 한다.
    - 풀 GC가 일으키는 STW 시간도 허용하지 않음

### 4.1.6 용량 계획 테스트

- 스트레스 테스트와 비슷하지만 용량 게획 테스트는 업그레이드한 시스템이 버틸 수 있는 부하를 미리 보는 것이다.
- 이벤트나 위협 요소에 대응하는 것이 아닌 예정된 계획의 일부분으로 실행하는 경우가 많다.

### 4.1.7 저하 테스트

- 부분 실패 테스트라고도 한다.
- 저하 테스트는 부하를 가하는 도중, 서브시스템이 능력을 상실하는 시점에 벌어지는 일들을 확인한다.
- 저하 테스트에선 트랜잭션 지연 분포와 처리율을 눈여겨 봐야 한다.
- 카오스 멍키(Chaos Monkey)
    - 복원성 있는 아키텍처에서는 한 컴포넌트가 잘못돼도 다른 컴포넌트까지 연쇄적으로 무너지지 않아야 한다.

## 4.2 기본 베스트 프랙티스

- 성능 튜닝 시 주안점을 두어야 할 세 가지 기본 원칙
    - 나의 관심사가 무엇인지 식별하고 측정 방법 고민
    - 최적화하기 용이한 부분이 아니라 중요한 부분을 최적화
    - 중요한 관심사를 먼저 다룬다.

### 4.2.1 하향식 성능

- 자바 애플리케이션을 대규모 벤치마킹하는 일이 작은 코드 섹션별로 정확한 수치를 얻는 것보다 쉽다.

> 하향식 성능 - 전체 애플리케이션의 성능 양상부터 먼저 알아보는 접근 방식
>
- 하향식 접근 방식으로 성과 극대화 하는 방법
    - 무엇을 측정하고 최적화해야 하는지 명확히 이해
    - 성능 활동을 전체 소프트웨어 개발 주기에서 어떻게 병행해야 하는지 명확히 이해

### 4.2.2 테스트 환경 구축

- 테스트 환경은 가급적 모든 면에서 운영 환경과 똑같이 복제해야 한다.
    - CPU 수, OS, 자바 버전, 웹 서버, DB, 로드 밸런서 등
- 편의상 기존 QA 환경을 성능 테스트 환경으로 재활용할 수도 있다.
    - 소규모 환경이나 일회성 테스트라면 괜찮겠지만 관리 오버헤드, 스케줄링, 로지스틱스(물류) 문제가 생길 가능성도 존재
- 성능 테스트 인프라 구축엔 비용이 들지만 테스트 환경 구축 비용을 아끼려다 서비스 중단으로 더 큰 대가를 치를 수도 있다.

### 4.2.3 성능 요건 식별

- 성능 비기능 요건(NonFunctional Requirement, NFR)
    - 코드 관점 뿐만이 아닌 시스템을 전체적으로 바라봤을 때 고객과 경영진에게 중요한 측정값
    - 최적화하려는 핵심 지표
- 명확한 목표
    - 95% 백분위 트랜잭션 시간을 100밀리초 줄인다
    - 하드웨어 처리율 5배 높일 수 있게 시스템을 개선한다
    - 평균 응답시간을 30% 줄인다.
- 모호한 목표
    - 일반 고객을 서비스하는 리소스 비용을 50% 줄인다.
    - 애플리케이션 클러스터 성능이 50% 덜어져도 시스템 응답 목표를 25% 이내로 유지한다.
    - 고객 이탈률을 25밀리초 지연당 25% 낮춘다.

### 4.2.4 자바에 특정한 이슈

- JVM은 메모리 영역의 동적 튜닝 등 특유의 동적 자기 관리 기능이 있어 성능 엔지니어가 주의 깊게 봐야할 부분들이 있다.
- JIT 컴파일러의 경우 어떤 메서드를 JIT 컴파일해서 최적화한 기계어로 변환할지 분석한다.
- JIT 컴파일 대상이 아닌 메서드는 다음 둘 중 하나다.
    - 자주 실행되는 메서드가 아니다.
    - 메서드가 너무 크고 복잡해서 컴파일 분석을 할 수 없다.
- JVM 성능 활동 첫 단추는 어떤 메서드가 컴파일 중인지 로그를 남겨 살피는 것
    - 핵심 코드의 중요 메서드가 잘 컴파일되고 있는지

### 4.2.5 SDLC 일부로 성능 테스트 수행하기

- 수준 높은 팀일수록 성능 테스트를 전체 SDLC의 일부로 수행하며 특히 성능 회귀 테스트를 상시 수행하는 편이다.
    - Software Development LifeCycle

## 4.3 성능 안티패턴 개요

- 성능 튜닝은 항상 목표 지향형 프로세스로 접근해야 한다.
    - 기획 단계부터 구체적인 목표를 정해놓고 시작
- 신규 서비스 오픈 시 예기치 않은 사고가 발생하는 경우
    - 성능 테스트를 진행하지 않았거나
    - 온갖 추정만 했거나
- 개발 이슈의 대부분 기술적인 측면보다 의사소통 문제 같은 인적 요소가 원인일 때가 많다.
- “왜 개발자는 잘못된 기술 선택을 밥 먹듯이 하나”라는 블로그 게시글에서 그 원인을 다섯 가지로 분류한다.

### 4.3.1 지루함

- 개발자는 자기 역할에 지루함을 느끼고 도전적인 일을 할 때가 있다.
- 지루함에서 시작된 도적은 프로젝트에 여러 해약을 끼칠 수 있다.
    - 잘 구현된 라이브러리를 사용하지 않고 직접 구현
    - 알려지지 않은 기술로 컴포넌트를 제작
    - 맞지도 않은 유스케이스에 억지로 기술을 욱여 넣기

### 4.3.2 이력서 부풀리기

- 본인의 이력서를 과대 포장할 구실을 찾는 개발자도 존재한다.
- 이런 사고로 프로젝트를 불필요한 방향으로 끌고 가는 선택의 발단이 될 수도 있다.

### 4.3.3 또래 압박

- 기술 결정 시 충분한 논의 없이 진행하면 잘못된 결과가 나오기 쉽다.
    - ex) 선배 앞에서 실수 안 하려는 신입 개발자
    - ex) 특정 주제를 잘 모른다는 것을 두려워하는 개발자
- 제대로 사정을 따지지 않고 섣불리 중요한 결정을 내려버릴 수도 있다.

### 4.3.4 이해 부족

- 지금 사용하는 툴도 잘 모르는데 무턱대고 새로운 툴로 문제를 해결하려는 개발자가 있다.
- 새로 나온 멋진 기술도 좋지만 기술 복잡도를 높이는 것과 현재 툴로도 할 수 있는 것 사이의 균형을 잘 맞추어야 한다.
- 이해가 부족한 상태에서 새로운 기술을 복잡하게 사용하게 되면 운영 단계에서 회복 불가능한 중단 사태를 맞이할 수도 있다.

### 4.3.5 오해와 있지도 않은 문제

- 문제 자체를 제대로 이해하지 못한 채 오로지 기술을 이용해서 문제를 해결하려는 개발자가 있다.
    - 성능 수치를 측정도 안 해보고 성공을 장담할 수는 없다.
- 안티 패턴을 예방하려면 팀원 모두 기술 이슈를 활발히 공유하는 분위기를 적극 장려해야 한다.
