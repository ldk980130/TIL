# Chapter 8. GC 로깅, 모니터링, 튜닝, 툴

## 8.1 GC 로깅 개요

- GC 로그는 시스템이 내려간 원인을 찾는 ‘콜드 케이스’ 분석을 할 때 미우 유용하다.
    - 로그를 분석하기 때문에 애플리케이션 프로세스가 살아있지 않아도 된다.
- 모든 중요한 애플리케이션에는 다음 두 가지를 설정해야 한다.
    - GC 로그를 생성한다.
    - 애플리케이션 출력과는 별도로 특정 파일에 GC 로그를 보관한다.
- GC 로깅은 오버헤드가 거의 없기에 주유 JVM 프로세스는 항상 로깅을 켜놓아야 한다.

### 8.1.1 GC 로깅 켜기

- 다음 스위치를 추가한다.

```
-Xloggc:gc.log -XX:+PrintGCDetails -XX:+PrintTenuringDistribution
-XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps
```

| 플래그 | 작용 |
| --- | --- |
| -X:loggc:gc.log | GC 이벤트에 로깅할 파일을 지정 |
| -XX:+PrintGCDetails | GC 이벤트 세부 정보를 로깅 |
| -XX:+PrintTenuringDistribution | 툴링에 필요한, 부가적인 GC 이벤트 세부 정보 추가 |
| -XX:+PrintGCTimeStamps | GC 이벤트 발생 시간을 (VM 시작 이후 경과한 시간을 초 단위로) 출력 |
| -XX:+PrintGCDateStamps | GC 이벤트 발생 시간을 (벽시계 시간 기준) 출력 |
- 주의할 점
    - 기존 플래그 `verbose:gc`는 지우고 대신 `PrintGCDetails`를 사용
    - `PrintTenuringDistribution`은 독특한 플래그로 이 플래그가 제공하는 정보를 사람이 이용하기 어렵다.
        - 중요한 메모리압(memory pressure) 효과, 조기 승격 등의 이벤트 계산 시 필요한 기초 데이터를 제공
    - `PrintBCDateStamps`와 `PrintGCTimeStamps`는 둘 다 필요
        - 전자는 GC 이벤트와 애플리케이션 이벤트를 연관 짓는 용도
        - 후자는 GC와 다른 내부 JVM 이벤트를 연관 짓는 용도

### 8.1.2 GC 로그 vs JMX

- 자바 관리 확장(Java Management eXtensions) 인터페이스를 통해 JVM 데이터를 수집한다.
- JMX는 GC에 영향을 준다.
    - GC 로그 데이터는 GC 이벤트가 발생해서 쌓이지만 JMX는 데이터를 샘플링하여 얻는다.
    - GC 로그 데이터는 캡쳐 영향도가 거의 없지만 JMX는 프록시 및 원격 메서드 호출 과정에서도 암묵적인 비용이 든다.
    - GC 로그 데이터에는 자바 메모리 관리에 연관된 성능 데이터가 50가지 이상 있지만 JMX는 10가지도 안 된다.
- JMX는 성능 데이터 원천으로서 스트리밍된 데이터를 즉시 제공할 수 있다.

> 기본적인 힙 상태를 파악하는 용도로는 JMX가 제격이지만 깊이 있는 진단에서는 부족하다.
>
- JMX로 가져온 빈은 표준 빈이고 쉽게 엑세스 가능하다.
    - MBean이라고 부르는데 각종 디바이스, 애플리케이션을 비롯한 관리되어야 할 리소스를 빈으로 나타낸 것

### 8.1.3 JMX의 단점

- JMX를 이용하면 대부분 런타임을 샘플링하여 현재 상태를 업데이트한다.
    - 클라이언트는 런타임에 있는 JMX 빈을 풀링한다.
- 문제는 가비지 수집
    - GC 실행 시점을 알 수 없어 수집 전후 메모리 상태 역시 알 수가 없다.
    - 정확한 분석에선 GC 전후 힙 상태 정보가 대단히 중요하다.
    - 즉 GC 데이터를 깊이 있고 정확하게 분석할 수 없다.
- JMX로 얻은 데이터로는 장기적 추이를 파악하는 정도로만 쓸 수 밖에 없다.
- 메모리압(할당률)을 분석하는 활동이 매우 중요한데 JMX는 이를 할 수 없다.
- JMXConnector 명세를 구현한 코드는 내부적으로 RMI에 의존하므로 RMI 기반 통신 채널의 고질적 문제점에 취약하다.
    - 방화벽에 포트를 열어야 하므로 부차 소켓 접속이 맺어질 수 있다.
    - 프록시 객체를 이용해 `remove()` 메서드 호출을 대행
    - 자바 종료화(finallization)에 의존
    - RMI를 사용하면 기본 1시간에 한 번씩 풀 GC가 발생

### 8.1.4 GC 로그 데이터의 장점

- GC 튜닝의 복잡함을 감안하더라도 런타임에 발생한 일을 파악하는 데 GC 로그는 아주 유용하다.

> GC 로그는 핫스팟 JVM 내부에서 논블로킹 쓰기 매커니즘을 이용하여 남긴다. 애플리케이션 성능에 미치는 영향은 거의 0이므로 운영계는 무조건 켜두어야 한다.
>
- GC 로그에 쌓인 기초 데이터는 특정 GC 이벤트와 연관 지을 수 있다.
- GC 로그를 통해 모든 의미 있는 분석 작업을 수행할 수 있다.

## 8.2 로그 파싱 툴

- GC 로그 메시지는 정해진 언어나 VM 명세 표준 포맷이 따로 없다.
    - 핫스팟 GC 개발팀 마음이라 릴리즈 간 포맷이 조금씩 다르다.
- 단순한 로그 포맷 파싱은 어렵지 않지만 GC 로그 플래그가 하나둘 추가되면 로그도 엄청 복잡해진다.
- GC 설정을 변경해 로그 출력 포맷이 달라지면 수동 GC 로그 파서를 쓰는 시스템에선 로깅이 끊어질 수 있다.

> 스스로 GC 로그를 파싱하려고 하지 말고 반드시 툴을 사용할 것
>

### 8.2.1 센섬

- jClarity사가 제작한 상용 메모리 분석기
- 센섬은 최고의 GC 로그 파싱, 정보 추출, 자동 분석 기능을 제공하는 것이 목표이다.
- 센섬 SaaS 모니터링 서비스를 이용하면 전체 클러스터 상태를 한눈에 볼 수 있다.
- OpenJDK 소스에 체크인된 코드베이스 중 로깅 관련 소스 코드를 낱낱이 분석해서 변경된 로그파일 포맷을 철저히 반영한다.
- 센섬 최신 버전이 지원하는 자동 분석 기능
    - 정확한 할당률
    - 조기 승격
    - 공격적인 할당
    - 유저 이탈
    - 메모리 누수 감지
    - 힙 크기 조정 및 용량 계획
    - VM에 대한 OS 간섭
    - 크기를 잘못 잡은 메모리 풀
- 자세한 정보는 https://www.jclarity.com 참고

### 8.2.2 GCViewer

- GC 로그 파싱 및 그래프 출력 등 기본 기능을 갖춘 데스크톱 툴
- 오픈소스인 점이 장점이지만 상용 툴에 비해 빈약하긴하다.
- https://github.com/chewiebug/GCViewer를 내려받아 컴파일/빌드 후 실행 가능한 JAR 파일로 패키징하면 된다.
- GC 로그파일은 GCViewer 메인 UI에서 열어볼 수 있다.
- 분석 기능은 없고 특정 GC 핫스팟 로그 포맷만 파싱할 수 있다.

## 8.3 GC 기본 튜닝

- GC 튜닝 역시 다른 튜닝 기법처럼 전체 진단 과정의 일부여야 한다.
- GC 튜닝 시 기억할 점
    1. GC가 성능 문제를 일으키는 원인이라고 확인하거나 그렇지 않다고 배제하는 행위는 저렴하다.
    2. UAT에서 GC 플래그를 켜는 것도 저렴한 행위
    3. 메모리 프로파일러, 실행 프로파일러를 설정하는 작업은 결코 저렴하지 않다.
- 엔지니어는 튜닝 시 다음 네 가지 주요 인자를 면밀히 관찰/측정해야 한다.
    - 할당, 중단 민감도, 처리율 추이, 객체 수명
    - 가장 중요한 요인은 ‘할당’
- 힙 크기를 조정하는 기본 플래그


    | 플래그 | 작용 |
    | --- | --- |
    | -Xms<size> | 힙 메모리의 최소 크기를 설정 |
    | -Xmx<size> | 힙 메모리의 최대 크기를 설정 |
    | -XX:MaxPermSize=<size> | 펌젠 메모리의 최대 크기를 설정 (자바 7 이전) |
    | -XX:MaxMetaspaceSize=<size> | 메타스페이스 메모리 최대 크기를 설정 (자바 8 이후) |
- 튜닝 시 GC 플래그는 다음과 같이 추가한다.
    - 한 번에 한 플래그씩 추가한다.
    - 각 플래그가 무슨 작용을 하는지 숙지해야 한다.
    - 부수 효과를 일으키는 플래그 조합도 있음을 명심한다.
- 현재 이벤트 발생 중이라면 성능 문제 원인이 GC인지 아닌지 판단하는건 어렵지 않다.
    - vmstat 같은 툴로 고수준 머신 지표를 체크하고 다음을 확인한다.
    - CPU 사용률이 100%에 가까운가?
    - 대부분의 시간(90%이상)이 유저 공간에서 소비되는가?
    - GC 로그가 쌓이고 있다면 현재 GC가 실행 중이라는 증거
- 지난 이벤트를 조사하려면 모니터링 이력 데이터가 쌓여 있어야 한다.
    - CPU 사용률, 타임스탬프가 찍힌 GC 로그 등
- 세 가지 조건이 다 맞는다면 GC 성능 이슈를 일으키고 있을 가능성이 크고 튜닝이 필요하다.

### 8.3.1 할당이란?

- 할당률 분석은 튜닝 방법뿐 아니라 실제로 GC 튜닝 시 성능이 개선될지 여부를 판단하는 데 꼭 필요한 과정이다.
- 영 GC 이벤트 데이터로 할당된 데이터양, 단위 수집 시간을 계산할 수 있다.
    - 일정 시간 동안의 평균 할당률도 산출할 수 있다.

> 할당률을 수작업으로 계산하지 말고 툴을 써서 계산할 것
>
- 할당률 수치가 1GB/s 이상으로 일정 시간 지속한다면 십중팔구 GC 튜닝만으로는 해결할 수 없는 성능 문제다.
    - 이 경우 애플리케이션 핵심부의 할당 로직을 제거하는 리팩터링을 수행해야 한다.
- 초기 할당 전략은 다음 네 가지 단순 영역에 집중하는 것이 좋다.
    - 굳이 없어도 그만인 사소한 객체 할당 (로그 디버깅 메시지)
    - 박싱 비용
    - 도메인 객체
    - 엄청 많은 논JDK 프레임워크 객체
- 드물지만 도메인 객체가 메모리를 많이 차지하는 일도 있는데 주로 다음 타입 문제다.
    - `char[]`: 스트링을 구성하는 문자
    - `byte[]`: 바이너리 데이터
    - `double[]`: 계산 데이터
    - 맵 엔트리
    - `Object[]`
    - 내부 자료 구조 (ex: methodOop, klassOop)
- 도메인 객체가 위의 타입 문제로 너무 뚱뚱하면 조기 승격 문제를 겪게 된다.
    - 스레드 당 TLAB 크기가 동적 조정되는데 너무 큰 객체로 인해 TLAB 할당이 어려울 수 있다.
    - 그러면 에덴에 직접 객체 할당을 시도한다.
    - 이것도 실패하면 영 GC를 수행한다.
    - 그래도 공간이 부족하면 테뉴어드 영역에 직접 할당한다.
- 핫스팟은 TLAB 및 큰 객체의 조기 승격에 관한 튜닝 플래그를 제공한다.
    - -`XX:PretenureSizeThreashold=<n>`
    - `-XX:MinTLABSize=<n>`
- 할당률은 테뉴어드로 승격되는 객체 수에 영향을 끼친다.
    - 할당률이 높을수록 영 GC 주기가 짧아지고 단명 객체가 테뉴어드로 잘못 승격될 가능성이 크다.
- 조기 승격 문제는 다음 스위치가 유용하다.
    - `-XX:MaxTenuringThreshold=<n>`
    - 테뉴어드로의 승격 전까지 객체가 겪어야 할 GC 횟수를 설정 (디폴트: 4, 1 ~ 15 설정 가능)
    - 한계치가 높을수록 진짜 장수한 객체를 더 많이 복사하고, 한계치가 너무 낮으면 단명 객체가 승격되어 메모리압을 가중시킨다.

### 8.3.2 중단 시간이란?

- 대부분의 애플리케이션에서 100밀리초 정도의 중단 시간은 무시할 만하다.
    - 웹 애플리케이션 등에서 100 ~ 200 밀리초 정도의 중단은 눈치채기도 어렵다.
- 중단 시간 튜닝 시 유용한 휴리스틱
    1. 1초: 1초 이상 걸려도 괜찮다.
    2. 1초 ~ 100밀리초: 100밀리초 이상 1초 이하 정도는 괜찮다.
    3. < 100 밀리초: 100밀리초까지는 괜찮다.
    - 중간 민감도를 애플리케이션 힙 크기와 대략 연관 지어보면 어떤 수집기가 적합한지 가늠할 수 있다.

> 동시 수집기를 사용할 경우 중단 시간 튜닝보단 할당률부터 줄여야 한다. 할당률이 낮아지면 동시 수집기에 가해지는 메모리압도 낮아지므로 수집 사이클이 스레드 할당 속도를 따라가기 쉬워진다. 또 CMF 이벤트 발생 확률이 감소한다.
>

### 8.3.3 수집기 스레드와 GC 루트

- GC 루트 탐색 시간은 다음 요인에 영향을 받는다.
    - 애플리케이션 스레드 개수
    - 코드 캐시에 쌓인 컴파일드 코드량
    - 힙 크기
- 런타임 조건 및 적용 가능한 병렬화 정도에 따라서도 달라진다.
    - ex) 마킹 단계에서 엄청 큰 Object[]를 발견했다고 하면 이 단일 스레드의 탐색 시간이 전체 마킹 시간을 결정짓게 된다.
    - 객체 그래프가 복잡해질수록 이런 현상은 더욱 심해진다.
- 애플리케이션 스레드가 너무 많아도 GC 시간에 영향을 끼친다.
    - 스택 프레임을 더 많이 탐색해야 한다.
    - 세이프포인트에 도달하는 시간도 길어진다.
- JNI 프레임과 JIT 컴파일드 코드용 캐시 등 다른 GC 루트 원천들도 있다.

## 8.4 Parallel GC 튜닝
