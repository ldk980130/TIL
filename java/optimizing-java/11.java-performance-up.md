# Chapter 11. 자바 언어의 성능 향상 기법
## 11.1 컬렉션 최적화

- 대부분 언어 라이브러리는 최소 두 가지 컨테이너를 제공한다.
    - 순차 컨테이너: 수치 인덱스로 표기한 특정 위치에 객체를 저장
    - 연관 컨테이너: 객체 자체를 이용해 컬렉션 내부에 저장할 위치를 결정
- 컨테이너에서 메서드가 정확히 작동하려면 객체가 호환성과 동등성 개념을 지니고 있어야 한다.
    - 코어 자바 컬렉션 API에서 모든 객체는 `hashCode()`, `equals()` 구현해야 한다.
- 참조형 필드는 힙에 레퍼런스로 저장된다.
    - 컨테이너에 저장되는 건 객체 자신이 아니라 객체를 가리키는 레퍼런스이기에 C/C++의 배열에서만큼의 성능을 얻을 순 없다.
- 자바는 서브시스템이 알아서 가비지 수집을 해주는 대신 저수준의 메모리 제어를 포기한다.
- 컬렉션 API는 타입별로 해당 컨테이너가 준수해야 할 작업을 구체적으로 명시한 인터페이스 모음

## 11.2 List 최적화

- 자바에서의 두 가지 리스트 기본 형태
    - `ArrayList`, `LinkedList`

### 11.2.1 ArrayList

- 고정 크기 배열에 기반한 리스트
    - 배열이 꽉 차면 더 큰 배열을 새로 할당해 기존 값을 복사
    - 성능을 신경쓰려면 크기 조정 작업 비용을 고려해야 함
- 기본 용량은 10이지만 초기 용량값을 생성자에 전달할 수도 있다.
    - `new ArrayList<>(1000000);`
- `ensureCapacity()` 메서드로 용량을 늘려 크기 조정 작업을 건너뛸 수 있다.

### 11.2.2 LinkedList

- 동적으로 증가하는 리스트
- 이중 연결 리스트이기에 `add()` 작업은 항상 O(1)이다.

### 11.2.3 ArrayList vs LinkedList

- 둘 중 어느 것을 쓸지는 데이터 접근/수정 패턴에 따라 다르다.
- 원소 추가 작업
    - 리스트 끝에 원소를 추가하는 작업은 두 리스트 모두 일정한 시간이 소요된다.
    - 특정 인덱스에 원소를 추가하는 경우 `ArrayList`는 다른 원소를 모두 한 칸씩 밀어야한다.
    - `LinkedList`는 특정 인덱스에 추가해도 레퍼런스만 변경하면 된다.
- 조회 작업
    - `ArrayList`는 랜덤 엑세스 하는 경우 모든 원소를 O(1)만에 가져올 수 있다.
    - `LinkedList`는 인덱스 카운트만큼 원소를 방문해야 한다.
- `LinkedList` 고유 기능이 필요한 경우가 아니고 랜덤 엑세스가 필요한 알고리즘에선 `ArrayList`를 권장
    - 가급적 크기를 미리 지정하여 중간에 다시 조정하는 일이 없도록 하는 것이 좋다.
