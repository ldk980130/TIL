# Chapter 13. 프로파일링

- 프로파일링의 여러 접근 방식 중 다음 두 가지가 가장 일반적
    - 실행
    - 할당
- 신중한 성능 엔지니어는 여러 툴로 프로파일링하면서 실제로 무슨 일이 벌어지는지 편향 가능성을 인지한 상태에서 문제점을 보완할 방법을 모색할 것이다.

## 13.1 프로파일링 개요

- 넓은 의미에서 다음 세 가지를 명확히 구분해야 한다.
    - 모니터링 툴 - 시스템 현재 상태를 살핌
    - 경고 시스템 - 비정상적/변칙적 움직임을 감지
    - 프로파일러 - 실행 중인 애플리케이션의 심층 정보를 제공
- 프로파일링의 목표는 리팩터링 및 성능 최적화 대상 코드를 식별하는 것
- 성능 엔지니어는 프로파일링을 수행하기 전에 성능 문제 원인이 애플리케이션 코드라는 사실을 입증해야 한다.
    - CPU 사용률이 유저 모드에서 100%에 육박하는 경우
    - GC STW 같은 요소는 GC 로깅을 통해 간단히 확인해볼 수 있으니 원인 후보군에서 제외해야 함
    - GC 로그가 난리라면 프로파일링이 아니야 GC 튜닝을 해야 한다.

## 13.2 샘플링과 세이프포인팅 편향

- 실행 중인 코드의 자료점(data point, 스택 트레이스)을 대부분 샘플링을 통해 획득한다.
    - 데이터 수집 비용을 줄이기 위해 메서드 입출구는 보통 추적하지 않는다.
    - 스레드 스냅샷을 낮은 빈도로 찍으면 오버헤드가 크지 않다.
- 샘플링 주기는 성능 엔지니어의 갈등을 일으키는 문제
    - 성능이 예민한 시스템에 잦은 샘플링은 오버헤드가 크고 그렇다고 뜸한 샘플링은 중요한 장면을 놓칠 수 있다.
- 세이프포인트 편향
    - 대부분의 샘플링이 세이프포인트에서만 일언나는 문제점
    - 모든 스레드는 샘플을 뜨기 전 세이프포인트에 다다라야 한다.
    - 세이프포인트 지점에 있는 애플리케이션 상태만 샘플링할 수 있다.
    - 모든 스레드가 세이프포인트에 있어야 하므로 오버헤드가 가중된다.
    - 표본점 분포가 왜곡될 소지가 있다.
- 애플리케이션에서 세이프포인팅 시간은 예의주시해야 한다.
    - JVM 플래그를 통해 세이브포인팅 시간이 높은 경우를 추적할 수 있다.
    - `-XX:+PrintGCApplicationStoppedTime`
- 세이프포인팅 편향 문제는 카운티드 루프로도 설명할 수 있다.

    ```java
    for (int i = 0; i < LIMIT; i++) {
        // 루프 바디에는 '단순' 작업만 있다.
    }
    ```

    - ‘단순’ 작업이란 이를테면 기본 산술 연산이나 완전 인라이닝된(메서드가 하나도 없는) 메서드 호출 등
    - 만약 `LIMIT` 값이 크다면 JIT 컴파일러는 루프 처음으로 되돌리는 백 브랜치를 포함하고 루프 백 끝에 세이프포인트 체크를 삽입한다.
    - 반면 `LIMIT` 값이 작다면 루프가 펼쳐져 세이프포인트를 하지 않는다.
    - 즉 세이프포인트에서만 샘플링하면 루프 크기와 그 안에서 하는 작업 성격에 크게 좌우되는 편향 작동을 하게 된다.
    - 루프가 펼쳐지면 엄청 많은 코드가 생성되어 한 번도 샘플링되지 않을 비대한 코드 덩이가 만들어질 수도 있다.
- 세이프포인팅 편향 문제는 성능 엔지니어가 숙지해야 할 트레이드 오프를 잘 보여주는 전형이다.

## 13.3 개발자용 프로파일링 툴

### 13.3.1 VisualVM 프로파일러

- [VisualVM](https://visualvm.github.io/)은 실행 프로파일러, 메모리 프로파일러가 모두 들어 있는 무료 툴
- 기능이 한정되어 운영에서는 거의 쓰지 않지만 개발/QA 환경에서 유용하다.

### 13.3.2 JProfiler

- [JProfiler](https://www.ej-technologies.com/products/jprofiler/overview.html)는 에이전트에 기반한 유명한 상용 프로파일러
- GUI 모드, 헤드리스 모드(명령줄 기반)로 로컬 또는 원격 애플리케이션을 프로파일링할 수 있다.
- 윈도우, 맥, 리눅스 등 지원하는 OS 범위도 넓다.

### 13.3.3 YourKit

- [YourKit](https://www.yourkit.com/)은 유어킷 사가 개발한 상용 프로파일러
- GUI를 제공하고 동적으로 어태치, 애플리케이션 시작 시 설정하는 측면에서 JProfiler와 닮았다.
    - 두 툴 모드 세이프포인트 샘플링을 하기에 편향과 한계점이 존재

### 13.3.4 JFR/JMC

- [자바 비행 기록기(java flight recorder)/자바 관제 센터(java mission control)](https://docs.oracle.com/en/java/java-components/index.html)는 오라클의 프로파일링/모니터링 기술
- 자바 8 기준으로 오라클 JVM에서만 쓸 수 있는 상용 툴
    - OpenJDK 및 다른 JVM에서는 못 쓴다.
- JFR을 사용하려면 다음 스위치를 전달한다.
    - `-XX:+UnlockCommercialFeatures -XX:+FlightRecorder`
- 오라클은 자바 9 이후부터 배포하는 메인 JDK는 오라클 JDK가 아니라 OpenJDK가 될 거라 밝혔다.
    - 그렇게 되면 무료 툴이 될 것

### 13.3.5 운영 툴

- 프로파일러는 문제 진단, 런타임 저수준 작동 파악에도 사용하지만 모니터링 툴로도 많이 쓰인다.
- 레드햇 서모스탯
    - JVM 전용 오픈 소스 서버서빌리티/모니터링 솔루션
    - 단일 머신, 클러스터 모두 모니터링 가능
    - 이력 데이터와 시점 별 상태는 몽고 DB저장
- 뉴 렐릭
    - 클라우드 기반 애플리케이션용 SaaS 제품
    - JVM 뿐 아니라 사용 범위가 넓은 툴 세트
    - 종합 모니터링, 풀스택 지원 기능이 돋보이는 운영/데브옵스 툴
    - 쏟아내는 데이터 양이 엄청나서 출력 데이터 추이를 제외하면 특징을 잡아내기 어려울 때가 많다.
- jClarity 일루미네이트
    - 프로파일링 툴과 모니터링 툴 사이의 징검다리 역할
    - 일루미네이트는 메인 자바 애플리케이션을 관찰하는 별도의 외부 데몬 프로세스를 이용한 모니터링 모드로 작동한다.
    - JVM에 이상한 점이 발견되면 일루미네이트가 애플리케이션을 파헤치기 시작한다.
    - OS, GC 로그, JVM 데이터를 분석한 머신 러닝 알고리즘으로 성능 문제 근본 원인을 밝힌다.

## 13.4 최신 프로파일러

- [어니스트 프로파일러](https://github.com/jvm-profiling-tools/honest-profiler)는 최신 오픈 소스 툴로 다음 목표를 가지고 있다.
  - 다른 대부분의 프로파일러에 있는 세이프포인트 편향을 없앤다.
  - 오버헤드가 아주 낮은 상태로 작동시킨다.
- 어니스트 프로파일러는 핫스팟 JVM, 오라클, 레드햇, 아줄 줄루 JVM에선 잘 동작하지만 논-OpenJDK 계열에선 사용 불가
- 이 프로파일러 구현체는 SIGPROF라는 유닉스 OS 시그널을 전송해 실행 스레드를 인터럽트한다.
  - 어니스트 프로파일러는 핫스팟 내부의 `AsyncGetCallTrace`라는 프라이빗 API를 활용한다.
  - `AsyncGetCallTrace()`을 통해 호출 스택을 수집할 수 있다.
  - 스레드만 따로 인터럽트하므로 전역 동기화 이벤트는 없어서 오버헤드가 거의 나타나지 않는다.
- 어니스트 프로파일러의 단점은 일부 스레드 제일 위에 ‘Unknown’이라고 표시되는 현상이다.
  - JVM 인트린직 때문에 발생하는 부수 효과
  - 프로파일러가 진짜 자바 스택 트레이스로 정확하게 다시 매핑되지 못하는 것

## 13.5 할당 프로파일링

- 할당 프로파일링은 애플리케이션 할당 동작을 살피는 표준 메모리 프로파일링이다.
  - 대부분 애플리케이션은 일정 수준의 메모리 프로파일링도 병행해야 한다.
- JVM에서 메모리 할당을 지시하는 바이트코드는 다음 세 가지 입니다.
  - `NEW`: 주어진 타입 객체를 생성할 공간을 할당
  - `NEWARRAY`: 기본형 배열 공간을 할당
  - `ANEWARRAY`: 주어진 타입의 객체 배열 공간을 할당
  - 할당 옵코드는 이 셋 뿐이므로 인스트루먼테이션할 바이트코드도 이들뿐이다.
- 가장 단순한 인스트루먼테이션은 할당 옵코드를 지닌 인스턴스를 하나하나 찾아내 옵코드가 실행되기 직전 로깅하는 정적 메서드 호출부를 삽입하는 것
  - 하지만 메모리가 할당될 때마다 부가적인 호출이 발생하기에 운영계에선 적절하지 않다.
  - JIT 컴파일을 통해 호출부가 인라이닝되겠지만 전체 성능에 무시 못 할 영향을 끼칠 수 있다.
- TLAB을 이용해 할당 프로파일링하는 방법도 있다.
  - 핫스팟 전용 콜백을 이용해 TLAB에 객체가 할당되거나 TALB 밖에 객체가 할당될 때 알림을 수신할 수 있다.
  - 매 n킬로바이트 단위로 뭉뚱그려 할당을 기록 (n은 TLAB의 평균 크기)
  - 운영계에 써도 괜찮을 정도의 저렴한 비용으로 힙 샘플링할 수 있으나 불완전할 수도 있다.

## 13.6 힙 덤프 분석

- 힙 덤프 분석 역시 빼놓을 수 없는 할당 프로파일링 기법이다.
  - 전체 힙의 스냅샷을 뜯어보며 어떤 객체가 살아 있는지, 그 개수와 타입은 어떤지 등의 객체 그래프 형상/구조를 파악
- 하지만 힙 덤프는 크기가 문제
  - 덤프한 메모리 크기가 너무 크면 디스크에 쓰는 것도 문제지만 네트워크를 통해 가져올 때 더 골치가 아프다.
  - 전체 힙을 뒤져야하므로 STW 이벤트도 불가피
- 대부분 애플리케이션에서 프로파일링 주 관심사는 할당 프로파일링과 힙 프로파일링
  - 메모리 희생을 감수하면서까지 실행 프로파일링에 너무 몰입하지 않는 편이 좋다.
