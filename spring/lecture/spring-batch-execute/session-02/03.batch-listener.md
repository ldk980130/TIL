# Spring Batch Listener와 활용

- 리스너는 배치 처리 중 발생하는 특정 이벤트를 감지하고 동작을 정의할 수 있게 해준다.
    - 이를 통해 로깅, 모니터링, 에러 처리 등을 수행할 수 있다.

## JobExecutionListener

- `Job` 실행의 시작과 종료 시점에 호출되는 리스너 인터페이스
- `afterJob`
    - `Job` 실행 정보가 메타데이터에 저장되기 전에 호출된다.
    - 특정 조건에 따라 `Job` 실행 결과 상태를 완료(`COMPLETED`)에서 실패(`FAILED`)로 변경하거나 반대도 가능

```java
public interface JobExecutionListener {
    default void beforeJob(JobExecution jobExecution) { }
    default void afterJob(JobExecution jobExecution) { }
}
```

## StepExecutionListener

- `Step` 실행의 시작과 종료 시점에 호출되는 리스너 인터페이스

```java
public interface StepExecutionListener extends StepListener {
    default void beforeStep(StepExecution stepExecution) { }

    @Nullable
    default ExitStatus afterStep(StepExecution stepExecution) {
			return null;
    }
}
```

- `afterStep`에서의 `ExitStatus` 반환을 통해 `Step` 실행 결과 상태를 직접 변경 가능하다.

## ChunkListener

- 하나의 청크 단위 처리가 시작되기 전/후 그리고 에러 발생 시 호출되는 리스너 인터페이스

```java
public interface ChunkListener extends StepListener {
    default void beforeChunk(ChunkContext context) { }

    default void afterChunk(ChunkContext context) { }
	
    default void afterChunkError(ChunkContext context) { }
}
```

- `afterChunk`는 트랜잭션 커밋 후 호출된다.
- `afterChunkErrror`는 트랜잭션 롤백 이후 호출된다.

## Item[Read|Process|Write]Listener

- 아이템의 읽기/처리/쓰기 작업의 수행 시점에 호출되는 인터페이스들도 있다.
  - `ItemReadListener`
  - `ItemProcessListener`
  - `ItemWriteListener`

```java
public interface ItemReadListener<T> extends StepListener {
    default void beforeRead() { }
    default void afterRead(T item) { }
    default void onReadError(Exception ex) { }
}

public interface ItemProcessListener<T, S> extends StepListener {
    default void beforeProcess(T item) { }
    default void afterProcess(T item, @Nullable S result) { }
    default void onProcessError(T item, Exception e) { }
}

public interface ItemWriteListener<S> extends StepListener {
    default void beforeWrite(Chunk<? extends S> items) { }
    default void afterWrite(Chunk<? extends S> items) { }
    default void onWriteError(Exception exception, Chunk<? extends S> items) { }
}
```

- `ItemReadListener.afterRead()`
  - `ItemReader.read` 호출 후에 호출되지만 `read`가 `null`을 반환하면 호출되지 않는다.
- `ItemProcessListener.afterProcess()`
  - 이 경우읜 `process` 메서드가 `null`을 반환하더라도 호출된다.
- `ItemWriteListener.afterWrite()`
  - `ChunkListener.afterChunk()`가 청크 커밋 후 호출되었다면 아이템 리스너는 커밋 전에 호출된다.

## 배치 리스너, 이런 것들을 할 수 있다.

- 단계별 모니터링과 추적
  - ex) `Job`, `Step` 전후로 로깅
- 실행 결과에 따른 후속 처리
  - ex) `Job` 종료 상태를 확인하고 종료 상태에 따른 처리 가능
- 데이터 가공과 전달
  - ex) Step 간 데이터를 전달하거나 미리 처리에 필요한 정보를 준비 가능
- 부가 기능 분리
  - ex) 오류 발생 시 관리자에게 알림 메일을 보내는 등의 처리 가능

## 배치 리스너 구현 방법

### 인터페이스 구현

- 기본적으론 인터페이스를 직접 구현해서 커스텀 리스너 클래스를 만들 수 있다.

```kotlin
@Component
class BigBrotherJobExecutionListener : JobExecutionListener {
    override fun beforeJob(jobExecution: JobExecution) {
        // ...
    }

    override fun afterJob(jobExecution: JobExecution) {
        // ...
    }
}

@Component
class BigBrotherStepExecutionListener : StepExecutionListener {
    override fun beforeStep(stepExecution: StepExecution) {
        // ...
    }

    override fun afterStep(stepExecution: StepExecution): ExitStatus {
        // ...
        return ExitStatus.COMPLETED
    }
}
```

- 각 메서드들은 모두 `default` 메서드이기에 필요한 메서드만 오버라이드하면 된다.
- `JobBuilder`, `StepBuilder` 체이닝에 리스너를 등록할 수 있다.

```kotlin
    @Bean
    fun systemTerminationSimulationJob(): Job =
        JobBuilder("systemTerminationSimulationJob", jobRepository)
            .listener(BigBrotherJobExecutionListener())
            .start(enterWorldStep())
            .build()
```

### 어노테이션 기반 구현

- Spring Batch가 제공하는 어노테이션으로 리스너를 더 간단하게 구현할 수 있다.
  - 각 어노테이션은 인터페이스에 정의된 메서드와 동일한 이름이다.
  - `@AfterChunk`, `@AfterChunkError`, `@AfterJob`, `@AfterProcess`, `@AfterRead`, `@AfterStep`, `@AfterWrite`, `@BeforeChunk`, `@BeforeJob`, `@BeforeProcess`, `@BeforeRead`, `@BeforeStep`, `@BeforeWrite`, `@OnProcessError`, `@OnReadError`, `@OnSkipInProcess`, `@OnSkipInRead`, `@OnSkipInWrite`

```kotlin
@Component
class ServerRoomInfiltrationListener {
    @BeforeJob
    fun infiltrateServerRoom(jobExecution: JobExecution?) {
        // ...
    }

    @AfterJob
    fun escapeServerRoom(jobExecution: JobExecution) {
        // ...
    }
}

@Component
class ServerRackControlListener {
    @BeforeStep
    fun accessServerRack(stepExecution: StepExecution?) {
        // ...
    }

    @AfterStep
    fun leaveServerRack(stepExecution: StepExecution?): ExitStatus {
        // ...
        return ExitStatus("POWER_DOWN")
    }
}
```

- `@AfterStep` 어노테이션을 사용하는 메서드는 반드시 `ExitStatus`를 반환해줘야 한다.
- 어노테이션 기반 리스너도 빌더 체이닝에 포함시킬 수 있다.
  - `XxxBuilder.listener()` 메서드는 `Object` 타입을 받는 오버로딩 메서드를 제공하기 때문

## JobExecutionListener와 ExecutionContext를 활용한동적 데이터 전달

- 잡 파라미터로 전달할 수 없는 동적 데이터가 필요한 경우 `beforeJob` 메서드를 활용할 수 있다.

```kotlin
@Component
class InfiltrationPlanListener : JobExecutionListener {
    override fun beforeJob(jobExecution: JobExecution) {
        val executionContext: ExecutionContext = jobExecution.executionContext

        val infiltrationPlan: Map<String, String> = generateInfiltrationPlan()
        executionContext.put("infiltrationPlan", infiltrationPlan) // 동적 파라미터 전달
    }

    private fun generateInfiltrationPlan(): Map<String, String> =
        mapOf(
            "targetSystem" to listOf("판교 서버실", "안산 데이터센터").random(),
            "objective" to listOf("kill -9 실행", "rm -rf 전개", "chmod 000 적용", "/dev/null로 리다이렉션").random(),
            "targetData" to listOf("코어 덤프 파일", "시스템 로그", "설정 파일", "백업 데이터").random(),
            "requiredTools" to listOf("USB 킬러", "널 바이트 인젝터", "커널 패닉 유발기", "메모리 시퍼너").random(),
        )
}
```

- `Job` 수준 `ExecutionContext` 내부 데이터는 `Job` 내부 모든 `Step`에서 접근 가능하다는 점을 이용하는 것이다.

```kotlin
    @Bean
    fun systemInfiltrationJob(
        jobRepository: JobRepository,
        reconStep: Step,
        attackStep: Step,
    ): Job =
        JobBuilder("systemInfiltrationJob", jobRepository)
            .listener(infiltrationPlanListener) // listener 등록
            .start(reconStep)
            .next(attackStep)
            .build()
```

- 이제 해당 `Job` 내부 `Step`에서 잡 파라미터로 전달 받는 것이 가능하다.
  - `Job` 수준 `ExecutionContext`에 저장되어 있기 때문

```kotlin
    @Bean
    @StepScope
    fun attackStepTasklet(
        @Value("#{jobExecutionContext['infiltrationPlan']}") infiltrationPlan: Map<String, Any>,
    ): Tasklet =
        Tasklet { contribution: StepContribution, _: ChunkContext ->
            val infiltrationSuccess = Random.nextBoolean()
            val infiltrationResult = if (infiltrationSuccess) "TERMINATED" else "DETECTED"
            
            val executionContext: ExecutionContext = contribution.stepExecution.jobExecution.executionContext
            executionContext.put("infiltrationResult", infiltrationResult)

            RepeatStatus.FINISHED
        }
```
