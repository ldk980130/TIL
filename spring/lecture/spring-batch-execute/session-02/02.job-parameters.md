# 잡 파라미터와 스프링 배치 Scope

- `JobParameters`는 배치 작업에 전달되는 입력 값이다.
    - 어떤 조건에서, 어떤 데이터를 다룰 것인가
    - ex) 매일 실행되는 배치의 경우 날짜나 실행 경로 등 매번 바뀐다.
- 즉 `JobParameters`는 배치 잡을 동적이고 유연하게 만들어 준다.

## 프로퍼티와 JobParameters 차이

- -D 옵션 으로 실행 시 파라미터를 주입할 수도 있지만 `JobParameters`와 그 목적이 다르다.

### 입력값 동적 변경

- -D 옵션 프로퍼티는 앱 시작 시 주입되는 정적인 값이다.
- `JobParameters`로는 웹 요청이 들어올 때마다 비동기 배치로 매번 다른 파라미터를 동적으로 전달할 수 있다.

### 메타데이터

- 스프링 배치에선 JobParameters의 모든 값을 메타데이터 저장소에 기록한다.
- 이를 통해 다음을 제공한다.
    - `Job` 인스턴스 식별 및 재시작 처리
    - `Job` 실행 이력 추적

## JobParameters 전달하기

- 실제 운영 환경에선 커맨드 라인을 통해 파라미터를 전달하는 방식이 핵심이다.
    - 젠킨스와 같은 CI/CD 도구 등 대부분 스케줄러 도그는 커맨드라인 실행을 기본으로 지원
    - ex) `./gradlew bootRun --args='--spring.batch.job.name=dataProcessingJob inputFilePath=/data/input/users.csv,java.lang.String’`
    - `—spring.batch.job.name`은 `Job`의 이름을 지정, 그 뒤의 key, value들이 실제 `JobParameters`다.

### JobParameters 기본 표기법

```bash
parameterName=parameterValue,parameterType,identificationFlag
```

- `parameterName`: Job에서 파라미터를 찾을 때 사용하는 key 값
- `parameterValue`: 파라미터의 실제 값
- `parameterType`: 파라미터의 타입으로 명시하지 않으면 `String`으로 가정한다.
    - `java.lang.String`와 같은 fully qualified name 사용
    - 스프링 배치의 `DefaultJobParametersConverter` 컴포넌트를 통해 적절한 타입으로 변환된다.
- `indentificationFlag`: 스프링 배치에게 해당 파라미터가 `JobInstance` 식별에 사용되는지 여부를 전달
    - 생략 가능하며 생략하면 `true`로 설정된다.

## 다양한 타입의 Job 파라미터

### 기본 데이터 타입 파라미터 전달

```kotlin
    @Bean
    @StepScope
    fun terminatorTasklet(
        @Value("#{jobParameters['terminatorId']}") terminatorId: String,
        @Value("#{jobParameters['targetCount']}") targetCount: Int,
    ): Tasklet =
        Tasklet { _: StepContribution, _: ChunkContext ->
            // ...
            RepeatStatus.FINISHED
        }
```

- `@Value` 애노테이션과 `#{jobParameters['parameterName']}` 표현식으로 `JobParameters`를 주입 받을 수 있다.
- 그리고 아래 명령어로 위 태스크에 파라미터를 전달하며 실행시킬 수 있다.
  - `./gradlew bootRun --args='--spring.batch.job.name=processTerminatorJob terminatorId=KILL-9,java.lang.String targetCount=5,java.lang.Integer’`
- `@StepScope` - `@Value`를 통해 잡 파라미터를 주입 받기 위해 필요

### 열거형 파라미터 전달

- 열거형(`Enum`)을 `JobParameters`로 사용할 수 있다.

```kotlin
    @Bean
    @StepScope
    fun terminatorTaskletEnum(
        @Value("#{jobParameters['questDifficulty']}") questDifficulty: QuestDifficulty,
    ): Tasklet =
        Tasklet { contribution: StepContribution, chunkContext: ChunkContext ->
            // ...
            val rewardMultiplier =
                when (questDifficulty) {
                    QuestDifficulty.EASY -> 1
                    QuestDifficulty.NORMAL -> 2
                    QuestDifficulty.HARD -> 3
                    QuestDifficulty.EXTREME -> 5
                }
            // ...
            RepeatStatus.FINISHED
        }

    enum class QuestDifficulty { EASY, NORMAL, HARD, EXTREME }
```

- `Enum` 파라미터 전달을 위한 커맨드 라인은 아래와 같다.
  - `./gradlew bootRun --args='--spring.batch.job.name=processTerminatorJob questDifficulty=HARD,com.system.batch.JobParametersConfig$QuestDifficulty’`
  - `Enum` 클래스가 `JobParametersConfig` 클래스의 내부 클래스로 선언되어 있기에 `JobParametersConfig$QuestDifficulty`로 명시해야 한다.

### POJO를 활용한 Job 파라미터 주입

- 대규모 배치 작업에선 여러 파라미터를 효율적으로 관리해야 할 때 별도 클래스로 파라미터를 관리할 수 있다.

```kotlin
@Component
@StepScope
class PojoParameters(
    @Value("#{jobParameters[missionName]}")
    private val missionName: String,
    @Value("#{jobParameters[securityLevel]}")
    private val securityLevel: Int,
    @Value("#{jobParameters[operationCommander]}")
    private val operationCommander: String,
)
```

- 마찬가지로 `@Value` 어노테이션으로 파라미터를 주입받을 수 있고 다음을 지원한다.
  - 필드 직접 부입
  - 생성자 파라미터 주입
  - 세터 메서드 주입

```kotlin
    @Bean
    fun terminatorParamTasklet(params: PojoParameters): Tasklet =
        Tasklet { _: StepContribution, _: ChunkContext ->
            // ...
            RepeatStatus.FINISHED
        }
```

- Pojo 파라미터를 전달하는 방법은 기존과 똑같다.
  - `./gradlew bootRun --args='--spring.batch.job.name=processTerminatorJob missionName=안산_데이터센터_침투,java.lang.String operationCommander=KILL-9 securityLevel=3,java.lang.Integer,false’`

### 기본 파라미터 표기법의 한계

- 파라미터 값에 아래처럼 쉼표(,)가 포함된다면?
  - `infiltrationTargets=판교_서버실,안산_데이터센터,java.lang.String`
  - Spring Batch는 파라미터 타입을 ‘안산_데이터센터’로 오해버리는 한계가 있다.
- 이를 보완하기 위해 Spring Batch 5부터 JSON 기반 표기법을 새로 제공한다.

### JobParameter의 JSON 기반 표기법

- Json 표기법은 다음과 같다.
  - `infiltrationTargets='{"value": "판교_서버실,안산_데이터센터", "type": "java.lang.String"}’`
- 표기법 구성 요소(`value`, `type`, `identifying`)들은 기본 표기법과 동일한 의미를 가진다.

```kotlin
    @Bean
    @StepScope
    fun terminatorTaskletJson(
        @Value("#{jobParameters['infiltrationTargets']}") infiltrationTargets: String,
    ): Tasklet =
        Tasklet { _: StepContribution, _: ChunkContext ->
            val targets: Array<String?> =
                infiltrationTargets.split(",".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()
            // ...
            log.info { "첫 번째 타겟: ${targets[0]} 침투 시작" }
            log.info { "마지막 타겟: ${targets[1]} 에서 집결" }
            // ...
            RepeatStatus.FINISHED
        }
```

### Json 표기법 사용을 위한 준비

- 의존성 추가
  - `implementation 'org.springframework.boot:spring-boot-starter-json’`
- `JsonJobParametersConverter` 빈 등록
  - `@Bean *fun* jobParametersConverter(): *JobParametersConverter* = JsonJobParametersConverter()`
- 그리고 아래 명령어를 통해 job을 실행할 수 있다.
  - `./gradlew bootRun --args="--spring.batch.job.name=terminatorJob infiltrationTargets='{\"value\":\"판교서버실,안산데이터센터\",\"type\":\"java.lang.String\"}'”`

### 커맨드 라인 파라미터가 실제 Job으로 전달되는 과정

- `JobLauncherApplicationRunner`
  - Spring Boot3에서 Spring Batch를 실행하면 동작하는 `ApplicationRunner`의 한 종류
  - 커맨드라인으로 전달된 잡 파라미터를 해석하고 실제 `Job`을 실행하는 역할을 맡는다.
- `JobLauncherApplicationRunner` 처리 과정
  - 처리 목록 준비 - `ApplicationContext`에 등록된 모든 `Job` 타입 빈이 `JobLauncherApplicationRunner`에 자동 주입
  - 유효성 검증 (주로 `--spring.batch.job.name` 검증)
    - 만약 `Job`이 여러 개인데 이름을 지정하지 않은 경우 검증 실패 (`Job`이 하나면 허용)
    - 커맨드라인에서 전달한 `Job` 이름을 찾을 수 없으면 검증 실패
  - 명령어 해석 - 커맨드라인으로 전달된 값들을 파싱
  - `Job` 실행 - `Job` 이름에 따라 `Job`을 찾고 파라미터를 전달해 실행한다. (`JobLauncher` 사용)
    - `this.jobLauncher.run(job, parameters)`

### 프로그래밍 방식으로 JobParameters 생성/전달

- 실무에선 커맨드라인 외에 다양한 방식으로 배치를 실행할 때가 있다.
  - REST API를 통해 배치 작업을 트리거
  - 메시지 큐에서 메시지가 도착했을 때
  - 특정 비즈니스 이벤트가 발생했을 때
  - `@Scheduled` 태스크에서 동적 파라미터와 함께 실행할 때
