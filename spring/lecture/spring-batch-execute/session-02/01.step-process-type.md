# 스프링 배치의 두 가지 스텝 유형

- Spring Batch의 Step은 크게 두 가지 처리 모델로 나뉜다.
    - 청크 지향 처리 (Chunk-Oriented Processing)
    - 태스크릿 지향 처리 (Tasklet-Oriented Processing)

## 태스크릿(Tasklet) 지향 처리란

- Spring Batch에서의 기본적인 Step 구현 방식
- 비교적 단순한 작업 실행에 사용된다.
    - 단일 비즈니스 로직에 초점을 맞춘 작업들
    - ex) 매일 새벽 불필요한 로그 파일 삭제
    - ex) 외부 API 호출 후 결과를 단순히 저장하거나 로깅
- 이러한 작업들은 대부분 함수 호출 하나로 끝날 단순한 작업들이다.

```java
@FunctionalInterface
public interface Tasklet {
    @Nullable
    RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception;
}
```

### Tasklet 구현 예시

```kotlin
private const val PROCESSED_TO_KILL: Int = 10
private var killedProcess: Int = 0

class ZombieProcessCleanupTasklet : Tasklet {
    val log: KLogger = KotlinLogging.logger {}

    override fun execute(
        contribution: StepContribution,
        chunkContext: ChunkContext,
    ): RepeatStatus {
        killedProcess += 1

        log.info { "☠️  프로세스 강제 종료... ({$killedProcess}/{$PROCESSED_TO_KILL})" }

        if (killedProcess >= PROCESSED_TO_KILL) {
            log.info { "💀 시스템 안정화 완료. 모든 좀비 프로세스 제거." }
            return RepeatStatus.FINISHED; // 모든 프로세스 종료 후 작업 완료
        }

        return RepeatStatus.CONTINUABLE; // 아직 더 종료할 프로세스가 남아있음
    }
}
```

- `Tasklet`의 `execute` 메서드는 메서드 실행을 계속 할지 `RepeatStatus`를 통해 결정한다.

### **RepeatStatus**: FINISHED vs CONTINUALBE

- `ReapeatStatus.FINISHED`
    - `Step` 처리가 완료되었음을 의미
    - `Step` 처리가 성공이든 실패든 상관 없다.
    - 다음 Step으로 진행된다.
- `RepeatStatus.CONTINUABLE`
    - `execute` 메서드가 추가로 실행되어야 함을 의미
    - Step 종료가 보류되고 필요한 만큼 `execute`가 반복 호출된다.

### RepeatStatus가 필요한 이유

- 짧은 트랜잭션을 활용한 안전 배치 처리
    - Spring Batch는 `Tasklet`의 `execute` 실행마다 새 트랜잭션을 실행한다.
    - `RepeatStauts`가 반환되면 해당 트랜잭션을 커밋한다.
- `while`문을 사용하지 않고 `Tasklet`과 `RepeatStatus.CONTINUABLE` 덕에 대량의 데이터 처리 도중 중간 실패가 발생해도 지금까지의 데이터는 안전하다.

### Tasklet을 Step으로 등록하는 방법

```kotlin
@Configuration
class ZombieBatchConfig(
    private val jobRepository: JobRepository,
    private val transactionManager: PlatformTransactionManager
) {
    @Bean
    fun zombieProcessCleanupTasklet(): Tasklet {
        return ZombieProcessCleanupTasklet()
    }

    @Bean
    fun zombieCleanupStep(): Step {
        return StepBuilder("zombieCleanupStep", jobRepository) // Tasklet과 transactionManager 설정
            .tasklet(zombieProcessCleanupTasklet(), transactionManager)
            .build()
    }

    @Bean
    fun zombieCleanupJob(): Job {
        return JobBuilder("zombieCleanupJob", jobRepository)
            .start(zombieCleanupStep()) // Step 등록
            .build()
    }
}
```

- 예제 코드를 보면 `tasklet` 외에도 `PlatformTransactionManager`가 전달된다.
    - 트랜잭션 작업을 위해 필요
    - 만약 트랜잭션이 필요 없는 작업이라면 `ResourcelessTransactionManager`를 고려해볼 수 있다.

```kotlin
    @Bean
    fun zombieCleanupStep(): Step =
        StepBuilder("zombieCleanupStep", jobRepository)
            .tasklet(zombieProcessCleanupTasklet(), ResourcelessTransactionManager())
            .build()
```

### Tasklet 람다

- 간단한 작업이라면 `Tasklet` 등록 시 람다를 통해 간단히 할 수 있다.

```kotlin
    @Bean
    fun deleteOldRecordsStep(): Step =
        StepBuilder("deleteOldRecordsStep", jobRepository)
            .tasklet(
                Tasklet { contribution: StepContribution, chunkContext: ChunkContext ->
                    // ...
                    RepeatStatus.FINISHED
                },
                transactionManager,
            ).build()
```

## 청크 지향 처리

- 특히 데이터를 다루는 작업은 읽기 → 처리 → 쓰기 패턴을 가진다.
- 이 방식을 Spring Batch에선 청크 지향 처리라고 부른다.

### Chunk

- 청크 (Chunk)
  - 데이터를 일정 단위로 쪼갠 덩어리
- Spring Batch에서의 청크 지향 처리
  - 읽기 → 처리 → 쓰기 작업을 일정 크기로 나눈 덩어리를 대상으로 작업을 진행
  - ex) 100만 건 데이터를 100건씩 청크 단위로 처리하면 읽기 → 처리 → 쓰기 작업이 만 번 반복된다.

### 청크 기반 처리를 하는 이유

- 메모리
  - 만약 수백/수천만 건의 데이터를 한 번에 처리하려고 하면 메모리와 DB 과부하로 시스템이 멈출 것이다.
- 가벼운 트랜잭션
  - 100만 건을 한 트랜잭션으로 처리한다면 중간 실패로 전체가 롤백되어 버린다.
  - 청크 단위로 나누면 복구가 쉽고 빠르다. (작은 실패로 제한)

### ItemReader

- `ItemReader`는 데이터를 읽어오는 역할을 한다.

```java
public interface ItemReader<T> {
    T read() throws Exception, 
        UnexpectedInputException, 
        ParseException, 
        NonTransientResourceException;
}
```

- 한 번에 하나씩
  - `read()` 메서드는 아이템 하나를 반환한다. (DB의 한 row)
  - 더 이상 읽을 레코드가 없다다 `null`을 반환하며 스텝은 종료된다.
  - `ItemReader`의 `null` 반환이 처크 지향 처리 `Step`의 종료 시점인 것
- 다양한 구현체 제공
  - 파일, DB, 메시지 큐 등 다양한 데이터 소스에 대한 표준 구현체를 제공한다.
  - ex) `FlatFileItemReader`, `JdbcCursorItemReader`

### ItemProcessor

- `ItemProcessor`는 데이터를 가공하고 다듬는 역할을 한다.

```java
public interface ItemProcessor<I, O> {
    O process(I item) throws Exception;
}
```

- 데이터 가공
  - 입력 데이터(I)를 원하는 형태(O)로 변환한다.
- 필터링: null 반환
  - 해당 데이터는 처리 흐름에서 제외되어 `ItemWriter`에 전달되지 않는다.
- 데이터 검증
  - 필터링과 달리 조건에 맞지 않는 데이터를 만나면 예외를 발생시킨다.
  - 잘못된 데이터를 발견했을 대 배치 잡을 중단시킬 수 있다.
- 필수는 아님
  - 바로 데이터를 읽고 쓰도록 생략 가능하다.

### ItemWriter

- 원하는 방식으로 데이터를 최종 저장/출력한다.

```java
public interface ItemWriter<T> {
    void write(Chunk<? extends T> chunk) throws Exception;
}
```

- 한 덩어리씩 쓴다.
  - `ItemWriter`는 데이터를 `Chunk` 단위로 묶어서 한 번에 쓴다.
  - `Chunk` 타입을 파라미터로 받음
- 다양한 구현체 제공
  - 파일, DB, 외부 시스템 전송 등에 사용 가능한 다양한 구션체를 제공한다.
  - ex) `FlatFileItemWriter`, `JdbcBatchItemWriter`

> 이러한 구조를 통해 각 컴포넌트는 자신의 역할만 수행하며 완벽한 책임 분리, 재사용성 극대화, 높은 유연성을 제공하여 대용량 처리의 표준이 되었다.
>

### 청크 지향 처리 조립하기

- 다음은 간단히 Step을 조립해 청크를 처리를 구현해본 코드 예제다.
  - 청크 지향 처리는 `chunk()` 메서드를 호출하는 것으로 시작된다.

```kotlin
@Bean
fun processStep(
    jobRepository: JobRepository,
    transactionManager: PlatformTransactionManager
): Step {
    return StepBuilder("processStep", jobRepository)
        .chunk<CustomerDetail, CustomerSummary>(10, transactionManager) // 청크 지향 처리 활성화
        .reader(itemReader())   // 데이터 읽기 담당
        .processor(itemProcessor())  // 데이터 처리 담당
        .writer(itemWriter())   // 데이터 쓰기 담당
        .build()
}

@Bean
fun customerProcessingJob(
    jobRepository: JobRepository,
    processStep: Step
): Job {
    return JobBuilder("customerProcessingJob", jobRepository)
        .start(processStep)    // processStep으로 Job 시작
        .build()
}
```

- 청크 사이즈 지정
  - `.chunk(10, transactionManager)`
  - 청크 크기를 지정하는데 이는 데이터를 n개씩 묶어 처리하겠다는 의미다.
  - `ItemReader`가 데이터를 n개만큼 읽어 `ItemProcessor`나 `ItemWriter`에 전달한다.
- 제네릭 타입으로 데이터 흐름 정의
  - `.<CustomerDetail, CustomerSummary>chunk(..)`
  - 첫 번째 타입: `ItemReader`가 반환할 타입
  - 두 번째 타입: `ItemProcessor`가 아이템을 처리 후 반환할 타입이자 `ItemWriter`가 전달 받을 타입

### 청크 지향 처리 흐름

1. 데이터 읽기 (`ItemReader`)
   2. `read()` 메서드로 순차적으로 데이터를 반환한다. 
   3. 청크 크기만큼 `read()`가 호출되어 하나의 청크가 생성된다.
2. 데이터 깎기 (`ItemProcessor`)
   3. `process()` 메서드는 청크 전체를 받지 않고 하나씩 처리한다. 
   4. 즉 청크 크기만큼 `process()`가 호출된다.
3. 데이터 쓰기 (`ItemWriter`)
   4. 청크 단위로 데이터를 저장한다. 
   5. 읽기/가공 단계와 달리 청크 전체를 한 번에 처리한다.

- 청크 지향 처리에선 위 과정을 반복하다 `ItemReader`에서 `null`이 반환되면 청크 단위 반복을 종료한다.

### 청크 처리와 트랜잭션

- 태스크릿에선 `execute()` 메서드가 트랜잭션 단위였다.
- 청크 지향에선 청크 단위로 트랜잭션이 관리된다.
  - 덕분에 대용량 데이터 처리 도중 실패하더라도 이전 청크 반복은 이미 커밋되어 보존된다.

### 적절한 청크 사이즈란?

- 업무 요구사항, 데이터 양을 고려해 적절히 선택해야 한다.
- 청크 사이즈가 클 때
  - 메모리에 많은 데이터를 한 번에 로드하게 된다.
  - 문제 발생 시 롤백되는 데이터가 많아진다.
- 청크 사이즈가 작을 때
  - 트랜잭션 경계가 작아져 롤백되는 데이터가 최소화된다.
  - 대신 그만큼 I/O가 자주 발생하여 지연이 발생할 수 있다.
