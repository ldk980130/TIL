# 스프링 배치의 두 가지 스텝 유형

- Spring Batch의 Step은 크게 두 가지 처리 모델로 나뉜다.
    - 청크 지향 처리 (Chunk-Oriented Processing)
    - 태스크릿 지향 처리 (Tasklet-Oriented Processing)

## 태스크릿(Tasklet) 지향 처리란

- Spring Batch에서의 기본적인 Step 구현 방식
- 비교적 단순한 작업 실행에 사용된다.
    - 단일 비즈니스 로직에 초점을 맞춘 작업들
    - ex) 매일 새벽 불필요한 로그 파일 삭제
    - ex) 외부 API 호출 후 결과를 단순히 저장하거나 로깅
- 이러한 작업들은 대부분 함수 호출 하나로 끝날 단순한 작업들이다.

```java
@FunctionalInterface
public interface Tasklet {
    @Nullable
    RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception;
}
```

### Tasklet 구현 예시

```kotlin
private const val PROCESSED_TO_KILL: Int = 10
private var killedProcess: Int = 0

class ZombieProcessCleanupTasklet : Tasklet {
    val log: KLogger = KotlinLogging.logger {}

    override fun execute(
        contribution: StepContribution,
        chunkContext: ChunkContext,
    ): RepeatStatus {
        killedProcess += 1

        log.info { "☠️  프로세스 강제 종료... ({$killedProcess}/{$PROCESSED_TO_KILL})" }

        if (killedProcess >= PROCESSED_TO_KILL) {
            log.info { "💀 시스템 안정화 완료. 모든 좀비 프로세스 제거." }
            return RepeatStatus.FINISHED; // 모든 프로세스 종료 후 작업 완료
        }

        return RepeatStatus.CONTINUABLE; // 아직 더 종료할 프로세스가 남아있음
    }
}
```

- `Tasklet`의 `execute` 메서드는 메서드 실행을 계속 할지 `RepeatStatus`를 통해 결정한다.

### **RepeatStatus**: FINISHED vs CONTINUALBE

- `ReapeatStatus.FINISHED`
    - `Step` 처리가 완료되었음을 의미
    - `Step` 처리가 성공이든 실패든 상관 없다.
    - 다음 Step으로 진행된다.
- `RepeatStatus.CONTINUABLE`
    - `execute` 메서드가 추가로 실행되어야 함을 의미
    - Step 종료가 보류되고 필요한 만큼 `execute`가 반복 호출된다.

### RepeatStatus가 필요한 이유

- 짧은 트랜잭션을 활용한 안전 배치 처리
    - Spring Batch는 `Tasklet`의 `execute` 실행마다 새 트랜잭션을 실행한다.
    - `RepeatStauts`가 반환되면 해당 트랜잭션을 커밋한다.
- `while`문을 사용하지 않고 `Tasklet`과 `RepeatStatus.CONTINUABLE` 덕에 대량의 데이터 처리 도중 중간 실패가 발생해도 지금까지의 데이터는 안전하다.

### Tasklet을 Step으로 등록하는 방법

```kotlin
@Configuration
class ZombieBatchConfig(
    private val jobRepository: JobRepository,
    private val transactionManager: PlatformTransactionManager
) {
    @Bean
    fun zombieProcessCleanupTasklet(): Tasklet {
        return ZombieProcessCleanupTasklet()
    }

    @Bean
    fun zombieCleanupStep(): Step {
        return StepBuilder("zombieCleanupStep", jobRepository) // Tasklet과 transactionManager 설정
            .tasklet(zombieProcessCleanupTasklet(), transactionManager)
            .build()
    }

    @Bean
    fun zombieCleanupJob(): Job {
        return JobBuilder("zombieCleanupJob", jobRepository)
            .start(zombieCleanupStep()) // Step 등록
            .build()
    }
}
```

- 예제 코드를 보면 `tasklet` 외에도 `PlatformTransactionManager`가 전달된다.
    - 트랜잭션 작업을 위해 필요
    - 만약 트랜잭션이 필요 없는 작업이라면 `ResourcelessTransactionManager`를 고려해볼 수 있다.

```kotlin
    @Bean
    fun zombieCleanupStep(): Step =
        StepBuilder("zombieCleanupStep", jobRepository)
            .tasklet(zombieProcessCleanupTasklet(), ResourcelessTransactionManager())
            .build()
```

### Tasklet 람다

- 간단한 작업이라면 `Tasklet` 등록 시 람다를 통해 간단히 할 수 있다.

```kotlin
    @Bean
    fun deleteOldRecordsStep(): Step =
        StepBuilder("deleteOldRecordsStep", jobRepository)
            .tasklet(
                Tasklet { contribution: StepContribution, chunkContext: ChunkContext ->
                    // ...
                    RepeatStatus.FINISHED
                },
                transactionManager,
            ).build()
```
