# 스프링 배치의 두 가지 스텝 유형

- Spring Batch의 Step은 크게 두 가지 처리 모델로 나뉜다.
    - 청크 지향 처리 (Chunk-Oriented Processing)
    - 태스크릿 지향 처리 (Tasklet-Oriented Processing)

## 태스크릿(Tasklet) 지향 처리란

- Spring Batch에서의 기본적인 Step 구현 방식
- 비교적 단순한 작업 실행에 사용된다.
    - 단일 비즈니스 로직에 초점을 맞춘 작업들
    - ex) 매일 새벽 불필요한 로그 파일 삭제
    - ex) 외부 API 호출 후 결과를 단순히 저장하거나 로깅
- 이러한 작업들은 대부분 함수 호출 하나로 끝날 단순한 작업들이다.

```java
@FunctionalInterface
public interface Tasklet {
    @Nullable
    RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception;
}
```

### Tasklet 구현 예시

```kotlin
private const val PROCESSED_TO_KILL: Int = 10
private var killedProcess: Int = 0

class ZombieProcessCleanupTasklet : Tasklet {
    val log: KLogger = KotlinLogging.logger {}

    override fun execute(
        contribution: StepContribution,
        chunkContext: ChunkContext,
    ): RepeatStatus {
        killedProcess += 1

        log.info { "☠️  프로세스 강제 종료... ({$killedProcess}/{$PROCESSED_TO_KILL})" }

        if (killedProcess >= PROCESSED_TO_KILL) {
            log.info { "💀 시스템 안정화 완료. 모든 좀비 프로세스 제거." }
            return RepeatStatus.FINISHED; // 모든 프로세스 종료 후 작업 완료
        }

        return RepeatStatus.CONTINUABLE; // 아직 더 종료할 프로세스가 남아있음
    }
}
```

- `Tasklet`의 `execute` 메서드는 메서드 실행을 계속 할지 `RepeatStatus`를 통해 결정한다.

### **RepeatStatus**: FINISHED vs CONTINUALBE

- `ReapeatStatus.FINISHED`
    - `Step` 처리가 완료되었음을 의미
    - `Step` 처리가 성공이든 실패든 상관 없다.
    - 다음 Step으로 진행된다.
- `RepeatStatus.CONTINUABLE`
    - `execute` 메서드가 추가로 실행되어야 함을 의미
    - Step 종료가 보류되고 필요한 만큼 `execute`가 반복 호출된다.

### RepeatStatus가 필요한 이유

- 짧은 트랜잭션을 활용한 안전 배치 처리
    - Spring Batch는 `Tasklet`의 `execute` 실행마다 새 트랜잭션을 실행한다.
    - `RepeatStauts`가 반환되면 해당 트랜잭션을 커밋한다.
- `while`문을 사용하지 않고 `Tasklet`과 `RepeatStatus.CONTINUABLE` 덕에 대량의 데이터 처리 도중 중간 실패가 발생해도 지금까지의 데이터는 안전하다.

### Tasklet을 Step으로 등록하는 방법

```kotlin
@Configuration
class ZombieBatchConfig(
    private val jobRepository: JobRepository,
    private val transactionManager: PlatformTransactionManager
) {
    @Bean
    fun zombieProcessCleanupTasklet(): Tasklet {
        return ZombieProcessCleanupTasklet()
    }

    @Bean
    fun zombieCleanupStep(): Step {
        return StepBuilder("zombieCleanupStep", jobRepository) // Tasklet과 transactionManager 설정
            .tasklet(zombieProcessCleanupTasklet(), transactionManager)
            .build()
    }

    @Bean
    fun zombieCleanupJob(): Job {
        return JobBuilder("zombieCleanupJob", jobRepository)
            .start(zombieCleanupStep()) // Step 등록
            .build()
    }
}
```

- 예제 코드를 보면 `tasklet` 외에도 `PlatformTransactionManager`가 전달된다.
    - 트랜잭션 작업을 위해 필요
    - 만약 트랜잭션이 필요 없는 작업이라면 `ResourcelessTransactionManager`를 고려해볼 수 있다.

```kotlin
    @Bean
    fun zombieCleanupStep(): Step =
        StepBuilder("zombieCleanupStep", jobRepository)
            .tasklet(zombieProcessCleanupTasklet(), ResourcelessTransactionManager())
            .build()
```

### Tasklet 람다

- 간단한 작업이라면 `Tasklet` 등록 시 람다를 통해 간단히 할 수 있다.

```kotlin
    @Bean
    fun deleteOldRecordsStep(): Step =
        StepBuilder("deleteOldRecordsStep", jobRepository)
            .tasklet(
                Tasklet { contribution: StepContribution, chunkContext: ChunkContext ->
                    // ...
                    RepeatStatus.FINISHED
                },
                transactionManager,
            ).build()
```

## 청크 지향 처리

- 특히 데이터를 다루는 작업은 읽기 → 처리 → 쓰기 패턴을 가진다.
- 이 방식을 Spring Batch에선 청크 지향 처리라고 부른다.

### Chunk

- 청크 (Chunk)
  - 데이터를 일정 단위로 쪼갠 덩어리
- Spring Batch에서의 청크 지향 처리
  - 읽기 → 처리 → 쓰기 작업을 일정 크기로 나눈 덩어리를 대상으로 작업을 진행
  - ex) 100만 건 데이터를 100건씩 청크 단위로 처리하면 읽기 → 처리 → 쓰기 작업이 만 번 반복된다.

### 청크 기반 처리를 하는 이유

- 메모리
  - 만약 수백/수천만 건의 데이터를 한 번에 처리하려고 하면 메모리와 DB 과부하로 시스템이 멈출 것이다.
- 가벼운 트랜잭션
  - 100만 건을 한 트랜잭션으로 처리한다면 중간 실패로 전체가 롤백되어 버린다.
  - 청크 단위로 나누면 복구가 쉽고 빠르다. (작은 실패로 제한)

### ItemReader

- `ItemReader`는 데이터를 읽어오는 역할을 한다.

```java
public interface ItemReader<T> {
    T read() throws Exception, 
        UnexpectedInputException, 
        ParseException, 
        NonTransientResourceException;
}
```

- 한 번에 하나씩
  - `read()` 메서드는 아이템 하나를 반환한다. (DB의 한 row)
  - 더 이상 읽을 레코드가 없다다 `null`을 반환하며 스텝은 종료된다.
  - `ItemReader`의 `null` 반환이 처크 지향 처리 `Step`의 종료 시점인 것
- 다양한 구현체 제공
  - 파일, DB, 메시지 큐 등 다양한 데이터 소스에 대한 표준 구현체를 제공한다.
  - ex) `FlatFileItemReader`, `JdbcCursorItemReader`

### ItemProcessor

- `ItemProcessor`는 데이터를 가공하고 다듬는 역할을 한다.

```java
public interface ItemProcessor<I, O> {
    O process(I item) throws Exception;
}
```

- 데이터 가공
  - 입력 데이터(I)를 원하는 형태(O)로 변환한다.
- 필터링: null 반환
  - 해당 데이터는 처리 흐름에서 제외되어 `ItemWriter`에 전달되지 않는다.
- 데이터 검증
  - 필터링과 달리 조건에 맞지 않는 데이터를 만나면 예외를 발생시킨다.
  - 잘못된 데이터를 발견했을 대 배치 잡을 중단시킬 수 있다.
- 필수는 아님
  - 바로 데이터를 읽고 쓰도록 생략 가능하다.

### ItemWriter

- 원하는 방식으로 데이터를 최종 저장/출력한다.

```java
public interface ItemWriter<T> {
    void write(Chunk<? extends T> chunk) throws Exception;
}
```

- 한 덩어리씩 쓴다.
  - `ItemWriter`는 데이터를 `Chunk` 단위로 묶어서 한 번에 쓴다.
  - `Chunk` 타입을 파라미터로 받음
- 다양한 구현체 제공
  - 파일, DB, 외부 시스템 전송 등에 사용 가능한 다양한 구션체를 제공한다.
  - ex) `FlatFileItemWriter`, `JdbcBatchItemWriter`

> 이러한 구조를 통해 각 컴포넌트는 자신의 역할만 수행하며 완벽한 책임 분리, 재사용성 극대화, 높은 유연성을 제공하여 대용량 처리의 표준이 되었다.
>
