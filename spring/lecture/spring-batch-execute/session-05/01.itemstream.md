# ItemStream

- 앞서 다룬 `ItemReader`, `ItemWriter`들 중에선 실제 데이터 처리를 다른 컴포넌트에게 위임하는 것들이 있었다.
  - `MultiResourceItemReader`**,** `MultiResourceItemWriter`**,** `CompositeItemReader`**,** `CompositeItemWriter`
- 각 위임자 내부 코드엔 `delegate` 필드가 존재한다.

```java
// MultiResourceItemReader
private ResourceAwareItemReaderItemStream<? extends T> delegate;

// MultiResourceItemWriter
private ResourceAwareItemWriterItemStream<? super T> delegate;

// CompositeItemReader
private final List<ItemStreamReader<? extends T>> delegates;
```

- 위임 대상들은 모두 단순 `ItemReader`/`ItemWriter`가 아닌 `ItemStream`을 사용하고 있다.
- 실제로 Spring Batch 대부분의 구현체들은 `ItemStream` 인터페이스를 공통적으로 구현하고 있다.
  - 대부분의 `ItemReader`는 `ItemStream`
  - 하지만 `ItemWriter`의 경우 파일 기반 구현체를 제외하고는 대부분 `ItemStream`이 아니다.

```java
public interface ItemStream {
  default void open(ExecutionContext executionContext) throws ItemStreamException {}

  default void update(ExecutionContext executionContext) throws ItemStreamException {}

  default void close() throws ItemStreamException {}
}
```

- `ItemStream`은 다음 두 역할을 담당한다.
  - 자원 초기화 및 해제
  - 메타데이터 관리 및 상태 추적

## 자원 초기화 및 해제

- 자원 관리의 중요성
  - 배치 작업은 파일, db 커넥션, 메모리 버퍼 등 다양한 자원을 다룬다.
  - 이러한 자원들은 반드시 적절한 사전 준비와 사용 후 정리가 필요하다.
  - 자원을 적절히 해제하지 않으면 치명적 문제가 발생한다.
    - 파일 핸들 누수
    - db 커넥션 누수
    - 메모리 누수
- 이러한 자원 초기화와 해제는 `ItemStream`의 `open()`, `close()` 메서드를 통해 처리된다.
  - Spring Batch에선 스텝이 `open`, `close` 메서드를 호출한다.

### FlatFileItemReader.doOpen()

- 부모 클래스인 `AbstractItemCountingItemStreamItemReader`의 `open()` 메서드에서 `doOpen` 호출

```java
@Override
protected void doOpen() throws Exception {
  if (!resource.exists()) { // 읽을 파일 존재 여부 확인
    if (strict) {
      throw new IllegalStateException("Input resource must exist (reader is in 'strict' mode): " + resource);
    }
    logger.warn("Input resource does not exist " + resource.getDescription());
    return;
  }
// ...
  reader = bufferedReaderFactory.create(resource, encoding); // 데이터를 읽어들일 BufferedReader 준비
}
```

```java
@Override
protected void doClose() throws Exception {
    // ...
    reader.close(); // BufferedReader.close()를 호출하여 파일을 닫음
    // ...
}
```

### JdbcCursorItemReader.doOpen

- 부모 클래스인 `AbstractItemCountingItemStreamItemReader`의 `open()` 메서드에서 `doOpen` 호출

```java
@Override
protected void doOpen() throws Exception {
   // ...
   // DB 연결 초기화 -> this.con = dataSource.getConnection();
   initializeConnection(); 
   openCursor(con); // 커서를 열어 데이터를 읽을 준비
   // ... 
}
```

```java
protected void doClose() throws Exception {
  // ...
  JdbcUtils.closeResultSet(this.rs); // ResultSet 닫기
  rs = null;
  cleanupOnClose(con); // 커서 close
  // ...
  JdbcUtils.closeConnection(this.con); // DB 커넥션 닫기
}
```

- `JdbcCursorItemReader.doOpen`
  - 부모 클래스인 `AbstractItemCountingItemStreamItemReader`의 `open()` 메서드에서 `doOpen` 호출

```java
@Override
protected void doOpen() throws Exception {
   // ...
   // DB 연결 초기화 -> this.con = dataSource.getConnection();
   initializeConnection(); 
   openCursor(con); // 커서를 열어 데이터를 읽을 준비
   // ... 
}
```

```java
protected void doClose() throws Exception {
    // ...
    JdbcUtils.closeResultSet(this.rs); // ResultSet 닫기
    rs = null;
    cleanupOnClose(con); // 커서 close
    // ...
    JdbcUtils.closeConnection(this.con); // DB 커넥션 닫기
}
```

## 메타데이터 관리 및 상태 추적

- `ItemStream`은 스텝의 실행 정보를 관리(저장, 복구)하는 역할도 맡는다.
- 메타데이터 관리가 필요한 이유
  - 배치 작업의 예상치 못한 실패 시 적절한 재처리를 위해 필요
  - 메타데이터가 없다면 실패 시 처음부터 다시 처리해야할 것이다.

### open() (실행 정보 복원)

- `open()` 메서드는 작업을 실패한 지점부터 이어할 수 있도록 상태를 복원한다.
- `ExecutionContext`를 입력으로 받는다.
  - 이전 스텝 실행 정보 포함
  - 처음 실행되는 경우엔 빈 상태로 전달된다.

- `FlatFileItemReader의` 부모 클래스인 `AbstractItemCountingItemStreamItemReader`의 `open()`
  - `ExecutionContext`에서 `maxItemCount`와 `itemCount`를 읽어온다. 
  - `maxItemCount` - 최대 몇 개 아이템을 읽을지 설정 값
  - `itemCount` - 이전 실행에서 몇 개 읽었는지에 대한 정보
  - 이전 읽었던 `itemCount`만큼 `jumpToItem()` 메서드로 읽기 위치를 이동시킨다.
  - `jumpToItem()` 호출 시엔 `readLine()`을 호출하여 순차적으로 읽어 나간다.

```java
public void open(ExecutionContext executionContext) throws ItemStreamException {
   // ...
   if (itemCount > 0 && itemCount < maxItemCount) {
       try {
           jumpToItem(itemCount);
       }
       catch (Exception e) {
           throw new ItemStreamException("Could not move to stored position on restart", e);
       }
   }
   currentItemCount = itemCount;
}
```

- `JdbcCursorItemReader` 또한 `AbstractItemCountingItemStreamItemReader`을 상속한다.
  - 따라서 `ExecutionContext`에서 `itemCount`와 `maxItemCount`를 읽어오는 방식이 동일하다.
  - 아래는 `JdbcUrsorItemReader`의 부모 클래스인 `AbstractCursorItemReader`의 `jumpToItem()` 구현이다.

```java
@Override
protected void jumpToItem(int itemIndex) throws Exception {
   if (driverSupportsAbsolute) {
      //...
      rs.absolute(itemIndex); // ResultSet.absolute()
      //...
   }
   else {
      moveCursorToRow(itemIndex);
   }
}
```

- `driverSupportsAbsolute`
  - `JdbcCursorItemReaderBuilder`에서 설정 가능하며 기본값은 `false`
  - `true` → `ResultsSet.absolute()`를 사용해 즉시 원하는 위치로 커서를 이동시킬 수 있다.
  - `false` → `itemIndex`만큼 `ResultSet.next()`를 순차적으로 호출하여 커서까지 이동시킨다.
  - 하지만 `JdbcCursorItemReader`는 `ResultSet.TYPE_FORWARD_ONLY`를 사용한다.
    - `ResultSet.TYPE_FORWARD_ONLY` - 커서의 순방향 이동만 지원하는 설정
    - JDBC 드라이버 지원 여부와 관계없이 `ResultSet.absolute()`를 사용할 수 없다.
    - 따라서 `driverSupportsAbsolute`는 `false`로 유지하는 것이 안전하다.


- `JdbcPagingItemReader`의 부모 클래스인 `AbstractPagingItemReader`의 `jumpToItem`은 효율적인 구현을 제공한다.
  - 간단한 수식으로 어떤 위치부터 읽어야 하는지 즉시 계산할 수 있다.

```java
@Override
protected void jumpToItem(int itemIndex) throws Exception {
   this.lock.lock();
   try {
      page = itemIndex / pageSize;
      current = itemIndex % pageSize;
   }
   finally {
      this.lock.unlock();
   }
   // ...
}
```

### update() (상태 저장)

- `update()` 메서드는 현재 작업이 어디까지 진행되었는지를 저장한다.
  - Spring batch의 `Step`은 여기서 메타데이터 저장소에 실행 정보를 저장한다.
  - 트랜잭션 커밋 직전에 `update()`가 호출된다.

```java
default void update(ExecutionContext executionContext) throws ItemStreamException {
}
```

- 아래는 `AbstractItemCountingItemStreamItemReader`의 `update()` 코드이다.

```java
@Override
public void update(ExecutionContext executionContext) throws ItemStreamException {
    // ...
    executionContext.putInt(getExecutionContextKey(READ_COUNT), currentItemCount);

    if (maxItemCount < Integer.MAX_VALUE) {
        executionContext.putInt(getExecutionContextKey(READ_COUNT_MAX), maxItemCount);
    }
    // ...
}
```

- `currentItemCount`**,** `maxItemCount`를 저장하여 `open()` 메서드에서 복원 시 사용한다.

### 재시작 불가 사례: RedisItemReader

- `RedisItemReader`의 경우 재시작을 지원하지 않는다.
  - `SCAN` 명령의 순서 불일치 때문

> `SCAN`- 대량의 key를 효율적으로 탐색하기 위한 용도로, 서버를 블로킹하지 않고 점진적으로 키를 반환하는 명령어 (`KEYS` 명령어는 전체 키를 검색하지만 서버를 블로킹할 수 있다.)
>
