# FaultTolerant

## Spring Batch의 기본 오류 처리

- 배치 플로우의 어느 단계에서든 예외가 발생하면 배치 잡 전체가 실패로 처리된다.
    - `ItemReader`/`ItemProcessor`/`ItemWriter`에서 발생한 예외가 `Step`으로 전파되어 전체 `Job` 실패로 이어진다.

### 청크 지향 처리의 구조적 한계

- 청크 지향 처리에서 개발자는 실제 실행에 개입하지 않고 `Step`에 맡긴다.
    - 단지 `ItemReader`/`ItemProcessor`/`ItemWriter`를 구현할 뿐
    - 즉 아이템 처리 중 발생한 예외에 개입할 기회가 없다.
- Spring Batch는 이 한계를 보완하기 위해 내결함성(FaultTolerance) 기능을 제공한다.
    - 재시도(Retry)
    - 건너뛰기(Skip)

> 태스크릿 지향 처리는 내결함성 기능의 지원 대상이 아니다. `Tasklet.execute` 내부에 전체 로직을 작성하기에 `try-catch`로 제어 가능하기 때문
>

## 재시도(Retry)

- 재시도(Retry)는 말 그대로 실패한 작업을 다시 사도하는 것
    - ex) 외부 API 호출에 일시적 타임아웃이 발생했을 때

### RetryTemplate

- Spring Retry의 핵심 컴포넌트
    - 작업 실패 시 정해진 정책에 따라 다시 시도
- `RetryTempplate.execute()`
    - `canRetry()`: True → `retryCallback`
    - `canRetry()`: False → `recoveryCallback`
- `retryCallback`
    - 핵심 비즈니스 로직이 담겨 있다.
    - 최초 실행부터 재시도까지 모두 `retryCallback`을 통해 수행된다.
- `recoverCallback`
    - 재시도가 불가능할 때 실행된다.
    - 기본적으로 예외를 그대로 전파하거나 대체 로직을 수행

- 내결함성 모드가 활성화되면 `ItemProcessor`/`ItemWriter` 호출 로직이 `retryCallback` 안으로 패키징된다.
  - 청크 처리가 `RetryTemplate`을 통해 수행되는 것

### RetryPolicy

- `RetryPolicy`를 통해 재시도 여부를 결정
- 기본적으로 `SimpleRetryPolicy` 정책을 사용
  - 발생한 예외가 사전에 정의된 예외 유형인지
  - 현재 재시도 횟수가 최대 허용 횟수를 초과하지 않았는지

### ItemReader 재시도는 없다

- `ItemReader`에서 발생한 예외는 재시도 되지 않는다.
- `Mutable`한 데이터 소스(ex. RabbitMQ, SQS 등)로부터 읽은 데이터는 재시도할 수 없기 때문
  - `Mutable`하다는 뜻은 읽으면 사라지는 데이터 소스를 의미
- 대부분의 데이터소스(파일, DB, Kafka)는 immutable하기에 언젠가 `ItemReader`도 재시도가 가능해질 수도 있다.

### 내결함성 최적화 - Input Chunk 재활용

- `ItemReader`의 기본 규약은 forward only
  - 데이터를 단방향으로만 순차적으로 읽어나가는 것이 기본 원칙
  - 즉 재시도가 발생해도 과거로 되돌아가 아이템을 다시 읽지 않는다.
- 재시도가 발생하면 `Step`은 청크 버퍼링에서 `RetryTemplate`에 input Chunk를 다시 전달한다.
  - 내결함성 기능이 활성화되면 input Chunk를 별도로 청크 버퍼링에 저장해 둔다.

### 재시도 설정

```java
@Bean
public Step terminationRetryStep() {
    return new StepBuilder("terminationRetryStep", jobRepository)
            .<Scream, Scream>chunk(3, transactionManager)
            .reader(terminationRetryReader())
            .processor(terminationRetryProcessor())
            .writer(terminationRetryWriter())
            .faultTolerant() // 내결함성 기능 ON
            .retry(TerminationFailedException.class)   // 재시도 대상 예외 추가
            .retryLimit(3)
            .listener(retryListener())
            .build();
}
```

- `faultTolerant()`
  - 재시도 기능 활성화
- 앞서 설명했듯이 기본적으로 `SimpleRetryPolicy`가 사용된다.
  - `retry()` - 재시도 대상 예외 지정, 연속해서 호출하면 여러 예외를 지정할 수도 있다.
  - `retryLimit()` - 최대 시도 횟수 지정, 기본값은 0
  - `noRetry()` - 특정 예외를 무시하고 싶을 때 지정하면 해당 예외의 하위 타입 예외는 무시된다.
- `listener()`
  - 재시도 과정을 모니터링할 수 있는 리스너를 등록
  - `RetryListener` 인터페이스의 구현체를 등록해야 한다.

```java
public interface RetryListener {
    default <T, E extends Throwable> boolean open(RetryContext context, RetryCallback<T, E> callback) {
        return true; // 재시도 시작 전에 호출. false를 반환하면 재시도를 중단
    }
    default <T, E extends Throwable> void onError(RetryContext context, RetryCallback<T, E> callback,
            Throwable throwable) {
        // 재시도 중 오류 발생할 때마다 호출
    }
    default <T, E extends Throwable> void onSuccess(RetryContext context, RetryCallback<T, E> callback, T result) { 
        // 재시도 성공 시 호출
    }
    default <T, E extends Throwable> void close(RetryContext context, RetryCallback<T, E> callback,
            Throwable throwable) {
        // 모든 재시도가 끝난 후 호출 (성공/실패 여부와 무관)
    }
}
```
