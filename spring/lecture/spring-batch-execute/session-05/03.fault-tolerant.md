# FaultTolerant

## Spring Batch의 기본 오류 처리

- 배치 플로우의 어느 단계에서든 예외가 발생하면 배치 잡 전체가 실패로 처리된다.
    - `ItemReader`/`ItemProcessor`/`ItemWriter`에서 발생한 예외가 `Step`으로 전파되어 전체 `Job` 실패로 이어진다.

### 청크 지향 처리의 구조적 한계

- 청크 지향 처리에서 개발자는 실제 실행에 개입하지 않고 `Step`에 맡긴다.
    - 단지 `ItemReader`/`ItemProcessor`/`ItemWriter`를 구현할 뿐
    - 즉 아이템 처리 중 발생한 예외에 개입할 기회가 없다.
- Spring Batch는 이 한계를 보완하기 위해 내결함성(FaultTolerance) 기능을 제공한다.
    - 재시도(Retry)
    - 건너뛰기(Skip)

> 태스크릿 지향 처리는 내결함성 기능의 지원 대상이 아니다. `Tasklet.execute` 내부에 전체 로직을 작성하기에 `try-catch`로 제어 가능하기 때문
>

## 재시도(Retry)

- 재시도(Retry)는 말 그대로 실패한 작업을 다시 사도하는 것
    - ex) 외부 API 호출에 일시적 타임아웃이 발생했을 때

### RetryTemplate

- Spring Retry의 핵심 컴포넌트
    - 작업 실패 시 정해진 정책에 따라 다시 시도
- `RetryTempplate.execute()`
    - `canRetry()`: True → `retryCallback`
    - `canRetry()`: False → `recoveryCallback`
- `retryCallback`
    - 핵심 비즈니스 로직이 담겨 있다.
    - 최초 실행부터 재시도까지 모두 `retryCallback`을 통해 수행된다.
- `recoverCallback`
    - 재시도가 불가능할 때 실행된다.
    - 기본적으로 예외를 그대로 전파하거나 대체 로직을 수행

- 내결함성 모드가 활성화되면 `ItemProcessor`/`ItemWriter` 호출 로직이 `retryCallback` 안으로 패키징된다.
    - 청크 처리가 `RetryTemplate`을 통해 수행되는 것

### RetryPolicy

- `RetryPolicy`를 통해 재시도 여부를 결정
- 기본적으로 `SimpleRetryPolicy` 정책을 사용
    - 발생한 예외가 사전에 정의된 예외 유형인지
    - 현재 재시도 횟수가 최대 허용 횟수를 초과하지 않았는지

### ItemReader 재시도는 없다

- `ItemReader`에서 발생한 예외는 재시도 되지 않는다.
- `Mutable`한 데이터 소스(ex. RabbitMQ, SQS 등)로부터 읽은 데이터는 재시도할 수 없기 때문
    - `Mutable`하다는 뜻은 읽으면 사라지는 데이터 소스를 의미
- 대부분의 데이터소스(파일, DB, Kafka)는 immutable하기에 언젠가 `ItemReader`도 재시도가 가능해질 수도 있다.

### 내결함성 최적화 - Input Chunk 재활용

- `ItemReader`의 기본 규약은 forward only
    - 데이터를 단방향으로만 순차적으로 읽어나가는 것이 기본 원칙
    - 즉 재시도가 발생해도 과거로 되돌아가 아이템을 다시 읽지 않는다.
- 재시도가 발생하면 `Step`은 청크 버퍼링에서 `RetryTemplate`에 input Chunk를 다시 전달한다.
    - 내결함성 기능이 활성화되면 input Chunk를 별도로 청크 버퍼링에 저장해 둔다.

### 재시도 설정

```java

@Bean
public Step terminationRetryStep() {
    return new StepBuilder("terminationRetryStep", jobRepository)
            .<Scream, Scream>chunk(3, transactionManager)
            .reader(terminationRetryReader())
            .processor(terminationRetryProcessor())
            .writer(terminationRetryWriter())
            .faultTolerant() // 내결함성 기능 ON
            .retry(TerminationFailedException.class)   // 재시도 대상 예외 추가
            .retryLimit(3)
            .listener(retryListener())
            .build();
}
```

- `faultTolerant()`
    - 재시도 기능 활성화
- 앞서 설명했듯이 기본적으로 `SimpleRetryPolicy`가 사용된다.
    - `retry()` - 재시도 대상 예외 지정, 연속해서 호출하면 여러 예외를 지정할 수도 있다.
    - `retryLimit()` - 최대 시도 횟수 지정, 기본값은 0
    - `noRetry()` - 특정 예외를 무시하고 싶을 때 지정하면 해당 예외의 하위 타입 예외는 무시된다.
- `listener()`
    - 재시도 과정을 모니터링할 수 있는 리스너를 등록
    - `RetryListener` 인터페이스의 구현체를 등록해야 한다.

```java
public interface RetryListener {
    default <T, E extends Throwable> boolean open(RetryContext context, RetryCallback<T, E> callback) {
        return true; // 재시도 시작 전에 호출. false를 반환하면 재시도를 중단
    }

    default <T, E extends Throwable> void onError(RetryContext context, RetryCallback<T, E> callback,
                                                  Throwable throwable) {
        // 재시도 중 오류 발생할 때마다 호출
    }

    default <T, E extends Throwable> void onSuccess(RetryContext context, RetryCallback<T, E> callback, T result) {
        // 재시도 성공 시 호출
    }

    default <T, E extends Throwable> void close(RetryContext context, RetryCallback<T, E> callback,
                                                Throwable throwable) {
        // 모든 재시도가 끝난 후 호출 (성공/실패 여부와 무관)
    }
}
```

### 내결함성 동작 차이

- `ItemProcessor`와 `ItemWriter`는 완전히 다른 재시도 방식을 사용한다.
- `ItemProcessor`의 재시도
    - 청크 내에서 예외가 발생하면 청크 전체가 `retryLimit`만큼 다시 처리(`process`)된다.
    - `ItemProcessor`의 재시도는 청크 단위가 아닌 아이템 단위로 재시도 컨텍스트가 관리된다.
        - 만약 특정 아이템만 계속 실패하고 나머지는 성공한다면 실패하는 아이템의 재시도 카운트만 증가하고 성공 처리된 아이템들은 재시도 카운트가 증가하지 않는다.
        - 즉 실패하는 아이템이 `retryLimit`번째 재시도를 실행해야 재시도가 종료되고, 실패하는 아이템 앞 순서에서 재처리되는 아이템들은 `retryLimit + 1`번만큼 재실행되게 된다.
    - 재시도 카운트가 증가하진 않지만 청크 단위로 재시도가 일어나기에 이미 처리된 아이템도 다시 `process()`를 호출하게 된다.
    - 때문에 내결함성 기능을 사용할 땐 `ItemPrcoessor`가 멱등하게 동작해야 재시도 과정에서 문제를 일으키지 않는다.
    - 이미 성공한 아이템의 불필요한 재처리를 방지하려면 `processorNonTransactional()` 설정을 통해 성공 아이템들은 캐시 결과를 재사용하도록 할 수 있다.
        - `process` 내부에서 비용이 큰 작업을 수행했다면 이를 방지 가능

```java

@Bean
public Step terminationRetryStep() {
    return new StepBuilder("terminationRetryStep", jobRepository)
            //...
            .faultTolerant()
            .retry(TerminationFailedException.class)
            .retryLimit(3)
            .listener(retryListener())
            .processorNonTransactional() // ItemProcessor 비트랜잭션 처리
            .build();
}
```

- `ItemWriter`의 재시도
    - `ItemWriter`는 아이템을 청크 단위로 한 번에 쓴다.
    - 때문에 `ItemProcessor`와 달리 재시도 횟수가 청크 단위로 관리되고 특정 아이템만 재시도를 할 수 없다.
    - `ItemWriter`에서 예외 발생 후 재시도가 시작되면 `ItemProcessor`부터 다시 시작한다.

### 다양한 재시도 정책 적용 (RetryPolicy)

- 기본 재시도 전략 외에 직접 `RetryPolicy`를 지정할 수도 있다.
    - `retryPolicy(new CustomRetryPolicy())`
- 만약 기본 `retry()`, `retryLimit()`와 `retryPolicy()`를 함께 사용하면 AND 조건으로 모든 정책이 재시도 가능이라 판단해야 재시도가 실행된다.
    - 복잡해지기에 동시에 사용하지 않는 것을 권장

### 백오프 정책(BackOffPolicy)

- `BackOffPolicy`로 재시도 간격을 조정할 수 있다.
    - 별도로 설정하지 않으면 기본적으로 `NoBackOffPolicy`가 적용
    - 실패 후 바로 재시도를 수행하면 부하가 가중되고 회복 가능성이 떨어질 수 있다.

```java
// BackOffPolicy 설정
backOffPolicy(new FixedBackOffPolicy() {
    {
        setBackOffPeriod(1000); // 1초
    }
})

// 또는 
backOffPolicy(new ExponentialBackOffPolicy() {
    {
        setInitialInterval(1000L);  // 초기 대기 시간
        setMultiplier(2.0);        // 대기 시간 증가 배수
        setMaxInterval(10000L);     // 최대 대기 시간
    }
})
```

- 백오프 정책을 통해 외부 시스템과의 통신 실패 시 재시도 성공률을 높일 수 있다.

## 건너뛰기(Skip)

- 앞서 `RetryTempplate.canRetry`가 `false`를 반환하면 `recoveryCallback`이 실행된다 했다.
- `Step`에 skip 기능이 활성화되면 `recoveryCallback`을 통해 예외를 건너뛸 수 있다.
    - 예외가 발생한 레코드를 건너뛰어 배치 프로세스가 중단 없이 진행되도록 한다.
- skip은 다음 상황에서 고려해볼 수 있다.
    - 비즈니스적으로 중요도가 낮은 데이터를 처리할 때
    - 일부 실패 레코드 처리보다 전체 배치 프로세스 완료가 더 중요할 때
    - 입력 데이터의 품질이 균일하지 않을 때

> `ItemProcessor`의 필터링과 skip은 다르다. 필터링은 일부 아이템을 의도적으로 걸러내는 것이고 skip은 예외가 발생했을 때 건너뛰는 예외 처리 방식이다.
>

```java

@Bean
public Step terminationRetryStep() {
    return new StepBuilder("terminationRetryStep", jobRepository)
            .<Scream, Scream>chunk(3, transactionManager)
            .reader(terminationRetryReader())
            .processor(terminationRetryProcessor())
            .writer(terminationRetryWriter())
            .faultTolerant()
            .skip(TerminationFailedException.class)
            .skipLimit(2)
            .build();
}
```

- skip 기능은 `SkipPolicy` 기반으로 동작하며 별도 설정이 없으면 기본적으로 `LimitCheckingItemSkipPolicy`가 사용된다.
    - `skip()`: 건너뛸 예외를 지정
    - `skipLimit()`: `Step`에서 허용할 최대 건너뛰기 횟수 지정
        - skip에선 스텝 전체에서 발생한 총 건너뛰기 횟수를 카운팅한다.
        - 예외가 어떤 아이템 또는 청크에서 발생했는지와 무관
        - 기본값은 10
- 별도 `SkipPolicy`는 아래와 같이 지정할 수 있다.

```java
.skipPolicy(new AlwaysSkipItemSkipPolicy())
```

### ItemProcessor에서의 건너뛰기

- `ItemProcessor`에서의 건너뛰기는 단순하다.
    - `SkipPolicy`가 건너뛰기 가능하다고 판단하면 `null`을 반환
    - 그렇지 않다면 건너뛸 수 없다며 예외를 던진다.
- `ItemProcessor`에서 `null`을 반환하면 해당 데이터는 필터링되어 `ItemWriter`에 전달되지 않는다.

> 정상적인 필터링과 건너뛰기 모두 `ItemWriter`에 데이터가 전달되지 않는다는 점은 동일하지만, Spring Batch는 이를 구분하여 각각 `filterCount`와 `skipCount`에 기록한다.
>

- 실행 흐름
    1. 아이템 처리 중 예외 발생 → 청크 트랜잭션 롤백
    2. 청크 재처리 시작 → 이전 아이템들 다시 처리
    3. 실패한 아이템 차례에 `RetryTemplate`이 `recoveryCallback` 호출 → 건너뛰기 실행
    4. 나머지 아이템 처리 후 `ItemWriter`에 스킵된 아이템 제외하고 전달

#### skipLimit 초과 시 동작

- `skipLimit`을 초과하면 `SkipLimitExceededException`이 발생하고 작업이 실패한다.
    - `skipLimit`은 스텝 전체 기준으로 관리되므로 실패 빈도를 고려하여 적절히 설정해야 한다.

### ItemWriter 건너뛰기와 스캔 모드

- `ItemWriter`에선 개별 아이템이 아닌 청크 단위로 동작한다.
    - 때문에 예외 발생 시 어떤 아이템이 문제인지 즉시 알 수 없다.
- 이를 해결하기 위해 spring batch는 **스캔 모드**로 돌입한다.
    - 스캔 모드란 청크 내 아이템을 하나씩 개별 처리하는 특수 모드다.
    - 문제가 발생한 아이템을 식별하고 그것만 건너뛸 수 있게 한다.
- 스캔 모드에 동작
    1. 재시도 불가능 판단 후 스캔 모드로 전환
    2. `ItemProcessor`가 아이템 하나를 처리하고 바로 `ItemWriter`에 전달
    3. `ItemWriter`는 단일 아이템만 쓰고 성공 시 즉시 커밋
    4. 단일 아이템 쓰기 중 예외가 발생하면 해당 아이템을 건너뛴다. (`SkipPolicy`에 따라)

- 스캔 모드의 성능 비용
    - 스캔 모드는 강력하지만 성능상 대가가 크다.
    - Skip이 빈번하게 발생할 것으로 예상된다면 다음 방법을 먼저 고려해야 한다.
        - 전처리 스텝에서 불량 데이터를 미리 걸러내기
        - `ItemProcessor`에서 철저한 검증 로직으로 문제 데이터를 사전 필터링
        - 애초에 예외가 발생하지 않도록 방어
    - Skip이 자주 발생할 것 같은데 데이터 전처리가 현실적으로 어렵다면 Skip 기능 자체를 포기하는 것도 고려해야 한다.
        - 느린 배치보다는 실패하는 배치가 차라리 나을 수 있다.
    - `.processorNonTransactional()` 설정을 사용하면 `ItemProcessor`의 중복 실행을 방지할 수 있다.
        - 스캔 모드에서도 동일하게 캐시된 결과가 재사용된다.
- 스캔 모드 내부 최적화
  - Spring Batch는 이런 비효율을 방지하기 위해 스캔 모드 내부 최적화를 수행한다.
      1. **마지막 예외 분석**: 스캔 모드 진입 전 마지막으로 발생한 예외를 분석
      2. **건너뛰기 가능성 검사**: 해당 예외가 건너뛰기 가능한 타입인지 확인
      3. **사전 차단**: 건너뛰기 불가능하다면 바로 실패 처리

### ItemReader에서의 건너뛰기 동작

- `ItemReader`에는 재시도 기능이 없지만 건너뛰기는 가능하다.
- `ItemReader`의 건너뛰기는 단순하다.
  - `read()` 중 예외 발생 시 이를 catch 후 `SkipPolicy`로 판단한다.
  - 건너뛰기 가능하면 바로 다음 아이템을 읽는다.
- `ItemReader`에서의 건너뛰기는 청크 사이즈에 영향을 미치지 않는다.
  - 청크 사이즈 n개를 채울 때까지 정상 아이템만 청크 사이즈에 포함한다.

### SkipListener

- `SkipListener`를 통해 건너뛰기 대상을 추적하고 조치를 취할 수 있다.
  - 각 단계에서 발생하는 건너뛰기에 모두 대응 가능하다.

```java
public interface SkipListener<T, S> extends StepListener {
    default void onSkipInRead(Throwable t) {
    }

    default void onSkipInWrite(S item, Throwable t) {
    }

    default void onSkipInProcess(T item, Throwable t) {
    }
}
```

- `ItemReader`에서 건너뛰기가 발생한 경우에만 해당 아이템 객체에 대한 정보를 제공받을 수 없다.
  - 읽기 자체가 실패했기에 아이템을 특정할 수 없기 때문
- 예외 발생 직후 재시도가 동작하던 `RetryListener`와 달라 `SkipListener`는 `ItemWriter`의 청크 쓰기 바로 다음에 일괄적으로 진행된다.
