# JPA ItemReader / ItemWriter
## JpaCursorItemReader

- JPA에서 사용하는 커서 방식 ItemReader
- `JpaCursorItemReader`는 내부적으로 entityManager를 통해 데이터를 읽는다.

### JpaCursorItemReader 해부

```
JpaCursorItemReader
    │
    ├────── queryString(JPQL) or JpaQueryProvider  
    │        └─ (Query 생성에 사용됨)  
    │
    ├────── EntityManager  
    │        └─ (JPA 핵심 엔진)
    │        
    └────── Query  
             └─ (EntityManager가 생성하는 실행 가능한 쿼리 인스턴스)
```

- `queryString`
    - `JpaCursorItemReaderBuilder.queryString()` 메서드를 통해 생성
    - `JpaCursorItemReaderBuilder.queryProvider()`로 커스텀 `JpaQueryProvider` 전달 가능
- `EntityManager`
    - `JpaCursorItemReaderBuilder.entityManagerFactory()`로 `EntityManagerFactory`를 전달하면 내부적으로 `EntityManager`를 생성해 사용된다.
- `Query`
    - `JpaCursorItemReader`가 `EntityManager`로 `Query` 객체를 생성
    - 스트리밍 방식으로 `getResultStream()` 메서드를 호출

- 실행 흐름
    - `JpaCursortemReader` 초기화
        - `doOpen()` 호출
        - `Query` 객체 생성
        - `getResultStream()` 호출하여 커서를 순회할 `Iterator` 준비
    - `Iterator`를 통해 실제 데이터를 한 건씩 읽어온다.
        - `iterator.hasNext()`로 데이터가 있다면 `iterator.next()`로 데이터 반환
        - 더 이상 읽을 데이터가 없다면 `null` 반환, 읽기 종료

### JpaCursorItemReader 구성 예제

```kotlin
@Bean
@StepScope
fun postBlockReader(
    @Value("#{jobParameters['startDateTime']}") startDateTime: LocalDateTime,
    @Value("#{jobParameters['endDateTime']}") endDateTime: LocalDateTime,
): JpaCursorItemReader<Post> =
    JpaCursorItemReaderBuilder<Post>()
        .name("postBlockReader")
        .entityManagerFactory(entityManagerFactory)
        .queryString(
            """
                SELECT p FROM Post p JOIN FETCH p.reports r
                WHERE r.reportedAt >= :startDateTime AND r.reportedAt < :endDateTime
            """.trimIndent()
        )
        .parameterValues(
            mapOf(
                "startDateTime" to startDateTime,
                "endDateTime" to endDateTime
            )
        )
        .build()
```

- `entityManagerFactory()`
    - 빈 주입 받은 `EntityManagerFactory` 구성
- `queryString()`
    - `parameterValues`로 받은 파라미터와 함께 쿼리 정의
    - 이 메서드를 사용하면 내부적으로 `JpaQueryProvider` 구현체가 사용된다.

### JpaQueryProvider를 사용한 쿼리 설정

- `JpaQueryProvider` 구현체로 더 유연한 쿼리 처리가 가능하다.
    - `JpaNamedQueryProvider`: 엔티티 등에 미리 정의된 Named Query를 사용
    - `JpaNativeQueryProvider`: Native SQL을 사용하여 데이터를 조회
    - 필요하다면 커스텀 구현체도 등록할 수 있다.

```kotlin
// JpaNamedQueryProvider 예제

@Entity
@Table(name = "posts")
@NamedQuery(
    name = "Post.findByReportsReportedAtBetween",
    query = "SELECT p FROM Post p JOIN FETCH p.reports r WHERE r.reportedAt >= :startDateTime AND r.reportedAt < :endDateTime",
)
class Post() { ... }

@Bean
@StepScope
fun postBlockReader(
    @Value("#{jobParameters['startDateTime']}") startDateTime: LocalDateTime,
    @Value("#{jobParameters['endDateTime']}") endDateTime: LocalDateTime,
): JpaCursorItemReader<Post> =
    JpaCursorItemReaderBuilder<Post>()
        .name("postBlockReader")
        .entityManagerFactory(entityManagerFactory)
        .queryProvider(createQueryProvider())
        .parameterValues(
            mapOf(
                "startDateTime" to startDateTime,
                "endDateTime" to endDateTime
            )
        )
        .build()
        
private fun createQueryProvider(): JpaNamedQueryProvider<Post> {
    val queryProvider = JpaNamedQueryProvider<Post>()
    queryProvider.setEntityClass(Post::class.java)
    queryProvider.setNamedQuery("Post.findByReportsReportedAtBetween")
    return queryProvider
}
```

