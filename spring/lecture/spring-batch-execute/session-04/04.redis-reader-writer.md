# NoSQL 읽고 쓰기 - Redis
## RedisItemReader

## RedisItemReader

- Redis 전용 `ItemReader`
- Redis의 `SCAN` 명령을 사용하는 일종의 커서 기반 `ItemReader`
- `RedisItemReader`는 다른 커서 기반 `ItemReader`와는 다르다.
    - `SCAN` 명령어는 조회 대상`key` 목록들만 반환한다.
    - 실제 값을 얻으려면 추가적인 `GET` 명령이 필요

> `SCAN` 명령어는 `STRING` 타입 전용 명령어이기에 `RedisItemReader`는 `STRING` 타입만 지원한다. 별도 타입을 처리하려면 커스텀 `ItemReader`를 구현해야 한다.
>

### RedisItemReader 동작 과정

- 초기화
    - 초기화 시점(`open()`)에 SCAN 명령을 최초 호출해 커서 생성
    - 커서는 조회 대상 key 목록을 담고 있다.
    - 이 때 커서가 가지는 key들은 전체가 아닌 일부이다.
- `read()`
    - `read()` 메서드는 커서로부터 key를 하나씩 받아와서 `GET` 명령을 호출
    - 커서 key가 전부 소비될 때까지 계속한다.
- 추가 `SCAN`
    - 추가적인 명령으로 새로운 key 목록을 확보

### RedisItemReader의 약점

- 네트워크 부하
  - 아이템 하나당 `GET` 명령어를 호출하는 구조라 청크 크기가 클 수록 부하가 늘어난다.
  - 아무리 Redis가 인메모리 DB라고 해도 네트워크 왕복 시간을 무시할 수 없다.
  - 게다가 다수의 `GET`이 몰리면 서버에 상당한 부담이 갈 수도 있다.
- 중복 데이터
  - Redis 내부 데이터 구조 특성 상 `SCAN` 명령이 중복된 key를 반환할 수 있다.
  - 애플리케이션에서 중복 처리를 해야한다.
  - 중복 처리가 힘들다면 `RedisItemReader`는 반드시 멱등성이 보장된 잡에서만 사용해야 한다.
- 재시작 불가
  - `SCAN`은 데이터 순서를 보장하지 않는다.
  - 때문에 실패하면 실패 지점부터 복구할 수가 없기에 재시작 기능을 지원하지 않는다.
  - 실패하면 처음부터 다시 돌릴 수밖에 없다.

### RedisItemReader 구성

```
RedisItemReader
│
├────── RedisTemplate
│       └─ (Redis 작업을 수행하는 핵심 컴포넌트)
│
├────── Cursor
│       └─ (SCAN 명령으로 생성된 Redis 커서)
│
└────── ScanOptions
        └─ (SCAN 명령 수행 시 사용할 옵션들)
```

- `RedisTemplate`
  - Redis 연산을 위한 색심 도구
  - `GET` 명령과 초기 커서 생성을 수행
- `Cursor`
  - `SCAN` 명령의 결과물
  - key 목록을 순차적으로 제공
- `ScanOptions`
  - SCAN 명령 실행 시 필요한 설정 정보를 가지고 있다.
  - ex) 얼마나 많은 key를 조회할지 등

```kotlin
    @Bean
    fun attackLogReader(): RedisItemReader<String, AttackLog> =
        RedisItemReaderBuilder<String, AttackLog>()
        .redisTemplate(redisTemplate)
            .scanOptions(
                ScanOptions
                    .scanOptions()
                    .match("attack:*") // attack: 으로 시작하는 키만 스캔
                    .count(10)
                    .build(),
            ).build()
```

- `RedisItemReaderBuilder`
  - `redisTemplate()` - `RedisTemplate` 전달
  - `scanOptions()` - `ScanOptions` 전달
    - `count()` 메서드 옵션은 엄격한 제한이 아니라 힌트이기에 요청된 개수만큼 반환된다는 보장은 없다.

### RedisItemReader의 한계

- 아래는 `RedisItemReader.read()` 구현이다.
  - key에 따른 value만 반환한다.

```java
@Override
public V read() throws Exception {
    if (this.cursor.hasNext()) {
       K nextKey = this.cursor.next();
       return this.redisTemplate.opsForValue().get(nextKey);
    }
    else {
       return null;
    }
}
```

- 즉 key에 포함된 중요 정보를 활용할 수 없다는 한계가 있다.
  - 보통 key에는 사용자 ID, 세션 ID 같은 고유 식별자를 활용한다.
- `Pair<K, V>` 타입을 반환하여 key, value를 함께 활용할 수 있다면 유용할 것이다.

> SpringBatch 6에 이 항목이 반영될 수도 있으니 기대해 보자.
>

## **RedisItemWriter**

- `RedisItemWriter`
  - `RedisTemplate`을 활용
  - 청크의 각 아이템을 추가(`SET`)하거나 삭제(`DEL`)한다.
  - `RedisItemReader`처럼 STRING 타입만 지원한다.
- `RedisItemWriter`의 `itemKeyMapper`
  - `Converter<V, K>` 타입의 필드
  - 청크의 각 아이템(`V`)로 Redis key(`K`)를 추출하는 역할을 한다.

```kotlin
@Bean
fun deleteAttackLogWriter(): RedisItemWriter<String, AttackLog> =
    RedisItemWriterBuilder<String, AttackLog>()
        .redisTemplate(redisTemplate)
        .itemKeyMapper { attackLog: AttackLog -> "attack:" + attackLog.id }
        .delete(true)
        .build()
```

- `itemKeyMapper`
  - 전달된 값의 정보를 사용해 키를 구성
- `delete(true)`
  - `RedisItemWriter`를 삭제 모드로 동작시킨다.
  - `itemKeyMapper`에서 추출한 키로 `DEL` 명령을 실행
  - `false`로 설정하면 반대로 추출한 키로 값(`AttackLog` 객체)을 redis에 저장한다.
