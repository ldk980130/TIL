# NoSQL 읽고 쓰기 - Redis
## RedisItemReader

## RedisItemReader

- Redis 전용 `ItemReader`
- Redis의 `SCAN` 명령을 사용하는 일종의 커서 기반 `ItemReader`
- `RedisItemReader`는 다른 커서 기반 `ItemReader`와는 다르다.
    - `SCAN` 명령어는 조회 대상`key` 목록들만 반환한다.
    - 실제 값을 얻으려면 추가적인 `GET` 명령이 필요

> `SCAN` 명령어는 `STRING` 타입 전용 명령어이기에 `RedisItemReader`는 `STRING` 타입만 지원한다. 별도 타입을 처리하려면 커스텀 `ItemReader`를 구현해야 한다.
>

### RedisItemReader 동작 과정

- 초기화
    - 초기화 시점(`open()`)에 SCAN 명령을 최초 호출해 커서 생성
    - 커서는 조회 대상 key 목록을 담고 있다.
    - 이 때 커서가 가지는 key들은 전체가 아닌 일부이다.
- `read()`
    - `read()` 메서드는 커서로부터 key를 하나씩 받아와서 `GET` 명령을 호출
    - 커서 key가 전부 소비될 때까지 계속한다.
- 추가 `SCAN`
    - 추가적인 명령으로 새로운 key 목록을 확보

### RedisItemReader의 약점

- 네트워크 부하
  - 아이템 하나당 `GET` 명령어를 호출하는 구조라 청크 크기가 클 수록 부하가 늘어난다.
  - 아무리 Redis가 인메모리 DB라고 해도 네트워크 왕복 시간을 무시할 수 없다.
  - 게다가 다수의 `GET`이 몰리면 서버에 상당한 부담이 갈 수도 있다.
- 중복 데이터
  - Redis 내부 데이터 구조 특성 상 `SCAN` 명령이 중복된 key를 반환할 수 있다.
  - 애플리케이션에서 중복 처리를 해야한다.
  - 중복 처리가 힘들다면 `RedisItemReader`는 반드시 멱등성이 보장된 잡에서만 사용해야 한다.
- 재시작 불가
  - `SCAN`은 데이터 순서를 보장하지 않는다.
  - 때문에 실패하면 실패 지점부터 복구할 수가 없기에 재시작 기능을 지원하지 않는다.
  - 실패하면 처음부터 다시 돌릴 수밖에 없다.

### RedisItemReader 구성

```
RedisItemReader
│
├────── RedisTemplate
│       └─ (Redis 작업을 수행하는 핵심 컴포넌트)
│
├────── Cursor
│       └─ (SCAN 명령으로 생성된 Redis 커서)
│
└────── ScanOptions
        └─ (SCAN 명령 수행 시 사용할 옵션들)
```

- `RedisTemplate`
  - Redis 연산을 위한 색심 도구
  - `GET` 명령과 초기 커서 생성을 수행
- `Cursor`
  - `SCAN` 명령의 결과물
  - key 목록을 순차적으로 제공
- `ScanOptions`
  - SCAN 명령 실행 시 필요한 설정 정보를 가지고 있다.
  - ex) 얼마나 많은 key를 조회할지 등

```java
RedisItemReader redisItemReader = new RedisItemReaderBuilder<String, AttackLog>()
    .redisTemplate(template)
    .scanOptions(ScanOptions.scanOptions()
        .match("attack:*")
        .count(10)
        .build())
    .build();
```

- `RedisItemReaderBuilder`
  - `redisTemplate()` - `RedisTemplate` 전달
  - `scanOptions()` - `ScanOptions` 전달
    - `count()` 메서드 옵션은 엄격한 제한이 아니라 힌트이기에 요청된 개수만큼 반환된다는 보장은 없다.
