# ItemWriter와 ItemReader 통합

## CompositeItemReader

- 여러 `ItemReader`들을 순차적으로 실행
- `ItemReader`를 `List`로 전달하면 이를 순서대로 실행한다.
    - 이전 `ItemReader`가 더 이상 읽을 게 없다고 판단되면 `null`을 반환

```java
List<ItemStreamReader<Customer>> readers = List.of(
    shard1ItemReader,  
    shard2ItemREader   
);

CompositeItemReader<Customer> compositeReader = new CompositeItemReader<>(readers);
```

- 데이터베이스가 여러 샤드로 분산되어 있을 때 특히 유용하다.
  - 샤드 관리 없이 각 샤드(datasource)를 바라보는 `ItemReader`들만 준비하면 된다.

## **CompositeItemWriter**

- `CompositeItemWriter`는 여러 `ItemWriter`들에게 같은 데이터를 전달한다.
  - 모든 위임 대상들이 차례대로 `write()`를 호출

```java
public void write(Chunk<? extends T> chunk) throws Exception {
    for (ItemWriter<? super T> writer : delegates) {
       writer.write(chunk);
    }
}
```

- 구성도 단순하다.

```java
CompositeItemWriter<Hacker> writer = new CompositeItemWriter<>(
   List.of(
       firstWriter,
       secondWriter,
       thirdWriter
   )
);
```

- 하나의 데이터를 여러 시스템에 동시에 써야하는 경우 유용하다.
  - ex) 동일한 데이터를 RDB와 NoSQL에 각각 저장해야 하는 경우

- `CompositeItemWriter` 사용에선 `FlatFileItemWriter`와 `MongoItemWriter`의 지연 쓰기가 빛을 발한다.
  - `FlatFileItemWriter`와 `MongoItemWriter`는 `beforeCommit()` 시점까지 실제 쓰기를 미룬다.
  - ex) `FlatFileItemWriter`, `JdbcBatchItemWriter`로 `CompositeItemWriter`를 구성한 경우
    - `JdbcBatchItemWriter`에서 예외가 발생한 경우 RDB에선 자연스레 롤백이 일어난다.
    - 이 때 이미 `FlatFileItemWriter.write()`가 실행되었고, 즉시 데이터를 썼다면 파일의 데이터와 RDB 데이터 싱크는 어긋난다.
    - 쓰기 지연 덕분에 데이터를 쓰지 않고 넘어갈 수 있다.
