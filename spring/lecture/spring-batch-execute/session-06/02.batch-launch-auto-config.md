# 배치 실행 진입점과 Spring Batch 자동 구성

## JobLauncherApplicationRunner

- `./gradlew bootRun` 실행 시 배치 작업이 자동으로 실행된다.
- 커맨드라인에서 전달한 문자열을 `Job`과 `JobParameters`로 변환하여 `JobLauncher`에 전달

```
./gradlew bootRun --args='--spring.batch.job.name=brutalizedSystemJob chaos=true,java.lang.Boolean'
```

### run() 메서드

```java
public void run(ApplicationArguments args) throws Exception {
    String[] jobArguments = args.getNonOptionArgs().toArray(new String[0]);
    run(jobArguments);
}

public void run(String... args) throws JobExecutionException {
    // "="를 delimiter로 사용해 key-value Properties로 변환
    launchJobFromProperties(StringUtils.splitArrayElementsIntoProperties(args, "="));
}
```

- Spring Boot가 애플리케이션 컨텍스트 초기화 후 `run()` 메서드를 호출
- `getNonOptionArgs()`로 잡 파라미터만 추출 (예: `chaos=true,java.lang.Boolean`)
- `"="` 기준으로 `Properties`로 변환: `{ "chaos": "true,java.lang.Boolean" }`

### DefaultJobParametersConverter

- `Properties`를 실제 `JobParameters`로 변환
- 생성자에서 날짜/시간 등 다양한 타입 변환기를 등록

```java
// getJobParameters()에서 각 Properties 엔트리를 JobParameter로 변환
for (Entry<Object, Object> entry : properties.entrySet()) {
    String parameterName = (String) entry.getKey();         // "chaos"
    String encodedJobParameter = (String) entry.getValue(); // "true,java.lang.Boolean"
    JobParameter<?> jobParameter = decode(encodedJobParameter); // Boolean 타입의 true로 변환
    jobParametersBuilder.addJobParameter(parameterName, jobParameter);
}
return jobParametersBuilder.toJobParameters();
```

- `decode()` 메서드가 `"true,java.lang.Boolean"` 문자열을 분석하여 `Boolean` 타입의 `true` 값으로 변환
- 이렇게 변환된 `JobParameter`는 `JobParametersBuilder`에 전달된다.


- `JobParameters`가 준비되면 두 가지 경로로 `Job`을 실행한다.

```java
protected void launchJobFromProperties(Properties properties) throws JobExecutionException {
    JobParameters jobParameters = this.converter.getJobParameters(properties);
    executeLocalJobs(jobParameters);
    executeRegisteredJobs(jobParameters);
}
```

### executeLocalJobs()

- `@Configuration`에서 빈으로 등록한 `Job`들 중 지정된 이름과 일치하는 `Job`만 실행

```java
private void executeLocalJobs(JobParameters jobParameters) throws JobExecutionException {
    for (Job job : this.jobs) {
        if (StringUtils.hasText(this.jobName)) {
            if (!this.jobName.equals(job.getName())) {
                continue; // 이름이 일치하지 않으면 건너뜀
            }
        }
        execute(job, jobParameters);
    }
}
```

- `jobs` 변수에는 `@Autowired`를 통해 애플리케이션 컨텍스트의 모든 `Job` 타입 빈이 자동 주입

```java
// JobLauncherApplicationRunner
// ...
private Collection<Job> jobs = Collections.emptySet();

@Autowired(required = false)
public void setJobs(Collection<Job> jobs) {
    this.jobs = jobs;
}
```

- `jobName` 변수에는 `--spring.batch.job.name=brutalizedSystemJob`으로 전달한 실행할 `Job`의 이름이 설정된다.

### executeRegisteredJobs()

- `JobRegistry`에 등록된 `Job` 중 로컬에 없는 `Job`을 찾아 실행
- `JobRegistry`는 `Job` 전용 저장소
  - Spring Boot 자동 구성에 의해 `MapJobRegistry`(in-memory 구현체)가 사용됨

```java
private void executeRegisteredJobs(JobParameters jobParameters) throws JobExecutionException {
    if (this.jobRegistry != null && StringUtils.hasText(this.jobName)) {
        if (!isLocalJob(this.jobName)) { // 로컬 Job이 아닌 경우에만 실행
            Job job = this.jobRegistry.getJob(this.jobName);
            execute(job, jobParameters);
        }
    }
}
```

- `isLocalJob()` 검사로 로컬 컨텍스트와 `JobRegistry` 양쪽에 같은 `Job`이 있어도 중복 실행 방지
- `JobRegistry`는 동적으로 `Job`을 등록해야 할 때 유용하다.
  - 예: 애플리케이션 시작 시점에 외부 설정 파일이나 데이터베이스로부터 `Job` 정의를 읽어와 동적으로 등록하는 시나리오

### getNextJobParameters()

- `execute()` 메서드에서 `JobLauncher.run()`을 호출하기 전에 `getNextJobParameters()`로 `JobParameters`를 한 번 더 가공한다.

```java 
// execute(Job job, JobParameters jobParameters)
JobParameters parameters = getNextJobParameters(job, jobParameters);
JobExecution execution = this.jobLauncher.run(job, parameters);
// ...
```

- 상황에 따라 세 가지 분기 중 하나만 실행된다.

```java
private JobParameters getNextJobParameters(Job job, JobParameters jobParameters) {
    if (jobRepository.isJobInstanceExists(job.getName(), jobParameters)) {
        return getNextJobParametersForExisting(job, jobParameters); // 1) 이미 존재하는 JobInstance
    }
    if (job.getJobParametersIncrementer() == null) { // 2) Incrementer 없음
        return jobParameters;                                      
    }
    
    // 3) Incrementer 있음
    JobParameters nextParameters = new JobParametersBuilder(jobParameters, this.jobExplorer)
            .getNextJobParameters(job).toJobParameters();
    return merge(nextParameters, jobParameters);                 
}
```

**1) 동일한 `JobInstance`가 이미 존재하는 경우**

- 마지막 `JobExecution`이 중단/실패이고 `restartable`인 경우, 이전 `identifying` 파라미터와 새 파라미터를 병합(`merge`)
- `merge()` 시 동일한 키는 새 파라미터 값으로 덮어쓰므로, 재시작 시 `non-identifying` 파라미터를 변경할 수 있다.

**2) `JobParametersIncrementer`가 없는 경우**

- 파라미터 가공 없이 원래 `JobParameters`를 그대로 반환

**3) `JobParametersIncrementer`가 설정된 경우**

- `RunIdIncrementer` 등을 통해 이미 완료된 `JobInstance`를 동일 파라미터로 재실행할 수 있게 해준다.
- `JobExplorer`(메타데이터 저장소 읽기 전용 조회 컴포넌트)를 사용해 마지막 `JobInstance`의 실행 이력을 조회
- 이전 `JobParameters`를 `JobParametersIncrementer.getNext()`에 전달하여 증분된 파라미터를 생성한 후 기존 파라미터와 병합

### JobExplorer

- 위 3번 분기에서 사용되는 `JobExplorer`는 메타데이터 조회에 특화된 컴포넌트
- `JobRepository`는 저장/업데이트/삭제까지 담당하지만, `JobExplorer`는 오직 조회에만 집중하여 더 풍부한 조회 기능을 제공
- 배치 작업 추적 및 관리용 대시보드나 어드민 툴 개발에 유용

```java
public interface JobExplorer {
    List<JobInstance> getJobInstances(String jobName, int start, int count);
    JobInstance getLastJobInstance(String jobName);
    JobExecution getJobExecution(Long executionId);
    JobExecution getLastJobExecution(JobInstance jobInstance);
    Set<JobExecution> findRunningJobExecutions(String jobName);
    List<String> getJobNames();
    long getJobInstanceCount(String jobName);
    /*...*/
}
```

- 3번 분기에서는 `jobExplorer.getLastJobInstance(name)`으로 마지막 `JobInstance`를 조회한 후, 그 실행 이력의 `JobParameters`를 `JobParametersIncrementer.getNext()`에 전달한다.
- 대표적인 구현체인 `RunIdIncrementer`는 `run.id` 파라미터 값을 1씩 증가시켜 매번 새로운 `JobInstance` 생성을 보장

### execute() - JobLauncher 호출

- 최종 `JobParameters`가 결정되면 `JobLauncher.run()`을 호출하여 `Job`을 실행

```java
protected void execute(Job job, JobParameters jobParameters) {
    JobParameters parameters = getNextJobParameters(job, jobParameters);
    JobExecution execution = this.jobLauncher.run(job, parameters); // Job Squad 진입점
}
```

- 이로써 `JobLauncherApplicationRunner.run()`에서 시작하여 `JobLauncher.run()` 호출까지의 흐름이 완료된다.

## BatchAutoConfiguration

- Spring Boot의 자동 구성 메커니즘의 핵심 클래스
- Spring Boot가 Spring Batch를 감지하면 `BatchAutoConfiguration`을 자동으로 활성화시킨다.

### JobLauncherApplicationRunner 자동 구성

```java
@Bean
@ConditionalOnMissingBean
@ConditionalOnProperty(prefix = "spring.batch.job", name = "enabled", havingValue = "true", matchIfMissing = true)
public JobLauncherApplicationRunner jobLauncherApplicationRunner(JobLauncher jobLauncher, JobExplorer jobExplorer,
       JobRepository jobRepository, BatchProperties properties) {
    JobLauncherApplicationRunner runner = new JobLauncherApplicationRunner(jobLauncher, jobExplorer, jobRepository);
    String jobName = properties.getJob().getName();
    if (StringUtils.hasText(jobName)) {
       runner.setJobName(jobName);
    }
    return runner;
}
```

- `@ConditionalOnProperty(prefix = "spring.batch.job", name = "enabled", havingValue = "true", matchIfMissing = true)`
  - `spring.batch.job.enabled` 프로퍼티가 `true`인 경우 `JobLauncherApplicationRunner` 빈을 자동 등록
  - `matchIfMissing = true` 옵션으로 인해 별도로 프로퍼티를 설정하지 않아도 기본값 `true`가 적용
- 생성자에 필수 코어 컴포넌트(`JobLauncher`, `JobExplorer`, `JobRepository`)를 전달
- `properties.getJob().getName()`으로 `jobName`을 추출해 `setJobName()`에 설정
  - 앞서 `--spring.batch.job.name=brutalizedSystemJob`으로 전달한 실행할 `Job`의 이름이 여기서 설정된다.

### BatchProperties

- `BatchAutoConfiguration` 선언부에 `@EnableConfigurationProperties(BatchProperties.class)`가 선언되어 있다.
  - `application.properties`, `application.yml`, 커맨드 라인 파라미터로 전달된 설정값을 자동으로 `BatchProperties` 객체에 매핑

```java
@ConfigurationProperties(prefix = "spring.batch")
public class BatchProperties {
    private final Job job = new Job(); // spring.batch.job.*

    public static class Job {
        private String name = ""; // spring.batch.job.name
    }
    /*...*/
}
```

- `@ConfigurationProperties(prefix = "spring.batch")`로 `spring.batch` 접두사를 가진 설정값이 이 클래스에 매핑
- `BatchAutoConfiguration`이 `JobLauncherApplicationRunner`를 생성할 때 `properties.getJob().getName()`으로 이 값을 가져와 설정

### JobExecutionExitCodeGenerator

```java
@Bean
@ConditionalOnMissingBean(ExitCodeGenerator.class)
public JobExecutionExitCodeGenerator jobExecutionExitCodeGenerator() {
    return new JobExecutionExitCodeGenerator();
}
```

- 배치 작업의 종료 상태에 따라 애플리케이션의 종료 코드를 생성하는 컴포넌트
- 배치 작업이 실패하면 JVM이 오류 코드와 함께 종료되도록 한다.

### DefaultBatchConfiguration

- `BatchAutoConfiguration` 내부에 `DefaultBatchConfiguration`을 상속하는 `SpringBootBatchConfiguration` 클래스가 존재

```java
@Configuration(proxyBeanMethods = false)
static class SpringBootBatchConfiguration extends DefaultBatchConfiguration {
    /*...*/
}
```

- `DefaultBatchConfiguration`은 Spring Batch의 모든 핵심 인프라 컴포넌트를 생성하고 구성하는 역할
- 다음 컴포넌트들을 자동으로 생성하여 애플리케이션 컨텍스트에 등록한다.
  - `JobRepository`, `JobExplorer`, `JobLauncher`, `JobRegistry`, `JobOperator`, `JobRegistryBeanPostProcessor`
  - `StepScope`, `JobScope`

```java
@Configuration(proxyBeanMethods = false)
@Import(ScopeConfiguration.class)
public class DefaultBatchConfiguration implements ApplicationContextAware {

    @Bean
    public JobRepository jobRepository() throws BatchConfigurationException { /*...*/ }

    @Bean
    public JobLauncher jobLauncher(JobRepository jobRepository) throws BatchConfigurationException { /*...*/ }

    @Bean
    public JobExplorer jobExplorer() throws BatchConfigurationException { /*...*/ }

    @Bean
    public JobRegistry jobRegistry() throws BatchConfigurationException { /*...*/ }

    @Bean
    public JobRegistrySmartInitializingSingleton jobRegistrySmartInitializingSingleton(JobRegistry jobRegistry) throws BatchConfigurationException { /*...*/ }
}
```

### protected 메서드를 통한 커스터마이징

- 빈 생성 메서드들은 내부적으로 의존성 구성을 위해 다른 메서드를 호출한다.
- 이 내부 메서드들이 `protected`로 선언되어 있어 상속을 통한 커스터마이징이 가능하다.

```java
protected DataSource getDataSource() { /*...*/ }
protected PlatformTransactionManager getTransactionManager() { /*...*/ }
protected String getTablePrefix() { /*...*/ }
protected TaskExecutor getTaskExecutor() { /*...*/ }
```

- `DefaultBatchConfiguration`을 상속한 `@Configuration` 클래스를 만들고 필요한 `protected` 메서드만 오버라이드하면 된다.

```java
@Configuration
public class KillBatchCustomConfiguration extends DefaultBatchConfiguration {
    @Override
    protected ExecutionContextSerializer getExecutionContextSerializer() {
        return new Jackson2ExecutionContextStringSerializer(); // 기본 직렬화 대신 JSON 직렬화
    }
}
```

### @EnableBatchProcessing

- `DefaultBatchConfiguration` 상속 없이 배치 코어 컴포넌트를 자동 구성할 수 있는 어노테이션

```java
// DefaultBatchConfiguration 상속 방식
@Configuration
public class BatchConfig extends DefaultBatchConfiguration { /*...*/ }

// @EnableBatchProcessing 방식
@Configuration
@EnableBatchProcessing
public class BatchConfig { /*...*/ }
```

- `@EnableBatchProcessing` 내부를 살펴보면 `~Ref`로 끝나는 속성들이 정의되어 있다.
  - 배치 코어 컴포넌트 구성에 사용할 빈 이름을 지정하는 용도

```java
@Import({ BatchRegistrar.class, ScopeConfiguration.class /*...*/ })
public @interface EnableBatchProcessing {
    String dataSourceRef() default "dataSource";
    String transactionManagerRef() default "transactionManager";
    String executionContextSerializerRef() default "executionContextSerializer";
    /*...*/
}
```

- 핵심은 `@Import`로 가져오는 `BatchRegistrar`
  - `@EnableBatchProcessing` 어노테이션 정보를 읽어 배치 코어 컴포넌트 빈들을 동적으로 등록

```java
class BatchRegistrar implements ImportBeanDefinitionRegistrar {
    @Override
    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {
        EnableBatchProcessing batchAnnotation = importingClassMetadata.getAnnotations()
            .get(EnableBatchProcessing.class)
            .synthesize();

        registerJobRepository(registry, batchAnnotation);
        registerJobExplorer(registry, batchAnnotation);
        registerJobLauncher(registry, batchAnnotation);
        registerJobRegistry(registry);
        /*...*/
    }
}
```

- 각 `register~` 메서드는 `@EnableBatchProcessing`의 `~Ref` 속성을 사용해 빈을 동적으로 구성하고 등록
- 커스터마이징 방식이 `DefaultBatchConfiguration`과 다르다.
  - `DefaultBatchConfiguration`: `protected` 메서드 오버라이드
  - `@EnableBatchProcessing`: 커스텀 빈을 정의하고 어노테이션 속성에 빈 이름을 지정
  - `~Ref` 속성에는 기본값이 있으므로 기본 이름과 동일한 빈을 등록하면 속성 지정 없이도 커스터마이징 가능

```java
@Configuration
@EnableBatchProcessing(executionContextSerializerRef = "jacksonExecutionContextSerializer")
public class BatchConfig {
    @Bean
    public ExecutionContextSerializer jacksonExecutionContextSerializer() {
        return new Jackson2ExecutionContextStringSerializer();
    }
}
```

- `DefaultBatchConfiguration`과 `@EnableBatchProcessing` 모두 `ScopeConfiguration`을 `@Import`한다.

### ScopeConfiguration

- `DefaultBatchConfiguration`과 `@EnableBatchProcessing`이 공통으로 `@Import`하는 클래스
- `StepScope`와 `JobScope` 빈을 등록한다.

```java
@Configuration(proxyBeanMethods = false)
public class ScopeConfiguration {
    private static final StepScope stepScope;
    private static final JobScope jobScope;

    static {
       jobScope = new JobScope();
       jobScope.setAutoProxy(false);

       stepScope = new StepScope();
       stepScope.setAutoProxy(false);
    }

    @Bean
    public static StepScope stepScope() { return stepScope; }

    @Bean
    public static JobScope jobScope() { return jobScope; }
}
```

- 실제 Spring 커스텀 스코프로의 등록은 공통 부모 클래스인 `BatchScopeSupport`의 `postProcessBeanFactory()`에서 수행
  - `beanFactory.registerScope(name, this)`
- 빈에 배치 스코프를 선언하면 Spring은 프록시를 생성한다.
  - 프록시가 실제 빈을 조회할 때 `JobScope`/`StepScope`의 `get()` → `getContext()`가 호출된다.

```java
private StepContext getContext() {
    StepContext context = StepSynchronizationManager.getContext();
    if (context == null) {
       throw new IllegalStateException("No context holder available for step scope");
    }
    return context;
}
```

- `StepSynchronizationManager.getContext()`는 `AbstractStep.execute()`에서 `register()`로 등록했던 `StepContext`를 반환한다.
  - `register` 시점에 현재 스레드의 `ThreadLocal`에 `StepExecution`과 `StepContext`가 바인딩
- 즉 "스코프 활성화"란 `StepSynchronizationManager`(`JobSynchronizationManager`)에서 유효한 컨텍스트를 가져올 수 있는 상태를 의미한다.
  - `StepContext`가 `null` → 아직 `Step`이 실행되지 않은 상태 → 예외 발생
  - `StepContext`가 `null`이 아님 → `Step`이 실행 중이며 `StepScope`가 활성화된 상태

### JobContext/StepContext - Late-Binding

- `StepContext`는 단순한 스코프 활성화 지표가 아니라 런타임 배치 정보를 담고 있다.

```java
public Map<String, Object> getStepExecutionContext() { /*...*/ }

public Map<String, Object> getJobExecutionContext() { /*...*/ }

public Map<String, Object> getJobParameters() { /*...*/ }
```

- SpEL 표현식과 `StepContext` 메서드의 매핑 관계:

| SpEL 표현식 | StepContext 메서드 |
|---|---|
| `#{jobParameters}` | `getJobParameters()` |
| `#{stepExecutionContext}` | `getStepExecutionContext()` |
| `#{jobExecutionContext}` | `getJobExecutionContext()` |

- `StepScope.resolveContextualObject()`가 이 연결을 담당한다.

```java
@Override
public Object resolveContextualObject(String key) {
    StepContext context = getContext();
    return new BeanWrapperImpl(context).getPropertyValue(key);
}
```

- `#{jobParameters['chaos']}`의 실행 흐름:
  1. SpEL 엔진이 `resolveContextualObject("jobParameters")` 호출
  2. `StepContext`를 확보하고 `BeanWrapperImpl`으로 프로퍼티 접근
  3. `stepContext.getJobParameters()`가 호출되어 `Map<String, Object>` 반환
  4. 반환된 `Map`에서 `['chaos']` 키로 값 추출

- `StepContext`에는 이 외에도 `getStepName()`, `getJobName()`, `getJobInstanceId()`, `getSystemProperties()` 등이 정의되어 있다.

```java
@Value("#{stepName}") String stepName,
@Value("#{jobName}") String jobName,
@Value("#{jobInstanceId}") Long jobInstanceId,
@Value("#{systemProperties['os.name']}") String osName
```

> `@JobScope` 빈에서는 `stepName`, `jobInstanceId`를 조회할 수 없다. `JobScope`는 `StepContext`가 아닌 `JobContext`를 사용하기 때문이다.

## BatchAutoConfiguration 비활성화

```java
@ConditionalOnMissingBean(value = DefaultBatchConfiguration.class, annotation = EnableBatchProcessing.class)
public class BatchAutoConfiguration
```

- 다음의 경우 `BatchAutoConfiguration`이 비활성화된다.
  - `DefaultBatchConfiguration`을 상속한 커스텀 컨피규레이션 클래스를 등록하는 경우
  - `@EnableBatchProcessing` 어노테이션을 사용하는 경우
- 비활성화되면 자동 구성 기능들이 모두 사용 불가능해진다.
  - `BatchProperties`, `JobLauncherApplicationRunner`, `BatchDataSourceScriptDatabaseInitializer` 등
  - 필요한 컴포넌트들을 직접 수동으로 등록해야 한다.

### SpringBootBatchConfiguration

- `BatchAutoConfiguration`은 `DefaultBatchConfiguration`을 상속한 `SpringBootBatchConfiguration`을 자동으로 빈으로 등록한다.
  - 별도의 구성 없이도 `JobRepository`, `JobLauncher`, `JobExplorer` 등을 사용할 수 있었던 이유

  
- 이를 활용해 `DefaultBatchConfiguration`의 `protected` 메서드들을 오버라이드
  - 개발자가 `DefaultBatchConfiguration`을 직접 상속하지 않아도 원하는 부분만 커스터마이징 가능

```java
// DefaultBatchConfiguration 직접 상속 없이 빈만 정의하면 자동 적용
@Configuration
public class KillBatchCustomConfiguration {
    @Bean
    public ExecutionContextSerializer executionContextSerializer() {
        return new Jackson2ExecutionContextStringSerializer();
    }
}
```

- `ExecutionContextSerializer` 빈만 정의해도 `SpringBootBatchConfiguration`에 의해 자동으로 적용된다.
- `BatchAutoConfiguration`의 다른 자동 구성 기능(`JobLauncherApplicationRunner` 등)도 그대로 유지된다.
