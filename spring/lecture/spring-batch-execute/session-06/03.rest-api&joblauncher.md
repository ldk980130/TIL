# REST API를 통한 Job 실행과 JobOperator

- 커맨드라인 말고도 `Job`을 실행할 수 있다.
    - `JobLauncher`를 실행하는 REST API를 통한 `Job` 제어
    - `JobOperator` 활용으로 Job 중지와 재시작 관리

> 웹 환경을 구성하는 경우 application.yml에 `spring.batch.job.enabled` 프로퍼티를 `false`로 설정함으로써 애플리케이션 시작 시 `Job` 자동 실행을 막을 수 있다. `false`인 경우 `JobLauncherApplicationRunner`가 자동 구성 되지 않는다.
>

## JobLauncher를 활용한 REST API 구현

### REST API 컨트롤러 예제

```java
@PostMapping("/{jobName}/start")
public ResponseEntity<String> launchJob(@PathVariable String jobName) throws Exception {
    Job job = jobRegistry.getJob(jobName); // JobRegistry에서 이름으로 Job 조회

    JobParameters jobParameters = new JobParametersBuilder(jobExplorer)
            .getNextJobParameters(job).toJobParameters(); // 이전 실행 이력 기반으로 다음 파라미터 생성

    JobExecution execution = jobLauncher.run(job, jobParameters); // Job 실행
    return ResponseEntity.ok("Job launched with ID: " + execution.getId());
}
```

- `JobLauncherApplicationRunner`가 내부적으로 수행하던 로직과 유사
- 커맨드라인과 웹 요청 모두 결국 동일한 배치 코어 엔진을 활용하는 서로 다른 진입점일 뿐
  - `JobLauncher`: 실제 `Job` 실행을 담당하는 진입점
  - `JobExplorer`: 이전 실행 이력을 바탕으로 다음 `JobParameters`를 생성
  - `JobRegistry`: 등록된 모든 `Job`들을 이름으로 조회하는 중앙 집중식 저장소

### 비동기 TaskExecutor 설정

- 기본적으로 `TaskExecutorJobLauncher`는 동기 방식의 `SyncTaskExecutor`를 사용
  - 배치 작업이 완료될 때까지 요청 스레드가 블로킹됨
- REST API 환경에서는 비동기 방식으로 변경해야 한다.

```java
@Configuration
public class BatchCustomConfiguration {
    @Bean
    @BatchTaskExecutor
    public TaskExecutor taskExecutor() {
        return new SimpleAsyncTaskExecutor(); // 비동기 실행
    }
}
```

- `@BatchTaskExecutor`로 등록하면 Spring Boot가 자동으로 `JobLauncher`에 주입
- REST API 호출 시 즉시 응답을 받고, 배치 작업은 별도 스레드에서 실행

### 실행 테스트

```
curl -X POST http://localhost:8080/api/jobs/brutalizedSystemJob/start
```

```
Job launched with ID: 1
```

- 반환된 `JobExecution` ID는 메타데이터 저장소의 고유 식별자로, 실행 상태 조회나 제어에 사용
- 단, `JobLauncher`만으로는 `Job` 시작만 가능하고 중지/재시작/모니터링 등 정교한 제어에는 한계가 있다.
