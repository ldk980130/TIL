# REST API를 통한 Job 실행과 JobOperator

- 커맨드라인 말고도 `Job`을 실행할 수 있다.
    - `JobLauncher`를 실행하는 REST API를 통한 `Job` 제어
    - `JobOperator` 활용으로 Job 중지와 재시작 관리

> 웹 환경을 구성하는 경우 application.yml에 `spring.batch.job.enabled` 프로퍼티를 `false`로 설정함으로써 애플리케이션 시작 시 `Job` 자동 실행을 막을 수 있다. `false`인 경우 `JobLauncherApplicationRunner`가 자동 구성 되지 않는다.
>

## JobLauncher를 활용한 REST API 구현

### REST API 컨트롤러 예제

```java
@PostMapping("/{jobName}/start")
public ResponseEntity<String> launchJob(@PathVariable String jobName) throws Exception {
    Job job = jobRegistry.getJob(jobName); // JobRegistry에서 이름으로 Job 조회

    JobParameters jobParameters = new JobParametersBuilder(jobExplorer)
            .getNextJobParameters(job).toJobParameters(); // 이전 실행 이력 기반으로 다음 파라미터 생성

    JobExecution execution = jobLauncher.run(job, jobParameters); // Job 실행
    return ResponseEntity.ok("Job launched with ID: " + execution.getId());
}
```

- `JobLauncherApplicationRunner`가 내부적으로 수행하던 로직과 유사
- 커맨드라인과 웹 요청 모두 결국 동일한 배치 코어 엔진을 활용하는 서로 다른 진입점일 뿐
  - `JobLauncher`: 실제 `Job` 실행을 담당하는 진입점
  - `JobExplorer`: 이전 실행 이력을 바탕으로 다음 `JobParameters`를 생성
  - `JobRegistry`: 등록된 모든 `Job`들을 이름으로 조회하는 중앙 집중식 저장소

### 비동기 TaskExecutor 설정

- 기본적으로 `TaskExecutorJobLauncher`는 동기 방식의 `SyncTaskExecutor`를 사용
  - 배치 작업이 완료될 때까지 요청 스레드가 블로킹됨
- REST API 환경에서는 비동기 방식으로 변경해야 한다.

```java
@Configuration
public class BatchCustomConfiguration {
    @Bean
    @BatchTaskExecutor
    public TaskExecutor taskExecutor() {
        return new SimpleAsyncTaskExecutor(); // 비동기 실행
    }
}
```

- `@BatchTaskExecutor`로 등록하면 Spring Boot가 자동으로 `JobLauncher`에 주입
- REST API 호출 시 즉시 응답을 받고, 배치 작업은 별도 스레드에서 실행

### 실행 테스트

```
curl -X POST http://localhost:8080/api/jobs/brutalizedSystemJob/start
```

```
Job launched with ID: 1
```

- 반환된 `JobExecution` ID는 메타데이터 저장소의 고유 식별자로, 실행 상태 조회나 제어에 사용
- 단, `JobLauncher`만으로는 `Job` 시작만 가능하고 중지/재시작/모니터링 등 정교한 제어에는 한계가 있다.

## JobOperator

- `JobLauncher`보다 한 단계 높은 수준의 추상화를 제공하는 운영 인터페이스
- `Job`의 시작, 중지, 재시작 등 배치 작업의 전체 생명주기를 관리

```java
public interface JobOperator {
    Long start(String jobName, Properties parameters);     // Job 시작
    boolean stop(long executionId);                        // Job 중지 요청
    Long restart(long executionId);                        // 실패/중지된 Job 재시작
    Long startNextInstance(String jobName);                // 다음 인스턴스 시작
    JobExecution abandon(long jobExecutionId);             // Job 포기(재시작 불가 처리)
    Set<Long> getRunningExecutions(String jobName);        // 실행 중인 Job 조회
    String getSummary(long executionId);                   // 실행 요약 정보
    Map<Long, String> getStepExecutionSummaries(long executionId); // Step 실행 요약
    Set<String> getJobNames();                             // 등록된 Job 이름 목록
    // ...
}
```

### 주요 메서드

- `start(jobName, parameters)`
  - `JobRegistry`에서 `Job`을 조회하고 `JobParameters`를 변환하여 `JobLauncher.run()`을 호출
  - `JobParametersIncrementer`를 자동 처리하지 않으므로 매번 다른 파라미터를 직접 전달해야 한다.
- `stop(executionId)`
  - `JobExecution`의 `BatchStatus`를 `STOPPING`으로 변경
  - 실제 중지는 `Step`이 다음 청크 경계에서 상태를 확인한 후 이루어지므로 즉시 중지되지는 않는다.
- `restart(executionId)`
  - 중지/실패한 `JobExecution`을 기반으로 `Job`을 재시작
  - 이전 `ExecutionContext`를 통해 중단된 지점부터 계속 실행하며, 새 `JobExecution` ID를 반환
- `startNextInstance(jobName)`
  - `JobParametersIncrementer`를 사용해 자동으로 증분된 파라미터로 새 `JobInstance`를 시작
- `abandon(executionId)`
  - `JobExecution`의 상태를 `ABANDONED`로 변경
  - `ABANDONED` 상태의 `Step`은 재시작 시에도 실행되지 않는다.
- `getRunningExecutions(jobName)` - 현재 실행 중인 `JobExecution` ID 목록 조회
- `getSummary(executionId)` - `JobExecution`의 요약 정보를 문자열로 반환
- `getStepExecutionSummaries(executionId)` - 해당 `JobExecution`에 포함된 각 `StepExecution`의 요약 정보 조회
