# REST API를 통한 Job 실행과 JobOperator

- 커맨드라인 말고도 `Job`을 실행할 수 있다.
    - `JobLauncher`를 실행하는 REST API를 통한 `Job` 제어
    - `JobOperator` 활용으로 Job 중지와 재시작 관리

> 웹 환경을 구성하는 경우 application.yml에 `spring.batch.job.enabled` 프로퍼티를 `false`로 설정함으로써 애플리케이션 시작 시 `Job` 자동 실행을 막을 수 있다. `false`인 경우 `JobLauncherApplicationRunner`가 자동 구성 되지 않는다.
>

## JobLauncher를 활용한 REST API 구현

### REST API 컨트롤러 예제

```java
@PostMapping("/{jobName}/start")
public ResponseEntity<String> launchJob(@PathVariable String jobName) throws Exception {
    Job job = jobRegistry.getJob(jobName); // JobRegistry에서 이름으로 Job 조회

    JobParameters jobParameters = new JobParametersBuilder(jobExplorer)
            .getNextJobParameters(job).toJobParameters(); // 이전 실행 이력 기반으로 다음 파라미터 생성

    JobExecution execution = jobLauncher.run(job, jobParameters); // Job 실행
    return ResponseEntity.ok("Job launched with ID: " + execution.getId());
}
```

- `JobLauncherApplicationRunner`가 내부적으로 수행하던 로직과 유사
- 커맨드라인과 웹 요청 모두 결국 동일한 배치 코어 엔진을 활용하는 서로 다른 진입점일 뿐
  - `JobLauncher`: 실제 `Job` 실행을 담당하는 진입점
  - `JobExplorer`: 이전 실행 이력을 바탕으로 다음 `JobParameters`를 생성
  - `JobRegistry`: 등록된 모든 `Job`들을 이름으로 조회하는 중앙 집중식 저장소

### 비동기 TaskExecutor 설정

- 기본적으로 `TaskExecutorJobLauncher`는 동기 방식의 `SyncTaskExecutor`를 사용
  - 배치 작업이 완료될 때까지 요청 스레드가 블로킹됨
- REST API 환경에서는 비동기 방식으로 변경해야 한다.

```java
@Configuration
public class BatchCustomConfiguration {
    @Bean
    @BatchTaskExecutor
    public TaskExecutor taskExecutor() {
        return new SimpleAsyncTaskExecutor(); // 비동기 실행
    }
}
```

- `@BatchTaskExecutor`로 등록하면 Spring Boot가 자동으로 `JobLauncher`에 주입
- REST API 호출 시 즉시 응답을 받고, 배치 작업은 별도 스레드에서 실행

### 실행 테스트

```
curl -X POST http://localhost:8080/api/jobs/brutalizedSystemJob/start
```

```
Job launched with ID: 1
```

- 반환된 `JobExecution` ID는 메타데이터 저장소의 고유 식별자로, 실행 상태 조회나 제어에 사용
- 단, `JobLauncher`만으로는 `Job` 시작만 가능하고 중지/재시작/모니터링 등 정교한 제어에는 한계가 있다.

## JobOperator

- `JobLauncher`보다 한 단계 높은 수준의 추상화를 제공하는 운영 인터페이스
- `Job`의 시작, 중지, 재시작 등 배치 작업의 전체 생명주기를 관리

```java
public interface JobOperator {
    Long start(String jobName, Properties parameters);     // Job 시작
    boolean stop(long executionId);                        // Job 중지 요청
    Long restart(long executionId);                        // 실패/중지된 Job 재시작
    Long startNextInstance(String jobName);                // 다음 인스턴스 시작
    JobExecution abandon(long jobExecutionId);             // Job 포기(재시작 불가 처리)
    Set<Long> getRunningExecutions(String jobName);        // 실행 중인 Job 조회
    String getSummary(long executionId);                   // 실행 요약 정보
    Map<Long, String> getStepExecutionSummaries(long executionId); // Step 실행 요약
    Set<String> getJobNames();                             // 등록된 Job 이름 목록
    // ...
}
```

### 주요 메서드

- `start(jobName, parameters)`
  - `JobRegistry`에서 `Job`을 조회하고 `JobParameters`를 변환하여 `JobLauncher.run()`을 호출
  - `JobParametersIncrementer`를 자동 처리하지 않으므로 매번 다른 파라미터를 직접 전달해야 한다.
- `stop(executionId)`
  - `JobExecution`의 `BatchStatus`를 `STOPPING`으로 변경
  - 실제 중지는 `Step`이 다음 청크 경계에서 상태를 확인한 후 이루어지므로 즉시 중지되지는 않는다.
- `restart(executionId)`
  - 중지/실패한 `JobExecution`을 기반으로 `Job`을 재시작
  - 이전 `ExecutionContext`를 통해 중단된 지점부터 계속 실행하며, 새 `JobExecution` ID를 반환
- `startNextInstance(jobName)`
  - `JobParametersIncrementer`를 사용해 자동으로 증분된 파라미터로 새 `JobInstance`를 시작
- `abandon(executionId)`
  - `JobExecution`의 상태를 `ABANDONED`로 변경
  - `ABANDONED` 상태의 `Step`은 재시작 시에도 실행되지 않는다.
- `getRunningExecutions(jobName)` - 현재 실행 중인 `JobExecution` ID 목록 조회
- `getSummary(executionId)` - `JobExecution`의 요약 정보를 문자열로 반환
- `getStepExecutionSummaries(executionId)` - 해당 `JobExecution`에 포함된 각 `StepExecution`의 요약 정보 조회

### stop()과 restart() 동작 흐름

**stop() 호출 시**

- `JobExecution`의 `BatchStatus`가 `STOPPING`으로 변경되고 메타데이터 저장소에 반영
- 실행 중인 `Job`이 즉시 중지되는 것이 아니라, `Step`이 다음 청크 경계에서 상태를 확인한 후 중지
  - 현재 처리 중인 청크는 끝까지 완료된 후에 중지된다.
- 중지 완료 후 `STATUS`와 `EXIT_CODE`가 모두 `STOPPED`로 변경

**restart() 호출 시**

- 중지/실패한 `JobExecution`의 ID를 전달하면 새로운 `JobExecution`이 생성되어 재시작
- 이전 `ExecutionContext`에 저장된 진행 상태를 기반으로 중단된 지점부터 계속 실행

### 재시작 시 ItemReader의 동작 - AbstractItemCountingItemStreamItemReader

- 청크 단위 처리가 완료될 때마다 `update()`에서 현재까지 읽은 아이템 수를 `ExecutionContext`에 저장

```java
// AbstractItemCountingItemStreamItemReader.update()
executionContext.putInt(getExecutionContextKey(READ_COUNT), currentItemCount);
```

- 재시작 시 `open()`에서 저장된 위치를 읽어 `jumpToItem()`을 호출하여 중단 지점으로 이동

```java
// AbstractItemCountingItemStreamItemReader.open()
int itemCount = executionContext.getInt(getExecutionContextKey(READ_COUNT));
jumpToItem(itemCount);
currentItemCount = itemCount;
```

- 예: 청크 크기 3으로 6개 아이템 처리 중 첫 번째 청크(아이템 1~3) 완료 후 중지 → 재시작 시 4번째 아이템부터 읽기 시작

## JobOperator Job 중지 메커니즘

### SimpleJobOperator.stop()

- `JobExecution`을 찾아 `BatchStatus.STOPPING`으로 변경하고 메타데이터 저장소에 업데이트
- 실제로 `Job`을 즉시 중단시키는 것이 아니라, 중단 요청을 메타데이터에 기록하는 것에 불과

```java
// SimpleJobOperator.stop()
jobExecution.setStatus(BatchStatus.STOPPING);
jobRepository.update(jobExecution);
```

### 중지 요청의 감지 - SimpleJobRepository.checkForInterruption()

- 청크 처리가 완료되고 `JobRepository.update(stepExecution)`가 호출될 때 중지 요청을 감지

```java
// SimpleJobRepository.update()
public void update(StepExecution stepExecution) {
    // ...
    checkForInterruption(stepExecution); // 여기서 중지 요청 감지
}

// SimpleJobRepository.checkForInterruption()
private void checkForInterruption(StepExecution stepExecution) {
    JobExecution jobExecution = stepExecution.getJobExecution();
    jobExecutionDao.synchronizeStatus(jobExecution); // 메타데이터 저장소에서 최신 상태를 읽어옴
    if (jobExecution.isStopping()) {
        stepExecution.setTerminateOnly(); // terminateOnly 플래그 설정
    }
}
```

- `synchronizeStatus()`로 메타데이터 저장소에서 `JobExecution`의 최신 상태를 읽어옴
- `STOPPING` 상태를 감지하면 `StepExecution`의 `terminateOnly` 플래그를 `true`로 설정

### 실제 중단 처리 - ThreadStepInterruptionPolicy

- 청크 트랜잭션이 완료된 후 `doInChunkContext()`에서 `checkInterrupted()`가 호출됨
- `StepExecution.isTerminateOnly()`가 `true`이면 `JobInterruptedException`을 던짐

### 예외 전파와 상태 결정

- `JobInterruptedException`이 `AbstractStep.execute()`의 `catch` 절까지 전파

```java
// AbstractStep.determineBatchStatus()
private static BatchStatus determineBatchStatus(Throwable e) {
    if (e instanceof JobInterruptedException) {
        return BatchStatus.STOPPED;  // 일반 실패(FAILED)와 구분
    }
    return BatchStatus.FAILED;
}
```

- `JobInterruptedException`은 `FAILED`가 아닌 `STOPPED`로 처리됨
- `ExitStatus`도 `STOPPED`로 설정되며, `EXIT_MESSAGE`에 `JobInterruptedException` 클래스명이 기록

### Step에서 Job으로의 중단 전파

- `SimpleStepHandler.handleStep()`에서 `StepExecution`이 `STOPPED` 상태임을 감지

```java
// SimpleStepHandler.handleStep()
if (currentStepExecution.getStatus() == BatchStatus.STOPPING
        || currentStepExecution.getStatus() == BatchStatus.STOPPED) {
    execution.setStatus(BatchStatus.STOPPING);
    throw new JobInterruptedException("Job interrupted by step execution");
}
```

- `JobExecution`의 상태를 `STOPPING`으로 설정하고 다시 `JobInterruptedException`을 던짐
- 이 예외가 `AbstractJob.execute()`까지 전파되어 `JobExecution`의 상태가 최종적으로 `STOPPED`로 확정
