# Job과 메타데이터 저장소

## Spring Batch의 메타데이터 저장소

- 배치 작업이 견고해지려면 다음 작업들이 필요하다.
    - 어떤 작업이 실행되었는지 추적할 수 있어야 한다.
    - 해당 작업의 진행에 관한 상태를 저장할 수 있어야 한다.
    - 실패 작업을 실패 지점부터 재시작할 수 있어야 한다.
- Spring Batch는 배치 실행에 관한 메타데이터를 저장한다.
    - 작업의 실행 상태
    - 처리 항목 수
    - 실패 지점 등

## Spring Batch 핵심 도메인

### JobInstance

- `JobInstance`는 `Job`의 논리적 실행 단위를 의미한다.
- 동일한 `Job`을 실행하더라도 처리하는 데이터가 다르면 별개의 `JobInstance`다.
    - ex) 2024년 1월 매출 정산과 2월 매출 정산은 다른 `JobInstance`다.
- Spring Batch는 `JobParameters`를 통해 `JobInstance`를 구분한다.

### JobParameters

- `JobParameters`는 동일한 `Job`을 서로 다른 `JobInstance`로 구분하는 핵심 요소다
- `Job` + `JobParameters` = `JobInstance`

### JobExecution

- `JobExecution`은 `JobInstance`의 실제 실행 시도를 뜻한다.
    - 같은 `JobInstance`(ex. 4월 정산 배치)라도 여러 번 실행될 수 있다.
- `JobExecution`에는 다음 정보들이 포함된다.
    - 현재 상태 (`COMPLETED`,`FAILED`,`STOPPED`등)
    - 시작 시간
    - 종료 시간
    - 종료 코드
    - 실패 원인

### BatchStatus

- `COMPLETED`: 배치 작업 완료
- `STARTING`: 배치 작업이 실행되기 직전
- `STARTED`: 배치 작업이 실행 중
- `STOPPING`: 배치 작업이 중지 요청을 받아 중지 진행 중
- `STOPPED`: 배치 작업이 요청에 의해 중지된 상태
- `FAILED`: 배치 작업이 실행 중 오류로 실패
- `ABANDONED`: 배치 작업이 비정상 종료되어 재시작할 수 없는 상태
- `UNKNOWN`: 배치 작업의 상태를 확인할 수 없는 불확실한 상태

## JobInstance 재실행 제한

- Spring Batch는 한 번 완료된 `JobInstance`는 재실행할 수 없도록 제한한다.
  - 동일한 `JobParameters`로 성공적으로 완료된 `Job`을 다시 실행하면 예외가 발생한다.
  - 동일한 작업이 중복 실행되어 발생할 수 있는 부작용을 방지하기 위한 안전장치

### 재실행 검사 메커니즘

- Spring Batch는 `Job` 실행 시 해당 `JobInstance`가 과거에 성공적으로 완료된 적이 있는지 검사한다.
  - `JobInstance`의 `JobExecution` 중 `BatchStatus`가 `COMPLETED`인 것이 존재하는지 확인
- `COMPLETED` 상태의 `JobExecution`이 존재하면 `JobInstanceAlreadyCompleteException`을 발생시킨다.
- `COMPLETED` 상태의 `JobExecution`이 없는 경우에는 해당 `JobInstance`를 다시 실행할 수 있다.
  - `FAILED` 상태로 종료된 `JobInstance`는 재실행 가능하다.

### 메타데이터 테이블 초기화 설정

- 다음 설정은 애플리케이션 실행 시마다 메타데이터 테이블을 초기화한다.

```yaml
spring:
  sql:
    init:
      mode: always
      schema-locations: classpath:org/springframework/batch/core/schema-drop-postgresql.sql

```

- 이 설정이 적용되면 매번 실행할 때마다 메타데이터 테이블이 초기화되어 이전 실행 이력이 사라진다.
  - Spring Batch가 이전 실행을 기억하지 못하므로 동일한 파라미터로 여러 번 실행이 가능해진다.
- 운영 환경에서는 이 설정을 사용하면 안 된다.


### **JobParametersIncrementer**

- 동일 `Job`을 여러 번 실행할 수 있게 하는 특수 컴포넌트
- 입력으로 `JobParameters`를 받아 약간 변형된 새로운 `JobParameters`를 반환한다.
  - 때문에 다른 JobInstance로 인식

```java
public interface JobParametersIncrementer {  
   JobParameters getNext(@Nullable JobParameters parameters);  
}
```

- `RunIdIncrementer`
  - `JobParametersIncrementer`의 대표적인 구현체
  - `run.id`라는 이름의 파라미터 값을 증가시키며 파라미터를 변형시킨다.

```java
@Bean
public Job brutalizedSystemJob() {
    return new JobBuilder("brutalizedSystemJob", jobRepository)
            .incrementer(new RunIdIncrementer())
            .start(brutalizedSystemStep())
            .build();
}
```

### JobParameter의 identifying 속성

- `JobParameters`는 단순한 데이터 전달체가 아니라 `JobInstance`를 식별하는 핵심 키로 작동하지만 모든 파라미터가 식별 용도로 사용되는 것은 아니다.
- `identifying` 속성이 해당 파라미터가 `JobInstance` 식별에 사용되는지 여부를 결정한다.

```text
{'chaos':'{value=true, type=class java.lang.Boolean, identifying=true}',
 'run.id':'{value=2, type=class java.lang.Long, identifying=true}'}
```

- 기본적으로 모든 `JobParameter`는 `identifying=true`로 설정된다.

- identifying=false가 필요한 경우
  - 파라미터가 실행마다 달라져도 같은 `JobInstance`로 취급해야 할 경우
  - 작업의 논리적 정체성을 바꾸지 않는 파라미터들에 적용
      - 로깅 수준 제어: `verbose=true`
      - 성능 튜닝 변수: `chunk.size=1000`
      - 출력 경로 지정: `output.path=/tmp/batch/report`

- 커맨드 라인에서 설정하는 방법

```bash
./gradlew bootRun --args='--spring.batch.job.name=brutalizedSystemJob chaos=true,java.lang.Boolean verbose=true,java.lang.String,false'
```

- `verbose=true,java.lang.String,false`에서 마지막 `false`가 `identifying` 속성이다.

- 주의사항
  - 핵심 데이터 식별자를 `identifying=false`로 설정하면 같은 `JobInstance`로 인식되어 재실행이 불가능해진다.
  - 단순 옵션을 `identifying=true`로 유지하면 불필요하게 중복 실행이 가능해진다.

### restartable 설정
- Spring Batch의 `Job`은 기본적으로 실패한 경우 재시작이 가능하다.
- 비즈니스적인 이유로 작업이 한 번 실패하면 다시는 실행되지 않도록 해야 할 수도 있다.
- `preventRestart()`
    - `JobBuilder`의 메서드로, 설정된 `Job`이 재시작 불가능하도록 만든다.
    - `Job`이 실패한 후 다시 실행하려고 하면 `JobRestartException`을 발생시킨다.

```java
@Bean
public Job brutalizedSystemJob() {
    return new JobBuilder("brutalizedSystemJob", jobRepository)
            .start(brutalizedSystemStep())
            .preventRestart()
            .build();
}
```

- 주의사항
    - `preventRestart()` 설정이 적용된 `Job`은 어떤 이유로든 실패하면 같은 파라미터로는 다시 실행할 수 없다.
    - `RunIdIncrementer`와 함께 사용 시 `preventRestart()` 설정이 의미가 없어진다.
        - `RunIdIncrementer`는 매번 다른 `run.id` 값을 생성하여 새로운 `JobInstance`를 만든다.
        - "실패한 작업의 재시작"이 아닌 "새로운 작업의 시작"으로 인식되기 때문

## StepExecution

- `StepExecution`은 단일 `Step`의 실행 시도를 나타내는 객체다.
- 하나의 `Job`이 여러 `Step`으로 구성될 수 있기 때문에, 하나의 `JobExecution`은 여러 개의 `StepExecution`을 포함할 수 있다.

```text
JobExecution {
    StepExecution("step1")
    StepExecution("step2")
    StepExecution("step3")
}
```

- `StepExecution`은 `Step` 실행 시 생성되며, 해당 `Step`이 실제로 시작될 때만 생성된다.
  - 첫 번째 `Step`이 실패하면 두 번째 `Step`은 실행되지 않으므로 두 번째 `Step`에 대한 `StepExecution`도 생성되지 않는다.

- `StepExecution`은 다음과 같은 주요 실행 정보를 포함한다.
  - 현재 상태: `Step`이 현재 어떤 상태인지를 나타내는 `BatchStatus`
  - 읽기/쓰기 카운트: 성공적으로 읽거나 쓴 아이템의 수
  - 커밋/롤백 카운트: 트랜잭션 처리 횟수
  - 스킵 카운트: 청크 처리 중 건너뛴 아이템의 수
  - 시작/종료 시간: `Step` 실행의 시간적 정보
  - 종료 코드: `Step` 실행의 최종 결과 코드
  - 예외 정보: 실패 시 발생한 오류에 대한 상세 정보

### JobExecution과 StepExecution의 BatchStatus

- `StepExecution`에도 현재 실행 상태를 의미하는 `BatchStatus`가 사용된다.
  - `StepExecution`도 `JobExecution`과 마찬가지로 실행 중 다양한 상태를 가질 수 있기 때문
- `JobExecution`의 최종 `BatchStatus`는 해당 `JobExecution`에서 가장 마지막에 실행된 `StepExecution`의 `BatchStatus` 값을 기준으로 결정된다.

### 실패와 재시작 시 StepExecution의 동작

- `Step`을 다시 실행할 때 새로운 `StepExecution`이 생성된다.
  - `StepExecution`이 `JobExecution`에 종속되어 있기 때문
  - 새로운 `JobExecution`이 생성되면 그에 속한 모든 `StepExecution`도 새롭게 생성된다.

- 실패한 `Job`을 재시작할 때는 실패한 `Step`부터 다시 시작된다.
  - 이미 성공적으로 완료된 `Step`은 재실행되지 않으므로 새로운 `StepExecution`도 생성되지 않는다.

```text
JobExecution#1 (FAILED) {
    StepExecution#1 ("step1", COMPLETED)
    StepExecution#2 ("step2", FAILED)    // 실패
}

JobExecution#2 (COMPLETED) {
    // StepExecution#1 ("step1")은 이미 성공했으므로 다시 생성되지 않음
    StepExecution#3 ("step2", COMPLETED) // 실패한 step2부터 재시작
}
```

- `StepExecution` 정보는 단순한 로깅 이상의 가치가 있다.
  - 성능 모니터링: 각 `Step`의 처리 시간과 처리량을 분석하여 병목 지점 식별
  - 오류 패턴 분석: 특정 데이터나 조건에서 반복적으로 오류가 발생하는지 파악
  - 자원 할당 최적화: 읽기/쓰기/처리 비율을 분석하여 리소스 할당 조정


### ExecutionContext

- `ExecutionContext`
  - 배치 작업의 상태 정보를 저장하는 뎅터 컨테이너
  - Java의 `Map` 인터페이스를 구현히야 key-value 형태의 데이터를 관리한다.

```
// ExecutionContext 예시
ExecutionContext {
    "processingIndex": 42500,              // 마지막으로 처리한 항목 인덱스
    "totalAmount": 2750000.00,             // 중간 집계 결과
    "lastProcessedId": "TRX-20240315-789", // 마지막으로 처리한 거래 ID
}
```

- `ExecutionContext`의 두 가지 범위
  - `ExecutionContext`는 `JobExecution`, `StepExecution` 각각 별도로 존재한다.
  - 실제 메타데이터 저장소에서도 물리적으로 별도의 테이블 구조로 관리된다.
  - `JobExecution`의 `ExecutionContext`는 모든 `StepExecution`에서 접근 가능하지만, `StepExecution`의 `ExecutionContext`는 해당 `StepExecution` 내에서만 유효하다.

## 배치 메타데이터 테이블 구조

- Spring Batch 메타데이터는 6개의 테이블에서 관리된다.
  - `BATCH_JOB_INSTANCE`
  - `BATCH_JOB_EXECUTION`
  - `BATCH_JOB_EXECUTION_PARAMS`
  - `BATCH_JOB_EXECUTION_CONTEXT`
  - `BATCH_STEP_EXECUTION`
  - `BATCH_STEP_EXECUTION_CONTEXT`

### BATCH_JOB_INSTANCE

- 배치 작업의 논리적 실행 단위인 `JobInstance`를 저장하는 테이블

| 컬럼명            | 설명                                   | 키 타입  |
|-----------------|---------------------------------------|---------|
| JOB_INSTANCE_ID | Job 인스턴스의 고유 식별자                  | PK      |
| JOB_NAME        | Job 이름. JobInstance 식별에 반드시 필요    |         |
| JOB_KEY         | JobParameters의 해시값                   |         |
| VERSION         | 낙관적 락(Optimistic Lock) 버전. JobInstance의 경우 항상 0으로 유지됨 |         |

- `JOB_NAME`과 `JOB_KEY` 컬럼에는 유니크 제약조건이 걸려있다.
  - 동일한 `Job` 이름과 파라미터 조합으로는 하나의 `JobInstance`만 존재할 수 있음
- `JobInstance`는 `Job`의 이름(`jobName`)과 해당 `JobInstance`에 속한 모든 실행 시도들(`jobExecutions`)을 포함

### BATCH_JOB_EXECUTION

- `JobInstance`의 실제 실행 시도를 나타내는 `JobExecution`을 저장하는 테이블

| 컬럼명            | 설명                                 | 키 타입   |
|------------------|------------------------------------|---------|
| JOB_EXECUTION_ID | 작업 실행의 고유 식별자                  | PK      |
| VERSION          | 낙관적 락 버전                        |         |
| JOB_INSTANCE_ID  | 연관된 JobInstance의 ID              | FK      |
| CREATE_TIME      | JobExecution 생성 시간               |         |
| START_TIME       | JobExecution 시작 시간               |         |
| END_TIME         | JobExecution 종료 시간               |         |
| STATUS           | JobExecution 현재 상태(BatchStatus)  |         |
| EXIT_CODE        | JobExecution 종료 코드               |         |
| EXIT_MESSAGE     | JobExecution 종료 메시지(오류 포함)     |         |
| LAST_UPDATED     | 마지막 업데이트 시간                    |         |

- `JOB_INSTANCE_ID` 컬럼이 FK로 지정되어 있다.
  - 하나의 `JobInstance`는 여러 번 실행될 수 있으므로 동일한 `JOB_INSTANCE_ID` 값을 갖는 여러 `BATCH_JOB_EXECUTION` 레코드가 존재할 수 있다.
- `VERSION` 컬럼은 동시성 제어를 위한 낙관적 락 메커니즘으로 사용된다.
  - 다른 스레드가 이미 이 레코드를 업데이트했다면 `VERSION` 컬럼으로 인해 `OptimisticLockingFailureException` 예외가 발생

- `JobExecution` 은 `JobParameters`, `JobInstance`와 같은 핵심 객체와 연결되어 있으며, 자신만의 `ExecutionContext`를 가진다.
- 하나의 `JobExecution`이 여러 개의 `StepExecution`을 포함

### BATCH_JOB_EXECUTION_PARAMS

- `JobParameters`를 저장하는 테이블

| 컬럼명            | 설명                          | 키 타입 |
|------------------|-----------------------------|---------|
| JOB_EXECUTION_ID | 작업 실행의 ID                 | FK      |
| PARAMETER_NAME   | 파라미터 이름                  |         |
| PARAMETER_TYPE   | 파라미터 타입                  |         |
| PARAMETER_VALUE  | 파라미터 값                    |         |
| IDENTIFYING      | JobInstance 식별에 사용 여부    |         |

- `IDENTIFYING` 컬럼은 해당 파라미터가 `JobInstance`를 식별하는 데 사용되는지 여부를(`Y` 또는 `N`).
- 이 테이블은 `JOB_INSTANCE_ID`가 아닌 `JOB_EXECUTION_ID`를 참조한다.

- `Job`을 실행할 때 여러 개의 `JobParameter`를 전달할 수 있다.
- `JobParameters` 객체 내부에서는 이를 `Map` 컬렉션으로 관리하지만, 데이터베이스에 저장될 때는 각 `JobParameter`가 테이블의 개별 레코드로 저장된다.

### BATCH_STEP_EXECUTION

- `StepExecution`을 저장하는 테이블

| 컬럼명              | 설명                                  | 키 타입  |
|-------------------|--------------------------------------|---------|
| STEP_EXECUTION_ID | StepExecution 고유 식별자               | PK      |
| VERSION           | 낙관적 락 버전                          |         |
| STEP_NAME         | Step 이름                             |         |
| JOB_EXECUTION_ID  | 연관된 JobExecution의 ID               | FK      |
| CREATE_TIME       | 실행 레코드 생성 시간                     |         |
| START_TIME        | StepExecution 시작 시간                |         |
| END_TIME          | StepExecution 종료 시간                |         |
| STATUS            | StepExecution의 현재 상태(BatchStatus)  |         |
| COMMIT_COUNT      | 커밋 횟수                              |         |
| READ_COUNT        | 읽은 아이템 수                          |         |
| FILTER_COUNT      | 필터링된 아이템 수                       |         |
| WRITE_COUNT       | 쓴 아이템 수                            |         |
| READ_SKIP_COUNT   | 읽기 건너뛴 수                          |         |
| WRITE_SKIP_COUNT  | 쓰기 건너뛴 수                          |         |
| PROCESS_SKIP_COUNT| 처리 건너뛴 수                          |         |
| ROLLBACK_COUNT    | 롤백 횟수                              |         |
| EXIT_CODE         | StepExecution 종료 코드                |         |
| EXIT_MESSAGE      | StepExecution 종료 메시지              |         |
| LAST_UPDATED      | 마지막 업데이트 시간                     |         |

- `JOB_EXECUTION_ID` 컬럼이 FK로 지정되어 있다.
  - `BATCH_JOB_EXECUTION` 테이블을 참조하며, 각 `StepExecution`이 어떤 `JobExecution`에 속하는지를 나타낸다.

- `JobExecution`과 마찬가지로 `StepExecution`도 자신만의 `ExecutionContext`를 가지고 있어, `Step` 단위로 상태를 저장하고 복원할 수 있다.

### BATCH_JOB_EXECUTION_CONTEXT & BATCH_STEP_EXECUTION_CONTEXT

- `JobExecution` 수준의 `ExecutionContext`는 `BATCH_JOB_EXECUTION_CONTEXT` 테이블에 저장
- `StepExecution` 수준의 `ExecutionContext`는 `BATCH_STEP_EXECUTION_CONTEXT` 테이블에 저장

| 컬럼명              | 설명                                | 키 타입   |
|--------------------|-----------------------------------|---------|
| JOB_EXECUTION_ID 또는 STEP_EXECUTION_ID | 각각 JobExecution 또는 StepExecution의 ID | PK, FK  |
| SHORT_CONTEXT      | 직렬화된 ExecutionContext의 문자열 버전 |         |
| SERIALIZED_CONTEXT | 전체 컨텍스트, 직렬화된 형태            |         |

- `ExecutionContext`의 데이터는 직렬화되어 문자열로 변환된다.
  - 직렬화된 문자열의 길이가 일정 기준(기본값 2500자)보다 짧으면 `SHORT_CONTEXT`에만 저장되고 `SERIALIZED_CONTEXT`는 `NULL`로 설정
  - 직렬화된 문자열이 기준 길이를 초과하면 `SHORT_CONTEXT`에는 잘린 버전(약 2492자 + "...")이 저장되고, 전체 내용은 `SERIALIZED_CONTEXT`에 CLOB 형태로 저장

## JobLauncher: 배치 작업의 시작점

- `JobLauncher`는 `Job`을 실행시키는 컴포넌트다.
- `Job`과 `JobParameters`를 받아 실행하고, 그 결과로 `JobExecution`을 반환한다.
- 기본 구현체는 `TaskExecutorJobLauncher`다.

### TaskExecutorJobLauncher.run() 메서드 분석

- `JobRepository`를 사용해 메타데이터 저장소로부터 가장 최근 `JobExecution`을 가져온다.

```java
JobExecution lastExecution = jobRepository.getLastJobExecution(job.getName(), jobParameters);
```

- `lastExecution`이 `null`이 아니라면 재시작 케이스다.
- 재시작 상황에서는 `Job`의 `restartable` 필드 값을 검사한다.
  - `JobBuilder.preventRestart()` 메서드를 호출한 경우 `JobRestartException` 발생

```java
if (lastExecution != null) {
    if (!job.isRestartable()) {
        throw new JobRestartException("JobInstance already exists and is not restartable");
    }
}
```

- `JobParametersValidator`를 사용해 `JobParameters`를 검증한다.
  - 잘못된 파라미터로 인한 불필요한 `JobExecution` 객체 생성을 방지

```java
job.getJobParametersValidator().validate(jobParameters);
jobExecution = jobRepository.createJobExecution(job.getName(), jobParameters);
```

- `JobRepository`의 `createJobExecution()` 메서드를 호출해 현재 실행에 대한 `JobExecution`을 생성한다.
  - 재시작 여부를 떠나 `JobExecution`은 항상 새로 만든다.

### SimpleJobRepository.createJobExecution() 분석

- 동일한 `jobName`과 `jobParameters`로 생성된 `JobInstance`가 있는지 찾아본다.

```java
public JobExecution createJobExecution(String jobName, JobParameters jobParameters) {
    JobInstance jobInstance = jobInstanceDao.getJobInstance(jobName, jobParameters);
    ExecutionContext executionContext;

    if (jobInstance != null) {
        // 재시작 케이스
    } else {
        // 첫 실행 케이스
    }
    ...
}
```

- 재시작 상황인 경우 (`jobInstance != null`)
  - 해당 `JobInstance`의 이전 실행 이력을 조회
  - 실행 이력이 전혀 없는데 `JobInstance`가 존재하면 비정상 상태이므로 `IllegalStateException`
  - 이전 실행 이력(`JobExecution`)들을 순회하며 `BatchStatus`를 검사
  - 이전 실행 이력이 `COMPLETED`이거나 `ABANDONED`인 경우 `JobInstanceAlreadyCompleteException`
  - 가장 최근 실행된 `JobExecution`의 `ExecutionContext`를 조회
- 첫 실행인 경우 (`jobInstance == null`)
  - `JobInstance`를 새로 생성하고 메타데이터 저장소에 저장
  - `ExecutionContext`도 빈(empty) 상태로 새로 생성


- `JobExecution` 생성 및 저장

```java
JobExecution jobExecution = new JobExecution(jobInstance, jobParameters);
jobExecution.setExecutionContext(executionContext);
jobExecution.setLastUpdated(LocalDateTime.now());

jobExecutionDao.saveJobExecution(jobExecution);
ecDao.saveExecutionContext(jobExecution);

return jobExecution;
```

- `JobExecution`을 초기화하고 메타데이터 저장소에 저장
  - `ExecutionContext`도 함께 저장

- `createJobExecution()` 메서드 정리
  - 이미 완료된 `JobInstance`의 재실행을 막고, 재시작 상황에서의 상태 복원까지 담당
  - 매번 새로운 `JobExecution`을 만들되, 재시작일 때는 이전 `ExecutionContext`를 그대로 사용
  - 모든 정보를 즉시 메타데이터 저장소에 기록
