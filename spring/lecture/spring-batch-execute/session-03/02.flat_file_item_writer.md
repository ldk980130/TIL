# FlatFileItemWriter

## FlatFileItemWriter

- 대량의 파일 쓰기 작업을 효율적으로 처리할 수 있다.
- `FlatFileItemReader`와는 반대로 도메인 객체를 문자열로 변환해서 쓴다.
- 파일 쓰기 작업은 크게 두 단계로 나뉜다.
    - 필드 추출 - `FieldExtrator`
    - 문자열 결합 - `LineAggregator`

## FieldExtractor

- 객체 `T`를 `Object`의 배열 형태로 반환한다.

```java
public interface FieldExtractor<T> {
    Object[] extract(T item);
}
```

- `FieldExtractor`도 스프링에서 기본 구현체를 제공한다.
    - `BeanWrapperFieldExtractor`
        - Java bean 객체로부터 필드를 추출
        - 객체 프로퍼티 이름을 기반으로 `getter` 메서드로 필드값을 추출
    - `RecordFieldExtractor`
        - Java Record 객체에서 필드를 추출
        - 레코드 컴포넌트의 accessor 메서드를 호출해 값을 가져온다.
    - 도메인 객체 타입에 따라 두 구현체 중 하나가 자동으로 선택된다.

## LineAggregator

- `T` 도메인 객체를 받아 문자열로 결합하여 반환한다.

```java
public interface LineAggregator<T> {
    String aggregate(T item);
}
```

- 파일 읽기 때와 마찬가지로 구분자 기반과 고정 길이 기반의 Aggregator가 기본적으로 존재한다.
    - `DelimitedLineAggregator`
    - `FormatterLineAggregator`
- `LineAggregator.aggregate()` 내부에서 `FieldExtractor`를 사용하는 구조기에 두 컴포넌트 모두 `T` 타입 객체를 파라미터로 받는다.
    - `LineAggregator`를 구현한 `ExtractorLineAggregator` 추상 클래스 내부에서 `FieldExtractor`를 사용한다.
    - `DelimitedLineAggregator`, `FormatterLineAggregator`은 `ExtractorLineAggregator`를 구현한다.

## 구분자 형식의 파일 쓰기

### FlatFileItemWriterBuilder

- reader 때와 마찬가지로 전문 빌더 클래스로 `FlatFileItemWriter`를 구성한다.

```kotlin
@Bean
@StepScope
fun deathNoteWriter(
    @Value("#{jobParameters['outputDir']}") outputDir: String,
): FlatFileItemWriter<DeathNote> =
    FlatFileItemWriterBuilder<DeathNote>()
        .name("deathNoteWriter")
        .resource(FileSystemResource("$outputDir/death_notes.csv"))
        .delimited()
        .delimiter(",")
        .sourceType(DeathNote::class.java)
        .names("victimId", "victimName", "executionDate", "causeOfDeath")
        .headerCallback { writer: Writer -> writer.write("처형ID,피해자명,처형일자,사인") }
        .build()
```

- `name()`
    - `FlatFileItemWriter`의 고유 이름 지정
- `resource()`
    - `WritableResource` ****타입의 리소스를 지정
    - 위 예제에선 잡 파라미터를 통해 파일 위치를 동적으로 결정
- `delimited()`
    - `LineAggregator` 구현체로 `DelimitedLineAggregator`가 지정된다.

> `FlatFileItemReaderBuilder`에선 `delimited`를 호출하면 `DelimitedLineTokenizer`가 지정되는 것과 유사
>

- `delimiter()`
    - 필드들을 이어붙일 때 사용할 구분자를 지정

- `FieldExtractor` 구성 방법
    - 직접 전달 방식
        - `FlatFileItemWriterBuilder`의 `fieldExtractor()` 메서드를 사용
        - 커스텀 `FieldExtractor`를 사용해야할 때 사용
    - 자동 구성 방식
        - `FlatFileItemWriterBuilder`의 `sourceType()` 메서드로 전달한 도메인 객체에 따라 자동 구성되는 방식
        - 자동 구성 방식에선 `BeanWrapperFieldExtractor`**,** `RecordFieldExtractor`만 지원한다.
        - 도메인 객체가 일반 자바빈 객체인 경우엔 `sourceType`을 호출하지 않아도 자동으로 `BeanWrapperFieldExtractor`가 선택된다.
- `names()`
    - 문자열로 변환할 객체 필드 이름을 지정
    - 이 메서드는 자동 구성 방식에서만 사용된다.
- `headerCallback()`
    - 파일에 헤더를 추가할 수 있도록 콜백을 설정
    - `FlatFileHeaderCallback`이 **전달된다.**
    - `FlatFileItemWriter` 초기화 시 호출되어 헤더를 작성한다.
    - 파일의 마지막에 푸터를 추가할 수 있는 `footerCallback()`도 있다.

### 커스텀 FieldExtractor 구성

- 타입 객체에서 특정 필드만 파일에 쓰고 싶다면 커스텀 `fieldExtractor`를 등록할 수 있다.
    - 커스텀 `fieldExtractor`를 등록하면 `sourceType`과 `names`는 무시되므로 제거하면 된다.

```kotlin
@Bean
@StepScope
fun deathNoteWriter(
    @Value("#{jobParameters['outputDir']}") outputDir: String,
): FlatFileItemWriter<DeathNote> =
    FlatFileItemWriterBuilder<DeathNote>()
        .name("deathNoteWriter")
        .resource(FileSystemResource("$outputDir/death_notes.csv"))
        .delimited()
        .delimiter(",")
        .fieldExtractor(fieldExtractor())
        .headerCallback { writer: Writer -> writer.write("처형ID,피해자명,처형일자,사인") }
        .build()
        
fun fieldExtractor(): FieldExtractor<DeathNote> =
    RecordFieldExtractor(DeathNote::class.java)
        .apply { setNames("victimId", "executionDate", "causeOfDeath") }
```

## 커스텀 포맷 형식으로 파일 쓰기

- 커스텀 포맷으로 데이터를 쓰려면 `FormatterLineAggregator`를 사용해야 한다.

```kotlin
@Bean
@StepScope
fun deathNoteFormatterLineWriter(
    @Value("#{jobParameters['outputDir']}") outputDir: String?,
): FlatFileItemWriter<DeathNote> =
    FlatFileItemWriterBuilder<DeathNote>()
        .name("deathNoteWriter")
        .resource(FileSystemResource("$outputDir/death_note_report.txt"))
        .formatted()
        .format("처형 ID: %s | 처형일자: %s | 피해자: %s | 사인: %s")
        .sourceType(DeathNote::class.java)
        .names("victimId", "executionDate", "victimName", "causeOfDeath")
        .headerCallback { writer: Writer -> writer!!.write("================= 처형 기록부 =================") }
        .footerCallback { writer: Writer -> writer!!.write("================= 처형 완료 ==================") }
        .build()
```

- `formatted()`
    - `LineAggregator` 구현체로 `FormatterLineAggregator`를 지정한다.
    - `FormatterLineAggregator` 동작 방식
        - `String customRecord = String.format("피해자: %s | 처형방식: %s", fields)`
- `format()`
    - `String.format`에서 사용하는 것과 동일한 포맷을 사용

## 파일 처리 옵션

- 지금까지의 방식으로 파일 처리를 실행하면 기존 파일에 새 파일이 덮어써져 버린다.
- `FlatFileItemWriterBuilder`에서 다음 옵션을 통해 어떻게 파일을 처리할지 조정할 수 있다.


- `shouldDeleteIfExists`
    - 기존 파일의 삭제 여부
    - default:  `true`
    - 이미 결과 파일이 있는데 `false`로 설정하면 `FlatFileItemWriter`는 예외를 던진다.
- `append`
    - 기존 파일에 데이터 덧붙이기 여부
    - default: `false`
    - `true`로 설정되면 `shouldDeleteIfExists`가 자동으로 `false`로 설정되며 기존 파일이 있어도 예외가 발생하지 않는다.
- `shouldDeleteIfEmpty`
    - 빈 결과 파일 처리 여부
    - default: `false`
    - `true`일 때 결과 파일에 헤더와 푸터 외에 데이터가 하나도 쓰여지지 않은 경우 파일을 삭제한다.

## FlatFileItemWriter 롤백 전략

- `FlatFileItemWriter`는 데이터를 즉시 파일에 쓰지 않고 내부 버퍼에 일시적으로 저장해둔다.
    - DB와 달리 데이터 롤백이 불가하기 때문
- 청크 처리가 정상적으로 완료되어 트랜잭션 커밋 시점에 버퍼의 데이터를 파일에 쓴다.
    - `beforeCommit()` 콜백 호출 시
- 이 설정은 `FlatFileItemWriterBuilder`의 `transactional()` 메서드로 설정 가능하다.
    - default: `true`

## 파일 쓰기와 OS 캐시: forceSync

- `FlatFileItemWriterBuilder`는 `forceSync()` 메서드를 제공한다.
    - default: `false`
    - `true`로 설정하면 데이터를 캐시가 아닌 디스크에 즉시 동기화 시킨다.
- OS는 성능을 위해 매번 디스크에 직접 쓰는 대신 메모리 캐시에 먼저 저장한다.
    - 하지만 예상치 못한 문제 발생 시 캐시의 데이터가 디스크에 쓰이지 못하고 유실될 수 있다.
    - `forceSync`는 이 문제를 피하기 위해 설정하는 것
- 다만 잦은 동기화로 인한 성능 저하는 유의해야 한다.
