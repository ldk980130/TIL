# 섹션 7. 조건부 자동 구성
## 스타터와 Jetty 서버 구성 추가

- 어떤 조건을 걸어서 Tomcat 서버를 쓸지, 다른 서블릿 컨테이너를 쓸지 선택해 보려고 한다.
    - Jetty 서버 구성을 사용
- 우리가 지금까지 Tomcat 서버를 사용할 수 있었던건 spring-starter 의존성에 Tomcat 의존성이 포함되어 있기 때문이다.
    - springboot 몇 버전을 쓰면 Tomcat은 몇 버전을 쓴다 등의 부트의 자기 주장이 강하게 반영되어 있다.

```groovy
dependencies {
  implementation 'org.springframework.boot::spring-boot-starter-web'
}
```

- Jetty는 starter에 포함되어 있지 않기에 아래 의존성을 추가한다.

```groovy
dependencies {
  implementation 'org.springframework.boot::spring-boot-starter-web'
  implementation 'org.springframework.boot::spring-boot-starter-jetty'
}
```

- Tomcat을 띄웠던 것처럼 Jetty도 서블릿 웹 서버 팩터리를 빈으로 등록시킬 수 있다.
    - 빈 이름은 기본적으로 빈 설정 메서드 이름을 따라가기에 `TomcatServletWebServerFactory` 빈 이름과 충돌을 피하기 위해 이름을 따로 지정

```java
@MyAutoConfiguration
public class TomcatWebServerConfig {
  @Bean("tomcatWebServerFactory")
  public ServletWebServerFactory servrWebServerFactory() {
    return new TomcatServletWebServerFactory();
  }
}

@MyAutoConfiguration
public class JettyWebServerConfig {
  @Bean("jettyWebServerFactory")
  public ServletWebServerFactory servletWebServerFactory() {
    return new JettyServletWebServerFactory();
  }
}
```

- `tobyspring.config.MyAutoConfiguration.imports` 내부에도 jetty 설정을 추가

```groovy
tobyspring.config.autoconfig.DispatcherServletConfig
tobyspring.config.autoconfig.TomcatWebServerConfig
tobyspring.config.autoconfig.JettyWebServerConfig
```

- 이 상태에서 서버를 실행하면 에러가 발생하여 애플리케이션이 뜨지 않는다.
    - 여러 `ServletWebServerFactory`가 존재하기 때문

## @Conditional과 Condition

- 조건부로 빈을 띄울 때 `@Conditional`을 사용할 수 있다.
- `@Conditional`은 `Condition` 인터페이스 구현체 클래스를 엘리먼트로 가진다.

```java
@MyAutoConfiguration
@Conditional(JettyWebserverConfig.JettyCondition.class)
public class JettyWebServerConfig {
  @Bean("jettyWebServerFactory")
  public ServletWebServerFactory servletWebServerFactory() {
    return new JettyServletWebServerFactory();
  }
  
  // boolean 반환 여부에 따라 빈을 띄우거나 띄우지 않음
  static class JettyCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
      return true
    }
  }
}
```

- `TomcatWebServerConfig`에는 반대로 `false`를 반환하는 `Condition` 구현체를 `@Conditional`로 등록하면 Jetty 서버가 뜨게 된다.
  - 둘 다 `true`르 반환하면 이전과 똑같은 이유로 애플리케이션이 뜨지 않는다.

## 커스텀 @Conditional

- 무엇을 기준으로 Tomcat, Jetty 중 하나를 선택할 수 있을까?
  - 스프링부트가 자동 구성에서 대표적으로 사용하는 방법은 어떤 라이브러리가 이 프로젝트에 포함되어 있는가
  - 어떤 클래스가 존재하는지를 확인하면 라이브러리를 포함하는지 여부를 알 수 있다.
  - 각 라이브러리가 있다는 가정 하에 Tomcat의 경우 `Tomcat.java` 클래스 자체가, Jetty의 경우 `Server.java` 클래스가 jetty.server 패키지 하위에 존재한다.
- `Spring`에는 `ClassUtils` 클래스가 존재하는데 이걸 사용해서 특정 클래스가 존재하는지를 알 수 있다.

```java
@MyAutoConfiguration
@Conditional(TomcatWebServerConfig.TomcatCondition.class)
public class TomcatWebServerConfig {
  @Bean("tomcatWebServerFactory")
  public ServletWebServerFactory servrWebServerFactory() {
    return new TomcatServletWebServerFactory();
  }
  
  static class TomcatCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
      return ClassUtils.isPresent("org.apache.catalina.startup.Tomcat", 
        context.getClassLoader());
    }
  }
}

@MyAutoConfiguration
@Conditional(JettyWebserverConfig.JettyCondition.class)
public class JettyWebServerConfig {
  @Bean("jettyWebServerFactory")
  public ServletWebServerFactory servletWebServerFactory() {
    return new JettyServletWebServerFactory();
  }
  
  static class JettyCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
      return ClassUtils.isPresent("org.eclipse.jetty.server.Server", 
        context.getClassLoader());
    }
  }
}
```

- 현재 이 프로젝트에는 Tomcat과 Jetty 의존성이 모두 있기 때문에 오류가 날 것이다.
- 각 의존성을 없애면서 실행해보면 각 서버가 잘 뜨는 것을 확인할 수 있다.

```groovy
dependencies {
  implementation 'org.springframework.boot::spring-boot-starter-web' {
    exclude group: 'org.springframework.boot', module: 'sppring-boot-starter-tomcat'
  }
  implementation 'org.springframework.boot::spring-boot-starter-jetty'
}
```

- `Conditional`을 메타 어노테이션으로 만들어 사용할 수 있다.
  - 어노테이션 element로 클래스 이름을 받아 처리해보자

```java
@Rentention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})
@Conditional(MyOnClassCondition.class)
public @interface ConditionalMyOnClass {
  String value(); // 있는지 체크할 클래스 이름
}
```

```java
public class MyOnClassCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
      Map<String, Object> attrs = metadata.getAnnotationAttribute(ConditionalMyOnClass.class());
      String value = (String) attrs.get("value");
      
      return ClassUtils.isPresent("value", context.getClassLoader());
    }
}
```

- 위 메타 어노테이션은 아래처럼 사용할 수 있다.

```java
@MyAutoConfiguration
@ConditionalMyOnClass("org.apache.catalina.startup.Tomcat")
public class TomcatWebServerConfig {
  @Bean("tomcatWebServerFactory")
  public ServletWebServerFactory servrWebServerFactory() {
    return new TomcatServletWebServerFactory();
  }
}

@MyAutoConfiguration
@ConditionalMyOnClass("org.eclipse.jetty.server.Server")
public class JettyWebServerConfig {
  @Bean("jettyWebServerFactory")
  public ServletWebServerFactory servletWebServerFactory() {
    return new JettyServletWebServerFactory();
  }
}
```

- 스프링부트는 위 방식으로 ‘gradle 의존성 추가 → 클래스가 존재 → 빈 등록’의 논리 구조로 자동 구성을 수행한다.
