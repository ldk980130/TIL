# 섹션 7. 서비스 추상화

## 서비스란 무엇인가?

- 스프링 애플리케이션 빈이 존재하는 계층 구조
    - `@Controller` → Presentation Layer
    - `@Service` → Business Layer
    - `@Repository` → Persistence Layer
- Business Layer
    - 애플리케이션의 비즈니스 로직/도메인 로직의 코드가 위치하는 계층
    - 그 외 다양한 이름으로 불린다.
    - https://martinfowler.com/eaaCatalog/serviceLayer.html
- 서비스는 일반적인 용어라 쓰이는 곳에 따라 다른 의미를 가진다.

### ‘서비스’의 의미

- 백엔드에서 ‘서비스’라는 단어가 가지는 두 가지 의미가 존재한다.
    - 서비스는 클라이언트에게 서비스를 제공해주는 오브젝트나 모듈
        - = 서버
    - 서비스는 일반적으로 상태를 가지지 않는다.
        - stateless
        - 싱글톤 스프링 빈을 사용하기 적합
- 서비스의 종류
    - 애플리케이션 서비스
        - 비즈니스 계층에 존재하는 @Service 애노테이션이 붙은 오브젝트
    - 도메인 서비스
        - 도메인 모델 패턴을 사용할 때 특정 엔티티로 표현하기 힘든 로직을 구현할 때 사용
    - 인프라 서비스
        - 이번 섹션에서 다루는 서비스 추상화의 대상
        - 도메인/애플리케이션 로직에 참여하지 않는다.
        - 기술을 제공하는 서비스 (메일, 캐시, 트랜잭션, 메시징 등)

## 애플리케이션 서비스

- 애플리케이션 서비스란
    - 가장 중요한 도메인/애플리케이션/비즈니스 로직
    - 인프라 레이어에 존재하는 기술에 가능한 의존하지 않도록 만들어야 함
- `Order` 엔티티를 저장하는 애플리케이션 서비스를 작성한다면 아래와 같을 것이다.

```java
@Service
public class OrderService {
  private final OrderRepository orderRepository;
  
  public OrderService(OrderRepository orderRepository) {
    this.orderRepository = orderRepository;
  }
  
  public Order createOrder(String no, BigDecimal total) {
    Order order = new Order(no, total);
    
    orderRepository.save(order);
    
    return order;
  }
}
```

- 위 서비스에 트랜잭션을 적용해보자
    - 트랜잭션을 적용하는 방법으로 `TransactionTemplate`을 이용하는 방법이 있다.
    - `TransactionTemplate`을 사용하려면 `TransactionManager` 의존성이 필요
    - 일단 Jpa를 사용하니 `JpaTransactionManager`를 사용

```java
@Service
public class OrderService {
  private final OrderRepository orderRepository;
  private final JpaTransactionManager transactionManager; 
  
  public OrderService(OrderRepository orderRepository, JpaTransactionManager transactionManager) {
    this.orderRepository = orderRepository;
    this.transactionManager = transactionManager;
  }
  
  public Order createOrder(String no, BigDecimal total) {
    Order order = new Order(no, total);
    
    return new TransactoinTemplate(transactionManager)
      .execute(status -> {
        orderRepository.save(order);
        return order;
      });
  }
}
```

## 기술에 독립적인 애플리케이션 서비스

- 위 `OrderService`는 지금 JPA에 굉장히 의존적이다.
    - 데이터 엑세스 기술의 하나인 JPA에 의존
    - JPA를 사용하는 `Repository` 클래스에 의존
    - `JpaTransactionManager`에 의존
- `OrderService`에게 있어 JPA 기술을 사용한다는 것은 관심사에서 제외되기에 관심사를 분리할 필요가 있다.
- JPA 어노테이션을 사용해서 JPA 엔티티로 정의한 `Order`는 어떤가?
    - `@Entity`로 정의
    - 컴파일 시점에만 JPA 라이브러리에 의존
    - 클래스 코드에는 JPA 기술과 관련된 내용이 들어가지 않음

> 관점에 따라 다르지만, `@Entity`와 같은 어노테이션이 있다고 해서 JPA에 의존하고 강결합이 있다고 보지 않기도 한다. JPA를 사용하지 않는다면 런타임에 JPA 라이브러리를 사용하지 않는다. JPA 말고 다른 기술을 사용한다고 해도 어노테이션을 제거하지 않아도 되고 다른 데이터 기술에 엔티티 클래스를 사용해도 문제 없다.
>

- 그럼에도 엔티티에서 JPA 메타정보를 제거하고 싶다면 xml을 사용하는 방법도 있다.
    - 어노테이션을 제거하고 xml에서 엔티티 설정

## OrderRepository DIP

- 특정 기술(JPA)에 의존하지 않은 애플리케이션 서비스를 만들기 위해서 우선 `OrderRepository`에서 JPA 의존성을 분리할 필요가 있다.
    - DIP를 적용
    - Application Layer[`OrderService` → `OrderRepository`] ← Infra Layer[`JpaOrderRepository`]
      - [ ]는 패키지
    - `OrderRepository`는 순수 인터페이스로 만들고 Infra Layer에서 JPA를 사용하는 구현체를 DI시키면 된다.

## 트랜잭션 서비스 추상화

- Transaction은 데이터 기술에 따라 방법이 다르다.
    - JDBC, JPA, MyBatis, Jooq
- 스프링의 트랜잭션 관리 기술의 핵심은 트랜잭션 추상화다.

> 추상화란 구현의 복잡함과 디테일을 감추고 중요한 것만 남기는 기법이다. 그렇다면 서비스 추상화란? 여러 인프라 서비스 기술의 공통적이고 핵심적인 기능을 인터페이스로 정의하고 이를 구현하는 어댑터를 만들어 일관된 사용이 가능하게 만드는 것이다.
>

- 기존 `OrderService`는 `JpaTransactionManager`에 의존적인데 스프링이 제공하는 트랜잭션 서비스 추상화를 사용해보자.
    - [`PlatformTransactionManager`](https://docs.spring.io/spring-framework/reference/data-access/transaction/strategies.html#page-title)

```java
@Service
public class OrderService {
  private final OrderRepository orderRepository;
  private final PlatformTransactionManager transactionManager; 

  public OrderService(OrderRepository orderRepository, PlatformTransactionManager transactionManager) {
    this.orderRepository = orderRepository;
    this.transactionManager = transactionManager;
  }
  // 아래 코드는 전혀 변화가 없다
  // ...
}
```
