# 섹션 2. 오브젝트와 의존관계

## 오브젝트와 의존관계

### 클래스와 오브젝트

- 클래스와 오브젝트는 다르다.
    - 클래스로 오브젝트를 만드는 것
    - 클래스는 오브젝트의 청사진
- 클래스의 인스턴스 = 오브젝트
    - 인스턴스란 추상적인 클래스의 실체
    - 오브젝트는 클래스로 만든 실제 무언가라고 말할 수 있다.
    - Java 언어 스펙에 나오는 표현
    - 클래스란 오브젝트를 만들어 내기 위한 설계도
- 자바에서는 배열(Array)도 오브젝트다.

> Java에서 오브젝트란 클래스의 인스턴스, 또는 배열이다. 이는 기술적으로는 완벽한 대답
>

### 의존관계 (Dependency)

- 의존 관계는 반드시 2개 이상의 대상이 존재해야 한다.
    - A → B
    - 하나가 다른 하나를 사용, 호출, 생성, 인스턴스화, 전송 등을 수행
- 의존관계가 있을 때 의존 대상이 변경되면 이를 사용하는 클래스 코드도 영향을 받는다.
- 오브젝트 간의 의존 관계는 런타임에 만들어지고 영향을 받지만 클래스 레벨의 의존관계와는 다를 수 있다.

## 관심사의 분리 (Separation of Concerns, SoC)

- `PaymentService.prepare` 코드 예제를 살펴보자
  - 주문번호, 외국 통화 종류, 외국 통화 기준 금액을 전달 받아
  - 외부 api로 환율을 가져와서
  - ‘적용 환율’, ‘원화 환산 금액’, ‘환산 금액의 유효 시간’을 가지는 `Payment` 객체를 리턴

```java
public class PaymentService {
  public Payment prepare(Long orderId, String currency, BigDecimal foreignCurrencyAmount) throws IOException {
    // 환율 가져오기
    URL url = new URL("https://open.ir-api.com/v6/latest/" + currency);
    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
    BufferedReader br = new BufferedReader(new InputStreamReader(connection.getInputStream()));
    String response = br.lines().collect(Collectors.joining());
    br.close();
    
    ObjectMapper mapper = new ObjectMapper();
    ExRateData data = mapper.readValue(response, ExRateData.class);
    BigDecimal exRate = data.rates().get("KRW");
    
    BigDecimal convertedAmount = foreignCurrencyAmount.multiply(exrate);
    LocalDateTime validUntil = LocalDateTime.now().plusMinutes(30);
    
    return new Payment(orderId, currency, foreignCurrencyAmount, exRate, convertedAmount, validUntil);
  }
}
```

- 위 정보는 관심사가 섞여 있다.
  - API를 이용해서 환율 정보를 가져오고 JSON을 매핑하는 관심
  - `Payment`를 준비하는 로직
- 관심사란 동일한 이유로 변경되는 코드의 집합이다.
  - API 호출 부분은 기술적 이유, 환율을 가져오는 방법이 바뀌면 변경될 것이다.
  - `Payment` 준비 로직은 서비스의 로직이 변경되면 변경될 것이다.
  - 변경의 이유와 시점이 명확히 다르다.
- 관심사를 분리하는 가장 간단한 방법은 별도의 메서드로 분리하는 것이다.
  - [메서드 추출 리팩터링](https://refactoring.guru/extract-method)

```java
public class PaymentService {
  public Payment prepare(Long orderId, String currency, BigDecimal foreignCurrencyAmount) throws IOException {
    BigDecimal exRate = getExRate(currency);
    BigDecimal convertedAmount = foreignCurrencyAmount.multiply(exrate);
    LocalDateTime validUntil = LocalDateTime.now().plusMinutes(30);
    
    return new Payment(orderId, currency, foreignCurrencyAmount, exRate, convertedAmount, validUntil);
  }
  
  private BigDecimal getExRate(String currency) throws IOException {
    // ...
    return exRate;
  }
}
```
