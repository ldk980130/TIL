# 섹션 5 탬플릿

## 다시보는 OCP

- 개방 폐쇄 원칙 (OCP)
    - 클래스나 모듈은 확장에 열려 있고 변경엔 닫혀 있어야 한다.
- 변화의 특성이 다른 부분을 구분하고 효율적인 구조로 만들어야 한다.
    - 각각 다른 목적과 이유에 의해 다른 시점에 독립적으로 변경될 수 있도록
    - ex) 환율을 가져오는 방식이 바뀌어도 변화가 없는 `PaymentService`처럼

### 탬플릿

- 변경이 거의 일어나지 않으며 일정한 패턴으로 유지되는 특징을 가진 부분을 탬플릿이라 한다.
- 탬플릿으로부터 자유롭게 변경되는 성질을 가진 부분을 독립시켜 효과적으로 사용할 수 있다.
- ex) 탬플릿 메소드 패턴
    - 상속을 이용해 고정된 탬플릿과 변경 가능한 훅 부분을 분리하는 패턴
- ex) 탬플릿 콜백 패턴
    - 전략 패턴과 유사하게 인터페이스로 만들어진 콜백을 교체하며 탬플릿을 활용하는 패턴
- 스프링이 제공하는 탬플릿
    - `JdbcTemplate` (스프링 6에는 좀 더 모던한 `JdbcClient`가 추가되었다.)
    - `RestTemplate` (최근에는 `RestClient`가 추가되어 더 모던한 API 스타일을 작성할 수 있게 되었다.)
    - `TransactionTemplate`

## WebApiExRateProvider 리팩터링

```java
public class WebApiExRateProvider extends ExRateProvider {
  @Override
  BigDecimal getExRate(String currency) throws IOException {
    // 네트워크 호출을 통해 환율을 가져오는 로직
    // ...
    return exRate;
  }
}
```

- 세부 사항이라 코드를 자세히 적진 않았지만 `WebApiExRateProvider`는 네트워크 통신을 수행한다.
- 그 과정에서 `IOEXception`이 체크 예외로 발생할 수 있기에 기존에는 위처럼 예외를 메서드 밖으로 던졌다.
- 하지만 `ExRateProvider` 인터페이스만 본다면 네트워크 통신을 해야하니 `IOException` 난다는 사실을 모른다.
    - 다른 구현체는 `IOException`이 필요 없을 수 있다.

- 즉 `WebApiExRateProvider`는 `IOException`을 적절히 처리해야 한다.
    - 런타임 예외로 전환해서 던지는 방법이 있다.
    - 결국 시스템은 예외를 알긴 알아야 한다. (`IOException`이 아닌)
- 런타임 예외로 전환하면 `ExRateProvider` 외부에선 `try/catch`나 `throws`를 선언하지 않아도 된다.
    - 런타임 예외는 결국 어딘가에서 적절히 처리해야 한다.
    - 적어도 `PaymentService` 쪽의 관심사에선 분리하는 거에 의미가 있다.

## 변하는 코드 분리하기 - 메서드 추출

```java
public class WebApiExRateProvider extends ExRateProvider {
  @Override
  BigDecimal getExRate(String currency) {
    String url = "https://open.er-api.com/v6/latest/" + currency;
    
    URI uri;
    uri = // 1. URI를 준비하고 예외 처리를 위한 작업을 하는 코드
    
    try {
      // 2. API를 실행하고 서버로부터 받은 응답을 가져오는 코드
    } catch (IOException e) {
      throw new RuntimeException(e)
    }
    
    try {
      // 3. JSON 문자열을 파싱하고 필요한 환율 정보를 추출하는 코드
    } catch (JsonProcessingException e) {
      throw new RuntimeException(e)
    }
    
    return exRate;
  }
}
```

- 메서드 흐름에서 2번과 3번은 변경과 확장이 될 가능성이 높다.
  - API 호출 방법이 다른 기술(라이브러리)로 변경될 수 있음
  - JSON 파싱 방법이 다른 기술(라이브러리)로 변경될 수 있음
- 2, 3번을 어떻게 나머지 변하지 않는 부분으로부터 분리시킬 수 있을까?
  - 일단 메서드로 추출해볼 수 있다.

```java
public class WebApiExRateProvider extends ExRateProvider {
  @Override
  BigDecimal getExRate(String currency) {
    String url = "https://open.er-api.com/v6/latest/" + currency;
    URI uri;
    uri = // 1. URI를 준비하고 예외 처리를 위한 작업을 하는 코드
    
    String response;
    try {
      response = executeApi(uri);
    } catch (IOException e) {
      throw new RuntimeException(e)
    }
    
    try {
      return extractExRate(response)
    } catch (JsonProcessingException e) {
      throw new RuntimeException(e)
    }
  }
  
  private BigDecimal extractExRate(String response) throws JsonProcessingException {
    return // 3. JSON 문자열을 파싱하고 필요한 환율 정보를 추출하는 코드
  }
  
  private String executeApi(URI uri) throws IOException {
    return // 2. API를 실행하고 서버로부터 받은 응답을 가져오는 코드
  }
}
```

- 메서드로 추출함으로써 `getExRate` 메서드 내부의 코드는 2, 3번이 변화해도 바뀌지 않게 되었다.
  - 더 정확히는 api의 엔드포인트는 변할 수 있기 때문에 `url` 변수로 `URI`를 생성하는 부분부터 변하지 않는 부분
- 변하지 않는 부분 또한 정확히 잘라내기 위해 메서드로 추출해보자

```java
public class WebApiExRateProvider extends ExRateProvider {
  @Override
  BigDecimal getExRate(String currency) {
    String url = "https://open.er-api.com/v6/latest/" + currency;
    
    return runApiForExRate(url);
  }
  
  private BigDecimal runApiForExRate(String url) {
    // 변하지 않는 코드
  }
  
  private BigDecimal extractExRate(String response) throws JsonProcessingException {
    return // 3. JSON 문자열을 파싱하고 필요한 환율 정보를 추출하는 코드
  }
  
  private String executeApi(URI uri) throws IOException {
    return // 2. API를 실행하고 서버로부터 받은 응답을 가져오는 코드
  }
}
```

- `runApiForExRate`는 변하지 않는, 탬플릿이 되었다.
- 메서드를 통해 변하는 부분과 변하지 않는 부분을 분리했지만 아직 부족하다.
  - 결국 변화가 생기면 `WebApiExRateProvider` 클래스가 바뀌게 된다.
