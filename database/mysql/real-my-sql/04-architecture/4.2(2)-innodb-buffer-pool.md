## 4.2.7 InnoDB 버퍼 풀

- 일반적인 애플리케이션에선 insert, update, delete 작업 처리 시 랜덤 디스크 I/O를 발생시킨다.
- InnoDB 스토리지 엔진은 쓰기 작업을 지연 시켜 일괄 작업으로 처리할 수 있게 하는 버퍼 공간을 가지고 있다. → 랜덤 디스크 작업 횟수를 줄일 수 있다.

### 버퍼 풀 크기 설정

- InnoDB 버퍼 풀은 `innodb_buffer_pool_size` 시스템 변수로 설정할 수 있으며 동적으로 확장할 수도 있다.
    - 가능하면 적절히 작은 값으로 설정해서 조금씩 증가시키는 방법이 최적이다.
- 버퍼 풀은 내부적으로 128mb 청크 단위로 쪼개어 관리된다. 버퍼 풀 크기를 조정할 때도 128mb 단위로 처리된다.

### 버퍼 풀의 구조

버퍼 풀은 페이지 크기 조각을 관리하기 위해 다음의 세 자료구조를 관리한다.

- **LRU(Least Recently Used) 리스트**
  ![img.png](../../../../image/buffer-pool-structure.png)

    - 엄밀하게 LRU와 MRU(Most Recently Used) 리스트가 결합된 형태
    - Old 서브 리스트 영역이 LRU, New 서브 리스트 영역이 MRU라고 이해하면 된다.
    - 디스크로부터 한 번 읽어온 페이지를 최대한 오래 버퍼 풀에 유지해 디스크 읽기를 최소화 시키는 것이 목적
    - 처음 읽힌 데이터는 Old 영역 헤더에 추가된다. 버퍼 풀의 데이터가 쿼리에 의해 사용되면 New 영역으로 이동하여 계속 사용된다면 New 영역에서 계속 남아있게 된다. 반대로 거의 사용되지 않는다면 새 데이터 페이지들에 밀려서 Old 영역 끝으로 밀려나 결국은 버퍼 풀에서 제거되는 방식이다.
- **플러시(Flush) 리스트**
    - 디스크로 동기화 되지 않은 데이터를 가진 데이터 페이지(더티 페이지)의 변경 시점 기준의 페이지 목록을 관리한다.
    - 데이터 변경이 가해진 데이터 페이지는 플러시 리스트에 관리되고 특정 시점에 디스크로 기록되어야 한다.
- **프리(Free) 리스트**
    - 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록
    - 사용자 커리가 새롭게 디스크의 페이지를 읽어와야 하는 경우 사용된다.

### 버퍼 풀과 리두 로그

InnoDB 버퍼 풀은 **캐시** 역할과 **쓰기 버퍼링**의 역할을 갖고 있다. 버퍼 풀 크기를 늘리면 성능이 빨라지는데 이는 캐시 기능만 향상 시키는 것이다. 버퍼 풀의 쓰기 버퍼링까지 향상 시키려면 버퍼 풀과 리두 로그의 관계를 이해할 필요가 있다.
![img.png](../../../../image/buffer-pool-redo-log.png)
- 버퍼 풀의 페이지 중 변경되지 않은 것을 클린 페이지, 변경된 데이터 페이지를 **더티 페이지**라고 한다.
- 데이터가 변경되면 변경 내용을 **리두 로그**에 기록하고 변경을 디스크에도 반영하기 위해 리두 로그의 엔트리는 해당 더티 페이지와 연결된다.
  - 리두 로그는 1개 이상의 고정 크기 파일을 연결해 순환 고리처럼 사용한다.
  - 데이터 변경이 계속 발생하면 로그 엔트리는 어느 순간 새로운 엔트리로 덮어 쓰인다.
  - 그래서 전체 리두 로그에서 **재사용 가능한 공간(활성 리두 공간, Active Redo Log)**과 불가능한 공간을 나눠 관리하게 된다. (그림에서 화살표가 있는 공간을 활성 리두 공간이라 함)
  - 리두 로그 공간은 순환되어 재사용되지만 매번 기록될 때마다 **LSN(Log Sequence Number)**은 계속 증가된 값을 갖는다.
- 하지만 리두 로그가 디스크에 기록되는 것이 데이터 페이지가 디스크에 기록되는 것을 보장하지는 않고 그 반대도 마찬가지다. 리두 로그와 데이터 페이지의 동기화를 **체크포인트** 이벤트를 통해 수행한다.
  - 체크포인트 - MySQL 서버가 시작될 때 InnoDB가 리두 로그의 어느 부분부터 복구를 실행해야 할지 판단하는 기준점의 역할을 한다.
  - 가장 최근의 체크포인트의 LSN이 활성 리두 로그 공간 시작점이 된다.
    - 활성 리두 공간의 마지막은 계속 증가하기 때문에 체크포인트와 무관
  - 가장 최근 체크포인트 LSN과 마지막 리두 로그 엔트리의 LSN의 차이를 **체크포인트 에이지(Checkpoint Age)**라고 한다. (체크포인트 에이지 == 활성 리두 공간 크기)
  - 체크포인트 이벤트가 발생하면 체크포인트 LSN보다 작은 리두 로그 엔트리와 관련된 더티 페이지는 모두 디스크로 동기화돼야 한다.
- 즉 버퍼 풀이 아무리 커봤자 리두 로그 공간이 부족하다면 쓰기 버퍼링을 위한 효과는 거의 못 보게 된다.
  - 쓰기 버퍼링을 위한 더티 페이지는 리두 로그 파일과 연결돼야 하기 때문
- 반대로 버퍼 풀에 비해 리두 로그 공간이 엄청 큰 상황에서는 갑작스러운 디스크 쓰기가 발생할 가능성이 높다.
  - 버퍼 풀의 더티 페이지 비율이 너무 높은 상황에서 갑자기 버퍼 풀이 필요해지면 많은 더티 페이지를 한 번에 기록해야 함
- 버퍼 풀 크기가 100GB 이하의 MySQL 서버에서는 리두 로그 파일 크기를 약 5~10GB 수준으로 선택하고 필요할 때마다 늘려가며 최적을 선택하는 것이 좋다.

### 버퍼 풀 플러시

- InnoDB 스토리지 엔진은 더티 페이지들을 성능상의 악영향 없이 디스크에 동기화하기 위해 다음의 2가지 플러시 기능을 백그라운드로 실행한다.
  - **플러시 리스트 플러시**
  - **LRU 리스트 플러시**
