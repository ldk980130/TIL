# 10.3(3) 실행 계획 분석 (type)

## 10.3.5 type 칼럼

- 쿼리 실행 계획에서 type 칼럼은 MySQL 서버가 각 테이블 레코드를 어떤 방식으로 읽었는지를 나타낸다.
    - 인덱스를 사용했는지 풀 테이블 스캔을 했는지
- 아래부터 설명되는 type 칼럼들은 성능이 빠른 순서대로 나열된 것이다.

### system

- 레코드가 1건 또는 0건 존재하는 테이블을 참조하는 형태의 접근 방법
- InnoDB 스토리지 엔진에선 나타나지 않고 MyISAM이나 MEMORY 테이블에서만 사용되는 접근 방법이다
- 쿼리에 따라 다르겠지만 InnoDB에서 레코드가 1 또는 0건인 테이블을 조회할 땐 ALL 또는 index 접근 방법이 사용될 가능성이 크다.

### const

- 테이블 레코드 건수와 관계 없이 `WHERE` 절 조건에 프라이머리 키나 유니크 키 칼럼을 이용하여 반드시 1건을 반환하는 쿼리의 처리 방식
    - 다른 DBMS에선 유니크 인덱스 스캔이라고도 표현한다.
- 프라이머리 키나 유니크 키가 다중 칼럼일 경우 일부 칼럼만으로 검색하면 const 타입의 접근 방법을 사용할 수 없다.
    - 실제 레코드가 1건만 저장돼 있더라도 MySQL 서버는 직접 읽어보지 않고서는 확신할 수 없다.
    - 대신 ref 접근 방식을 사용한다.
- const인 실행 계획은 옵티마이저가 쿼리를 최적화하는 단계에서 쿼리를 먼저 실행해 통째로 상수화한다.

    ```sql
    SELECT COUNT(*) FROM emplyees e1
    WHERE first_name=(
    	SELECT first_name FROM employees2 WHERE emp_no=10001
    );
    
    -- // 위 쿼리는 최적화 후 아래와 같이 변환된다.
    SELECT COUNT(*) FROM employees e1
    WHERE first_name='Jasminko'; -- // emp_no=100001인 칼럼
    ```


### eq_ref

- 조인 쿼리의 실행 계획에서만 표시된다.
- eq_ref는 조인에서 처음 읽은 테이블의 칼럼값을, 그 다음 읽어야 할 테이블의 프라이머리 키나 유니크 키 칼럼의 검색 조건에 사용할 때 표시된다.
    - 두 번째 이후 읽는 테이블의 type 칼럼에 eq_ref가 표시된다.
- 조인에서 두 번째 이후 읽는 테이블에서 반드시 1건만 존재한다는 보장이 있어야 한다.
    - 유니크 키로 검색할 때 그 유니크 인덱스는 `NOT NULL`이어야 한다.
    - 다중 칼럼 인덱스라면 인덱스의 모든 칼럼이 비교 조건에 사용되어야 한다.
- 예제 쿼리를 살펴보자.

    ```sql
    EXPLAIN SELECT *
    FROM dept_emp de, employees e
    WHERE e.emp_no=de.emp_no AND de.dept_no='d005';
    ```
  | id | select_type | table | type | key | rows |
  | --- | --- | --- | --- | --- | --- |
  | 1 | SIMPLE | de | ref | PRIMARY | 165571 |
  | 1 | SIMPLE | e | eq_ref | PRIMARY | 1 |
    - id 값이 1로 같으므로 조인이 실행된다는 것을 알 수 있다.
    - 실행 계획에서 먼저 표시된 `dept_emp` 테이블을 먼저 읽고, `e.emp_no=de.emp_no` 조건을 이용해 두 번째 테이블인 `employees` 테이블을 검색한다.
    - 이 때 `emp_no`는 `employees` 테이블의 프라이머리 키이기 때문에 실행 계획의 두 번째 라인은 type이 eq_ref로 표시된다.

### ref

- 인덱스 종류와 조인에 관계 없이 동등(Equal) 조건으로 검색할 때 ref 접근 방법이 사용된다.
- 다중 칼럼 인덱스에서 일부 칼럼으로만 검색하는 경우 ref가 사용된다.

> const, eq_ref, ref는 매우 좋은 접근 방법이므로 인덱스 분포도가 나쁘지 않다면 성능 문제를 일으키지 않는다. 쿼리 튜닝 시 이 세 가지에 대해서는 크게 신경쓰지 않아도 무방하다.
>
