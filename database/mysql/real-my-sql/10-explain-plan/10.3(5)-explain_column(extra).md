# 10.3(5) 실행 계획 분석 (Extra)

## 10.3.12 Extra 칼럼

Extra 칼럼에는 주로 내부적인 처리 알고리즘에 대해 더 깊이 있는 내용을 보여주는 경우가 많다.

### const row not found

- const 접근 방벙으로 테이블을 읽었지만 해당 테이블 레코드가 1건도 존재하지 않는 경우 표시된다.
- 이런 경우 테이블에 적절히 테스트용 데이터를 저장하고 다시 쿼리 실행 계획을 확인해 보는 것이 좋다.

### Distinct

- 아래 쿼리는 두 테이블에 모두 존재하는 `dept_no`만 중복 없이 유니크하게 가져오기 위한 쿼리다.
    - 두 테이블을 조인하면 중복되는 `dept_no`가 발생하게 되기 때문에 `DISTNCT` 명령을 추가했다.

```sql
EXPLAIN 
SELECT DISTINCT d.dep_no 
FROM departments d, dept_emp de 
WHERE de.dept_no=d.dept_no;
```

| id | select_type | table | type | key | Extra |
| --- | --- | --- | --- | --- | --- |
| 1 | SIMPLE | d | index | ux_deptname | Using index; Using temporary |
| 1 | SIMPLE | de | ref | PRIMARY | Using index; Distinct |

![img.png](../../../../image/distnct-opt.png)

- 쿼리의 `DISTINCT`를 처리하기 위해 조인하지 않아도 되는 항목은 모두 무시하고 필요한 것만 조인한 것을 나타낼 때 Extra 칼럼에 Distinct가 표시된다.

### FirstMatch

- 세미 조인 최적화 중 FirstMatch 전략이 사용되면 Extra 칼럼에 FirstMatch(table_name)이 표시된다.
- 표시되는 테이블 기준으로 첫 번째로 일치하는 한 건만 검색한다는 것을 의미한다.
- 자세한 내용은 9.3.11절 ‘퍼스트 매치’ 참고

### Full scan on NULL key

- `col1 IN (SELECT col2 FROM …)`과 같은 쿼리에서 `col1`이 `NULL`인  경우 서브 쿼리에 대해 풀 테이블 스캔을 해서 다음 2가지 중 결론을 내야 한다.
    - 서브 쿼리가 1건이라도 결과 레코드를 가지면 최종 결과는 `NULL`
    - 서브 쿼리가 1건도 결과 레코드를 가지지 않는다면 최종 결과는 `FALSE`
- Extra 칼럼에 ‘Full scan on NULL key’가 표시되는 경우가 바로 `col1`이 `NULL`인 경우 서브 쿼리 테이블을 풀 테이블 스캔 하는 경우다.
    - `col1`이 `NOT NULL`로 정의된 칼럼이라면 표시되지 않을 것이다.
- `IN`이나 `NOT IN` 연산자의 왼쪽 값이 NULL인 레코드가 있고 서브 쿼리에 개별적인 WHERE 조건이 지정돼 있다면 풀 테이블 스캔으로 인해 성능 문제가 발생할 수 있다.
    - 연산자 왼쪽 칼럼이 `NOT NULL`이 아니라면 `WHERE` 조건절에 `IS NOT NULL` 조건을 추가하는 것도 방법이다.

### Impossible HAVING

- 쿼리에 사용된 `HAVING` 절 조건을 만족하는 레코드가 없을 때 표시된다.
- ‘Implossible HAVING’ 메세지가 출력되면 쿼리를 잘못 작성한 경우가 대부분이므로 쿼리를 다시 저검하는 것이 좋다.

### Impossible WHERE

- `WHERE` 조건이 항상 `FALSE`가 될 수밖에 없는 경우 표시된다.

### LooseScan

- 세미 조인 최적화 중 LooseScan 최적화 전략이 사용되면 표시된다.
- 자세한 내용은 9.3.1.12절 ‘루스 스캔(loosescan)’을 참조하자.

### No matching min/max row

- 아래 쿼리처럼 `WHERE` 조건절에 만족하는 레코드가 하나도 없지만 `MIN()`이나 `MAX()` 같은 집합 함수가 있는 쿼리엔 ‘No matching min/max row’가 표시된다.

```sql
EXPLAIN SELECT MIN(dept_no), MAX(dept_no)
FROM dept_emp WHERE dept_no='';
```

### no matching row in const table

- const 방법으로 접근할 때 일치하는 레코드가 없을 때 표시된다.

### No matching rows after partition pruning

- 없는 파티션에서 `UPDATE`나 `DELETE` 쿼리를 실행할 때 표시된다.
- 단순히 삭제할 레코드가 없음을 의마하는 것이 아니라 대상 파티션이 없다는 것을 의미한다.

### No tables used

- `FROM` 절이 없거나 `FROM DUAL` 형태의 쿼리 실행 계획에서 표시된다.
    - `SELECT 1;`, `SELECT 1 FRO dual;`
    - 다른 DBMS와 달리 MySQL에선 `FROM` 절이 없는 쿼리도 허용된다.
    - DUAL은 상수 테이블을 의미한다. (카럼과 레코드를 각각 1개씩만 가지는 가상의 상수 테이블)

### Not exists

- ‘Not exists’는 아우터 조인을 이용해 안티 조인(Anti-JOIN)을 수행하는 쿼리에서 표시된다.
    - **안티 조인**이란 A 테이블에 존재하지만 B 테이블에 없는 값을 조회해야할 때 `NOT IN(subquery)`나 `NOT EXISTS` 연산자를 사용할 때 실행되는 조인을 뜻한다.
    - 똑같은 처리를 아우터 조인으로도 할 수 있는데 레코드 건수가 많을 땐 아우터 조인을 이용하면 빠른 성능을 낼 수 있다.
- 아래 쿼리에선 옵티마이저가 `dept_emp` 테이블 레코드로 `departments` 테이블을 조인할 때 `departments` 테이블의 레코드가 존재하는지 아닌지만 판단한다.
    - 일치하는 레코드가 여러 건 있다고 해도 딱 1건만 조회해보고 처리를 완료하는 최적화를 의미한다.

    ```sql
    EXPLAIN SELECT *
    FROM dept_emp de
    	LEFT JOIN departments d ON de.dept_no=d.dept_no
    WHERE d.dept_no IS NULL;
    ```

  | id | select_type | table | type | key | Extra |
      | --- | --- | --- | --- | --- | --- |
  | 1 | SIMPLE | de | ALL | NULL | NULL |
  | 1 | SIMPLE | d | eq_ref | PRIMARY | Using where; Not exists |
