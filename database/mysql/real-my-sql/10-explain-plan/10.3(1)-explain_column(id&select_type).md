# 10.3(1) 실행 계획 분석(id, select_type)

- `EXPLAIN` 명령을 실행하면 표 형태로 된 1줄 이상의 결과가 표시된다.
- 표의 각 라인(레코드)은 쿼리에서 사용된 테이블 개수만큼 출력된다.
    - 임시 테이블까지 포함
- 위쪽에 출력된 결과일수록(id 칼럼 값이 작을수록) 쿼리의 바깥(Outer) 부분이거나 먼저 접근한 테이블이다.

## 10.3.1 id 칼럼

- 실행 계획 가장 왼쪽에 표시되는 id 칼럼은 `SELECT` 쿼리별로 부여되는 식별자 값이다.
    - 쿼리가 서브 쿼리를 포함하여 2개의 단위 `SELECT` 쿼리를 가지는 경우 최소 2개의 id 값이 표시될 것이다.
- 테이블을 조인하면 조인되는 테이블 개수만큼 실행 계획 레코드가 출력되지만 같은 id 값이 부여된다.

    ```sql
    EXPLAIN 
    SELECT e.emp_no, e.first_name, s.from_Date, s.salary
    FROM employees e, salaryies s
    WHERE e.emp_no=s.emp_no LIMIT 10;
    ```
  
| id | select_type | table | key | ref | rows | Extra |
| --- | --- | --- | --- | --- | --- | --- |
| 1 | SIMPLE | e | ix_firstname | NULL | 3000252 | Using index |
| 1 | SIMPLE | s | PRRIMARY | employees.e.emp_no | 10 | NULL |

## 10.3.2 select_type 칼럼

- 각 단위 `SELECT` 쿼리가 어떤 타입 쿼리인지 표시되는 칼럼이다.

### SIMPLE

- `UNION`이나 서브 쿼리를 사용하지 않는 단순 `SELECT` 쿼리
    - 쿼리에 조인이 포함된 경우도 마찬가지
- 쿼리가 아무리 복잡하더라도 SIMPLE 쿼리는 하나만 존재한다.
- 일반적으로 제일 바깥 `SELECT` 쿼리가 SIMPLE로 표시된다.

### PRIMARY

- `UNION`이나 서브 쿼리를 가지는 `SELECT` 쿼리에서 가장 바깥쪽(Outer)에 있는 단위 쿼리
- PRIMARY인 쿼리는 실행 계획에서 하나만 존재하며 쿼리 제일 바깥쪽에 있는 SELECT 단위 쿼리가 PRIMARY로 표시된다.

### UNION

```sql
EXPLAIN SELECT * FROM (
	(SELECT emp_no FROM employees e1 LIMIT 10) UNION ALL
	(SELECT emp_no FROM employees e2 LIMIT 10) UNION ALL
	(SELECT emp_no FROM employees e3 LIMIT 10)
) tb;
```

| id | select_type | table | type | key | ref | rows | Extra |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 1 | PRIMARY | <derived2> | ALL | NULL | NULL | 30 | NULL |
| 2 | DERIVED | e1 | index | ix_hiredate | NULL | 30252 | Using index |
| 3 | UNION | e2 | index | ix_hiredate | NULL | 30252 | Using index |
| 4 | UNION | e3 | index | ix_hiredate | NULL | 30252 | Using index |
- UNION으로 결합하는 단위 쿼리 중 첫 번째를 제외한 두 번째 이후의 select_type은 UNION으로 표시된다.
- UNION의 첫 번째 단위 쿼리는 UNION된 쿼리를 모아 저장하는 임시 테이블(DERIVED)이 select_type으로 표시된다.
    - 3개 쿼리 중 e1 테이블이 대표 테이블로 설정되어 서브 쿼리 결과를 `UNION ALL`로 결합해 임시 테이블을 만들어 사용하고 있다.

### DEPENDENT UNION

- DEPENDENT UNION은 `UNION`이나 `UNION ALL`로 결합된 쿼리가 외부 쿼리에 의해 영향을 받을 때 표시된다.

```sql
EXPLAIN SELECT * FROM employees e1 WHERE e1.emp_no
IN (
	SELECT e.emp_no FROM employees e2.first_name='Matt'
	UNION
	SELECT e3.emp_no FROM employees e3 WHERE e3.last_name='Matt'
);
```

- 위 쿼리의 경우 옵티마이저가 IN 서브 쿼리를 먼저 처리하지 않고, 외부 `employees` 테이블을 먼저 읽은 다음 서브 쿼리를 실행하기 때문에 `employees` 테이블 칼럼 값이 서브 쿼리에 영향을 준다.

| id | select_type | table | type | key | ref | rows | Extra |
| --- | --- | --- | --- | --- | --- | --- | --- |
| 1 | PRIMARY | e1 | ALL | NULL | NULL | 30252 | Using where |
| 2 | DEPENDENT SUBQUERY | e2 | eq_ref | PRIMARY | func | 1 | Using where |
| 3 | DEPENDENT UNION | e3 | eq_ref | PRIMARY | func | 1 | Using where |
| NULL | UNION RESULT | <union2,3> | ALL | NULL | NULL | NULL | Using temporary |
- 결국 내부적으로 `UNION` 쿼리의 `WHERE` 조건에 `e2.emp_no=e1.emp_no`와 `e3.emp_no=e1.emp_no` 조건이 자동으로 추가된다.