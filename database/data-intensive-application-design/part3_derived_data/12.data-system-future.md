# 12장 데이터 시스템의 미래

- 이 책의 목적은 애플리케이션과 시스템을 신뢰할 수 있고 확장 가능하며 유지보수하기 쉽게 만드는 방법을 탐구하는 것이다.
- 이번 장에서는 이 아이디어들을 기반으로 미래를 고찰한다.

## 데이터 통합

- 특정 문제에 대해서 트레이드 오프를 고려할 때 적절한 소프트웨어를 선택해야 한다.
    - 하지만 도구를 사용하는 환경을 고려하더라도 복잡한 애플리케이션은 데이터를 여러 가지 다른 방법으로 사용한다.
    - 여러 데이터를 모든 상황에 적합하게 다루는 소프트웨어가 있을 가능성은 낮다.
- 예를 들어 OLTP 데이터베이스와 키워드를 대상으로 질의하는 전문 검색 색인을 통합하는 요구는 일반적이다.
    - 전문 색인 기능이 있는 RDB도 있지만 더 복잡한 검색을 지원하려면 전문적인 탐색 도구가 필요
    - 반대로 검색 색인은 지속성 있는 레코드 시스템으로는 적합하지 않다.

### 파생 데이터에 특화된 도구의 결합

- 데이터를 다른 방식으로 표현하는 수가 늘어날수록 데이터 시스템을 통합하기는 더욱 어렵다.
    - ex) 원본에서 파생된 캐시 객체의 비정규화 버전을 유지하기
- 데이터 사본을 여러 저장소에 유지해야 할 때 입출력을 분명히 해야 한다.
    - 레코드 데이터베이스에 데이터를 입력하고 CDC로 검색 색인에 반영하는 경우 색인은 전적으로 레코드 시스템에서 파생되므로 일관성이 보장된다.
    - 애플리케이션이 검색 색인에 직접 데이터를 기록한다면 쓰기 충돌 등으로 일관성 문제가 발생한다.
    - 모든 쓰기 순서를 결정하는 단일 시스템으로 입력을 밀어 넣을 수 있다면 쓰기를 같은 순서로 처리해 데이터 파생이 훨씬 쉬워진다.
    - 이벤트 로그 기반의 파생 데이터 시스템은 결정적이고 멱등성을 지닌다.
- 파생 데이터 대 분산 트랜잭션
    - 분산 트랜잭션
        - 상호 배타적인 잠금을 사용해 쓰기 순서를 결정한다.
        - 원자적 커밋을 사용해 변경 효과가 한 번 나타나도록 보장
        - 선형성을 보장해 자신이 쓴 내용 읽기 같은 기능을 보장
    - 파생 데이터
        - CDC와 이벤트 소싱은 순서를 결정하는 데 로그를 사용한다.
        - 결정적 재시도와 멱등성을 기반으로 동작한다.
        - 대개 비동기로 갱신되기에 동시간 갱신 보장을 하지 않는다.
- 전체 순서화의 제약
    - 보통 전체 로그 순서를 결정하려면 단일 리더 노드를 통해야하지만 데이터 처리량이 늘어나면 파티셔닝이 필수적이고 그럼 두 파티션 간 순서는 애매해진다.
    - 마이크로서비스의 경우 두 이벤트가 서로 다른 서비스에서 발생했다면 이들 사이엔 정해진 순서가 없다.
    - 어떤 애플리케이션은 클라이언트 측 상태를 유지하고 사용자 입력마다 서버 응답을 기다리지 않고 바로 갱신하는데 이 경우 이벤트 순서가 클라이언트와 서버에서 서로 다를 가능성이 높다.
    - 결론적으로 단일 노드 처리량을 넘어서는 규모와 지리적으로 분산된 설정에서 동작하는 전체 순서 브로드캐스트(합의) 설계는 아직 해결되지 않은 과제다.
- 인과성 획득을 위한 이벤트 순서화
    - 이벤트 간 인과성이 없는 경우 순서가 정해지지 않아도 큰 문제는 아니다.
    - 논리적 타임스탬프를 통해 코디네이션 없이 전체 순서화를 지원할 수는 있지만 여전히 수신자가 잘못된 순서로 전달된 이벤트를 처리해야 한다.
    - 충돌 해소 알고리즘은 예상치 못한 순서로 전송된 이벤트를 처리하는 데 도움을 주지만 사용자에게 알림을 보내는 등의 외부 부수 효과가 있다면 도움이 되지 않는다.

### 일괄 처리와 스트림 처리

- 파생 상태 유지
    - 일괄 처리는 결정적이고 출력이 입력에만 의존하여 부수 효과가 없는 강력한 함수형 특징을 가진다.
    - 결정적 함수는 내결함성에 도움이 되고 데이트 플로 추론을 단순화한다.
    - 스트림 처리도 유사하지만 연산자를 확장해 상태를 관리할 수 있고 내결함성을 지니게 한다.
    - 이론상 파생 데이터 시스템은 동기식으로 갱신할 수 있지만 비동기 방식을 사용하면 이벤트 로그 기반 시스템을 훨씬 견고하게 만든다.
- 애플리케이션 발전을 위한 데이터 재처리
    - 일괄 처리와 스트림 모두 파생 데이터를 유지하는데 유용하다.
        - 스트림 처리를 통해 빠르게 파생 뷰에 반영 가능
        - 일괄 처리 시스템을 사용하면 상당한 양의 과거 데이터를 재처리해 새 파생뷰 구축이 가능
    - 파생뷰를 사용하면 스키마의 점진적 발전이 가능하다.
        - 스키마가 변경되어도 이전 스키마와 새 스키마를 함께 유지에 두 개의 독립적인 파생뷰를 만들 수 있다.
        - 점진적으로 새 뷰를 접근하는 사용자 비율을 늘려 결국엔 기존 뷰를 내릴 수 있게 된다.
- 람다 아키텍처 - 일괄 처리와 스트림 처리를 결합한 설계 방식
    - 입력 데이터를 불변 이벤트로 기록하여 일괄 처리와 스트림 처리가 모두 같은 원본을 사용
    - 스트림 처리자는 이벤트를 소비해 근사 갱신을 뷰에 빠르게 반영하고 이후 일괄 처리자가 같은 이벤트를 소비해 정확한 버전의 파생뷰에 반영
    - 하지만 실질적인 문제가 몇 가지 있다.
        - 일괄 처리와 스트림 처리에서 같은 로직을 유지해야 하는 번거로움이 존재
        - 스트림과 일괄 처리 파이프라인은 분리된 출력을 생성하기에 사용자 요청에 대응하려면 두 출력을 병합해야 한다.
        - 대규모 데이터 재처리가 자주 발생한다고 하면 비용이 만만치 않다.
- 최근에는 람다 아키텍처의 단점을 극복하기 위해 두 방식을 통합하려는 시도가 있는데 아래 기능들이 필요하다.
    - 과거 이벤트를 재생하는 능력
    - 정확히 한 번 실행
    - 처리 시간 기준이 아닌 이벤트 시간 기준으로 윈도우를 처리하는 도구
        - 과거 이벤트를 처리할 땐 처리 시간은 의미가 없기 때문

## 데이터베이스 언번들링

- 추상화 수준에서 보면 데이터베이스, 하둡, 운영체제는 모두 같은 기능을 수행한다.
    - 데이터를 저장, 처리, 질의
- 유닉스와 관계형 데이터베이스는 정보 관리 문제를 각기 매우 다른 철학으로 접근한다.
    - 유닉스 - 논리직이지만 저수준인 하드웨어 추상화를 프로그래머에게 제공
    - 관계형 데이터베이스 - 자료 구조, 동시성, 장애 복구 등의 복잡성을 감추고 고수준 추상화를 애플리케이션 프로그래머에게 제공

### 데이터 저장소 기술 구성하기

- 지금까지 데이터베이스가 제공하는 다양한 기능을 설명하고 동작 방식을 설명했다.
    - 보조 색인 - 필드 값을 기반으로 효율적인 레코드 검색 지원
    - 구체화 뷰 - 질의 결과를 미리 계산한 캐시의 일종
    - 복제 로그 - 데이터 복사본을 다른 노드에 최신 상태로 유지하는 기능
    - 전문 검색 색인 - 텍스트에서 키워드 검색을 가능하게 하는 기능
- 데이터베이스에 내장된 기능과 일괄처리와 스트림 처리로 구축하는 파생 데이터 시스템 사이에는 유사점이 있다.
    - 관계형 DB에서 색인 생성하는 과정도 새 팔로워 복제본을 구축하는 과정과 비슷하다.
        - 테이블의 스냅숏을 사용해 스캔하고 색인할 필드 값을 모두 골라 정렬 후 색인에 기록한다.
        - 그 다음 스냅숏 이후에 실행된 쓰기의 백로그를 처리해야 한다.
        - 색인 생성 후에는 쓰기 트랜잭션마다 꾸준히 색인에 반영해야 한다.
    - 전체 조직의 데이터플로가 거대한 데이터베이스로 보일 수도 있는 것이다.
        - 일괄 처리, 스트림 처리를 통해 데이터를 다른 저장소에 다른 형태로 바꿔 저장하는 작업은 색인이나 구체화 뷰를 최신으로 유지하는 데이터베이스의 하위 시스템처럼 작동한다.
- 서로 다른 저장소와 처리 도구를 사용하지만 하나의 응집된 시스템으로 구성할 수 있는 길은 두 가지 존재한다.
    - 연합 데이터베이스: 읽기를 통합
        - 엄청 많은 하단 저장소 엔진과 처리 메서드를 통합해 질의하는 인터페이스를 제공
        - ex) PostgreSQL이 제공하는 foreign data wrapper
        - 특정 데이터 모델이 필요한 경우엔 하단 저장소에 직접 접근
        - 다른 장소의 데이터를 결합하기 원한다면 연합 인터페이스를 통해 처리
        - 여러 시스템에 걸친 쓰기를 동기화하기에는 적합하지 않다.
    - 언번들링 데이터베이스: 쓰기를 통합
        - 여러 시스템으로 구성됐을 때도 모든 데이터가 올바른 장소에 반영되도록 보장해야 한다.
        - 저장소 시스템들을 신뢰성 있게 결합하기 쉽게 만드는 것은 언번들링 방식과 유사하다.
        - 언번들링 - 기존에 하나의 통합된 시스템으로 제공되던 데이터베이스의 다양한 기능(색인, 캐싱, 질의, 트랜잭션 등)을 분리하여 독립적으로 관리하거나 최적화하는 접근 방식
- 언번들링이 동작을 위해 쓰기를 동기화하는 경우 쓰기 기반 비동기 이벤트 로그를 사용하는 것이 좋다.
    - 비동기 이벤트 스트림을 사용하면 전체 시스템 중 개별 요소에 장애가 발생해도 잘 견딜 수 있다.
    - 인적 수준 관점에서도 데이터 시스템을 언번들링하면 각 팀에서 각자 구성 요소를 개발하고 독립적인 유지보수가 가능하다.
- 언번들링 대 통합 시스템
    - 언번들링이 사용된다고 해도 현재 형태의 DB를 대체하지는 못할 것이다.
        - 스트림 처리자의 상태 유지를 위해 필요, 일괄 처리와 스트림 처리자의 출력에 대한 질의에도 필요
    - 여러 인프라에서 수행하는 복잡성도 문제가 된다.
        - 각 소프트웨어마다 학습 곡선 그리고 운영상 특성
    - 언번들링의 목표는 몇 개의 데이터베이스를 결합해 단일 소프트웨어로 가능한 것보다 더 넓은 범위의 작업부하에 대해 좋은 성능을 달성하기 위함이다.
        - 개별 데이터베이스와 특정 작업부하에 대한 성능을 경쟁하는 것이 아님
    - 언번들링의 장점은 요구사항을 모두 만족하는 단일 소프트웨어가 없는 상황에서만 드러난다.

