# 12장 데이터 시스템의 미래

- 이 책의 목적은 애플리케이션과 시스템을 신뢰할 수 있고 확장 가능하며 유지보수하기 쉽게 만드는 방법을 탐구하는 것이다.
- 이번 장에서는 이 아이디어들을 기반으로 미래를 고찰한다.

## 데이터 통합

- 특정 문제에 대해서 트레이드 오프를 고려할 때 적절한 소프트웨어를 선택해야 한다.
    - 하지만 도구를 사용하는 환경을 고려하더라도 복잡한 애플리케이션은 데이터를 여러 가지 다른 방법으로 사용한다.
    - 여러 데이터를 모든 상황에 적합하게 다루는 소프트웨어가 있을 가능성은 낮다.
- 예를 들어 OLTP 데이터베이스와 키워드를 대상으로 질의하는 전문 검색 색인을 통합하는 요구는 일반적이다.
    - 전문 색인 기능이 있는 RDB도 있지만 더 복잡한 검색을 지원하려면 전문적인 탐색 도구가 필요
    - 반대로 검색 색인은 지속성 있는 레코드 시스템으로는 적합하지 않다.

### 파생 데이터에 특화된 도구의 결합

- 데이터를 다른 방식으로 표현하는 수가 늘어날수록 데이터 시스템을 통합하기는 더욱 어렵다.
    - ex) 원본에서 파생된 캐시 객체의 비정규화 버전을 유지하기
- 데이터 사본을 여러 저장소에 유지해야 할 때 입출력을 분명히 해야 한다.
    - 레코드 데이터베이스에 데이터를 입력하고 CDC로 검색 색인에 반영하는 경우 색인은 전적으로 레코드 시스템에서 파생되므로 일관성이 보장된다.
    - 애플리케이션이 검색 색인에 직접 데이터를 기록한다면 쓰기 충돌 등으로 일관성 문제가 발생한다.
    - 모든 쓰기 순서를 결정하는 단일 시스템으로 입력을 밀어 넣을 수 있다면 쓰기를 같은 순서로 처리해 데이터 파생이 훨씬 쉬워진다.
    - 이벤트 로그 기반의 파생 데이터 시스템은 결정적이고 멱등성을 지닌다.
- 파생 데이터 대 분산 트랜잭션
    - 분산 트랜잭션
        - 상호 배타적인 잠금을 사용해 쓰기 순서를 결정한다.
        - 원자적 커밋을 사용해 변경 효과가 한 번 나타나도록 보장
        - 선형성을 보장해 자신이 쓴 내용 읽기 같은 기능을 보장
    - 파생 데이터
        - CDC와 이벤트 소싱은 순서를 결정하는 데 로그를 사용한다.
        - 결정적 재시도와 멱등성을 기반으로 동작한다.
        - 대개 비동기로 갱신되기에 동시간 갱신 보장을 하지 않는다.
- 전체 순서화의 제약
    - 보통 전체 로그 순서를 결정하려면 단일 리더 노드를 통해야하지만 데이터 처리량이 늘어나면 파티셔닝이 필수적이고 그럼 두 파티션 간 순서는 애매해진다.
    - 마이크로서비스의 경우 두 이벤트가 서로 다른 서비스에서 발생했다면 이들 사이엔 정해진 순서가 없다.
    - 어떤 애플리케이션은 클라이언트 측 상태를 유지하고 사용자 입력마다 서버 응답을 기다리지 않고 바로 갱신하는데 이 경우 이벤트 순서가 클라이언트와 서버에서 서로 다를 가능성이 높다.
    - 결론적으로 단일 노드 처리량을 넘어서는 규모와 지리적으로 분산된 설정에서 동작하는 전체 순서 브로드캐스트(합의) 설계는 아직 해결되지 않은 과제다.
- 인과성 획득을 위한 이벤트 순서화
    - 이벤트 간 인과성이 없는 경우 순서가 정해지지 않아도 큰 문제는 아니다.
    - 논리적 타임스탬프를 통해 코디네이션 없이 전체 순서화를 지원할 수는 있지만 여전히 수신자가 잘못된 순서로 전달된 이벤트를 처리해야 한다.
    - 충돌 해소 알고리즘은 예상치 못한 순서로 전송된 이벤트를 처리하는 데 도움을 주지만 사용자에게 알림을 보내는 등의 외부 부수 효과가 있다면 도움이 되지 않는다.

