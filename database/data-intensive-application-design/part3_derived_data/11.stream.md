# 11장 스트림 처리
- ‘스트림’은 일반적으로 시간 흐름에 따라 점진적으로 생산된 데이터를 일컫는다.
- 일괄 처리와 달리 스트림은 데이터가 점진적으로 처리된다.

## 이벤트 스트림 전송

- 스트림 처리에서 입력은 보통 ‘이벤트’라고 한다.
    - 특정 시점에 일어난 사건의 세부 사항
    - 작고 독립된 불변 객체
    - 이벤트 발생 타임스탬프를 포함
    - 텍스트 문자열이나 JSON 또는 이진 형태 등으로 부호화된다.
- 이벤트 스트리밍에서도 한 번 기록한 이벤트를 여러 곳에서 읽을 수 있다.
    - 생산자(producer)가 이벤트를 한 번 생성하면 여러 소비자(consumer)가 처리할 수 있다.
    - 스트림 시스템에선 대개 토픽(topic)이나 스트림으로 관련 이벤트를 묶는다.
- 전통적 데이터베이스는 알림 메커니즘을 강력히 지원하지 않는다.
    - 이론상으론 폴링을 사용하여 데이터베이스만 있다면 스트림 처리를 구현할 수 있지만 풀링은 비용이 크다.
    - 트리거(trigger) 기능이 있긴 하지만 제한적이다.

### 메시징 시스템

- 메시징 시스템은 새로운 이벤트에 대해 소비자에게 알려주려고 쓰이는 방법이다.
    - 다수의 생산자 노드가 같은 토픽으로 메시지 전송 가능
    - 다수의 소비자 노드가 토픽 하나에서 메시지를 소비 가능
    - 메시징 시스템에선 발행/구독(publish/subscribe) 모델을 사용한다.
- 많은 메시지 시스템은 중간 노드 없이 생산자와 소비자가 네트워크로 직접 통신한다.
    - 낮은 지연이 필수인 주식 시장과 금융 산업에서 널리 사용된다. (UDP 멀티캐스트)
    - ZeroMQ 같은 브로커가 필요 없는 메시징 라이브러리도 이 방식을 사용
    - 메시지가 유실될 수도 있기에 애플리케이션 코드로 이를 보완해야하지만 상당히 제한적이다.
- 메시지 브로커(메시지 큐)
    - 메시지 스트림 처리에 최적화된 데이터베이스의 일종이다.
    - 생산자는 브로커로 메시지를 전송하고 소비자는 브로커에서 메시지를 읽는다.
    - 브로커에 데이터가 모이기에 클라이언트(생산자/소비자)의 장애에 쉽게 대처 가능하다.
        - 메시지를 메모리에만 보관할 수도 있지만 디스크에 메시지를 기록하는 브로커도 있다.
        - 소비 속도가 느린 소비자가 있다면 일반적으로 큐가 제한 없이 계속 늘어난다.
    - 소비자는 일반적으로 비동기로 동작한다.
- 메시지 브로커와 데이터베이스의 비교
    - 데이터베이스와 달리 브로커 대부분은 소비자에게 배달 성공 후 자동으로 메시지를 삭제한다.
    - 브로커 대부분은 메시지를 빨리 지우기에 큐 크기가 작다.
    - 데이터베이스는 다양한 데이터 검색을 지원하는 반면 메시지 브로커는 특정 패턴과 부합하는 토픽의 부분 집합을 구독하는 방식을 지원한다.
    - 메시지 브로커는 데이터베이스의 스냅샷 기반의 임의 질의를 하지는 않지만 데이터가 변하면 클라이언트에게 즉시 알려준다.
- 복수 소비자가 같은 토픽에서 메시지를 읽을 때 사용하는 주요 패턴 두 가지가 있다.
    - 로드 밸런싱 - 소비자 중 하나로 전달
    - 팬 아웃 - 모든 소비자에게 전달
- 확인 응답과 재전송
    - 메시지 유실을 막기 위해 메시지 브로커는 확인 응답을 사용한다.
        - 클라이언트는 메시지 처리가 끝나고 브로커가 큐에서 메시지를 제거할 수 있게 브로커에게 명시적으로 알림
    - 브로커가 확인 응답을 받지 않으면 메시지가 처리되지 않았다고 가정하고 다른 소비자에게 다시 전송한다.
    - 메시지 재전송으로 인해 메시지 순서가 순서대로 처리되지 않을 수도 있다.
    - 소비자마다 독립된 큐를 사용하면 순서가 꼬이는 문제를 피할 수는 있다.
