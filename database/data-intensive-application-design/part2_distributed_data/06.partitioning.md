# 06장 파티셔닝
- 데이터셋이 매우 크거나 질의 처리량이 매우 높다면 데이터를 파티션으로 쪼갤 필요가 있다.
- 데이터 파티셔닝을 하는 주된 이유는 확장성이다.

## 파티셔닝과 복제

- 보통 복제와 파티셔닝을 함께 적용해 각 파티션의 복사본을 여러 노드에 저장한다.
    - 각 레코드가 한 파티션에 속하더라도 여러 노드에 저장됨으로 내결함성을 보장
- 한 노드에 여러 파티션을 저장할 수도 있다.
    - 각 파티션의 리더는 한 노드에 할당되고 팔로워들은 다른 노드에 할당
    - 각 노드는 어떤 파티션에게는 리더이면서 다른 파티션에겐 팔로워가 될 수 있다.

## 키-값 데이터 파티셔닝

- 파티셔닝의 목적은 데이터와 질의 부하를 노드 사이에 고르게 분산시키는 것
    - 파티셔닝이 고르지 않아 특정 파티션에 질의 부하가 커지면 쏠렸다(skewed)고 말한다.
    - 불균형하게 부하가 높은 파티션을 핫스팟이라 한다.

### 키 범위 기준 파티셔닝

- 파티셔닝 방법 중 하나는 각 파티션에 연속된 범위의 키를 할당하는 것이다.
- 키 범위 크기가 반드시 동일할 필요는 없는데 데이터가 고르게 분포하지 않을 수 있기 때문이다.
    - 데이터를 고르게 분산시키려면 파티션 경계를 데이터에 맞춰 조정해야 한다.
- 파티션 경계는 수동으로 선택하거나 데이터베이스에서 자동으로 정할 수 있다.
- 각 파티션 내 키는 정렬되어 있기에 범위 스캔이 쉬워지는 이점이 있다.
- 하지만 키 범위 기준 파티셔닝은 특정한 접근 패턴이 핫스팟을 유발하는 단점이 있다.

### 키의 해시값 기준 파티셔닝

- 쏠림과 핫스팟 위험 때문에 키의 해시값을 기준으로 파티셔닝하는 방법이 있다.
- 파티셔닝을 위한 해시 함수
    - 좋은 해시 함수는 쏠린 데이터를 입력 받아 균일하게 분산되게 한다.
    - 파티셔닝용 해시는 암호적으로 강력할 필요는 없다.
- 하지만 키 해시값으로 파티셔닝하면 범위 질의를 효율적으로 실행할 수 없다.
- 카산드라는 두 파티셔닝 전략을 타협해 테이블 선언 시 복합 기본키를 지정할 수 있게 한다.
    - 키의 첫 부분에만 해싱을 적용해 각 파티션에 분배
    - 남은 칼럼은 카산드라의 SS 테이블에서 데이터를 정렬해 연쇄된 색인으로 사용
    - 복합 키의 첫 번째 칼럼에 대해선 범위 질의를 사용할 순 없다.
    - 복합 키의 첫 번째 칼럼을 고정된 값으로 지정하면 다른 칼럼에 대해선 범위 스캔을 효율적으로 실행 가능

### 쏠린 작업부하와 핫스팟 완화

- 파티셔닝을 균등하게 하더라도 특정 키에 대해 작업부하가 극단적으로 몰리는 상황이 존재한다.
    - ex) 소셜 미디어에서 수백만 명의 팔로워를 가진 유명인
- 현대 데이터 시스템은 쏠린 작업부하를 자동으로 보정하지 못해 애플리케이션에서 쏠림을 완화해야 한다.
    - ex) 키의 시작이나 끝에 임의의 숫자를 붙여 한 키에 대한 쓰기가 n개의 다른 키로 균등하게 분산시키는 방식
        - 이 방식은 요청이 몰리는 소수의 키에만 적용하는 편이 좋다.
        - 키에 쪼개서 쓰면 읽기를 실행할 때 추가적인 작업이 필요하고 읽을 때도 여러 키로부터 조합해야하기 때문 → 오버헤드 발생

## 파티셔닝과 보조 색인

- 기본키가 아닌 보조 색인이 연관되면 파티셔닝이 복잡해진다.
- 보조 색인은 보통 레코드를 유일하게 식별하지는 않는다.
- 보조 색인이 있는 데이터베이스를 파티셔닝하는 데 쓰이는 두 가지 방법이 있다.
  - 문서 기반 파티셔닝
  - 용어 기반 파티셔닝

### 문서 기준 보조 색인 파티셔닝

- 데이터베이스를 문서 ID 기준으로 파티셔닝한다.
  - 각 파티션은 자신의 보조 색인을 유지하며 그 파티션에 속하는 문서만 담당
  - 보조 색인으로 질의하는 경우 결과 레코드들이 서로 다른 파티션에 저장되어 있을 가능성이 크다.
- 스캐터/개더(scatter/gatter)
  - 보조 색인으로 질의하는 경우 여러 파티션으로 질의를 보내 결과를 모으는 방법
  - 지연이 크게 발생하기 쉽다.
- 스캐터/개더의 단점에도 불구하고 문서 기준으로 파티셔닝하는 경우가 많다.
  - ex) 몽고DB, 리악, 카산드라, 엘라스틱 서치 등
  - 보조 색인 질의가 단일 파티션에서만 실행되도록 파티셔닝 설계를 권장하지만 항상 가능하진 않다.

### 용어 기준 보조 색인 파티셔닝

- 전역 색인
  - 각 파티션이 자신만의 보조 색인(지역 색인)을 갖는 대신 모든 파티션의 데이터를 담당하는 색인
  - 전역 색인도 병목을 방지하기 위해 여러 노드에 분산 저장된다.
- 용어 기준 보조 색인 파티셔닝이란
  - 모든 파티션의 데이터를 담당하는 전역 색인으로 파티셔닝하는 방식
  - 찾고자 하는 용어에 따라 색인의 파티션이 결정된다.
  - ‘용어’란 문서에 등장하는 모든 단어를 의미
- 보조 색인이 있는 파티션과 해당 보조 색인이 가리키는 실제 레코드는 다른 파티션이 있을 수도 있다.
  - 각 레코드들은 여전히 기본키로 색인되기 때문
- 문서 기반 파티셔닝 색인에 비해 읽기가 효율적이다.
  - 원하는 용어를 포함하는 파티션에 요청을 보내기만 하면 된다.
- 하지만 쓰기가 느리고 복잡하다는 단점이 있다.
  - 특정 문서를 쓸 때 해당 색인의 여러 파티션에 영향을 줄 수 있기 때문
  - 문서에 있는 모든 용어가 서로 다른 노드에 있는 다른 파티션에 속할 수도 있다.
  - 대부분의 경우 비동기로 색인이 갱신되는데 여러 파티션에 걸친 색인 반영이 즉각적인 일관성을 보장하지 않을 수도 있다.

## 파티션 재균형화

- 클러스터에서 한 노드가 담당하던 부하를 다른 노드로 옮김는 과정을 이를 재균형화라고 한다.
  - 시간이 지나면 데이터베이스에 CPU, 디스크, 램이 추가되거나 장애로 인한 새 노드 추가 등의 변화가 생기기 때문
- 재균형화의 최소 요구사항
  - 재균형화 후 부하가 균등하게 분배돼야 한다.
  - 재균형화 도중에도 데이터베이스는 읽기 쓰기 요청을 받아야 한다.
  - 재균형화 속도와 부하 최소화를 위해 노드 사이 데이터가 필요 이상으로 옮겨져서는 안 된다.

### 재균형화 전략

- 쓰면 안 되는 방법 : 해시값에 mod N 연산을 실행
  - mod N 방식은 노드 N대로 나머지 연산을 하여 각 숫자에 키를 배정하는 방식
  - 이 방식의 문제는 노드 개수 N이 바뀌면 대부분의 키가 노드 사이에 옮겨져 재균형화 비용이 지나치게 커진다.
- 파티션 개수 고정
  - 간단한 해결책 - 파티션을 노드 대수보다 많이 만들어 각 노드에 여러 파티션을 할당
    - ex) 노드 10대에 1000개 파티션을 100개씩 할당
  - 재균형화 시 파티션은 노드 사이에서 통째로 이동하기만 하면 되기에 파티션 개수와 파티션에 할당된 키도 변경되지 않는다.
  - 이 방식을 사용하면 보통 파티션 개수가 고정되고 이후에 변하지 않기에 운영이 단순해진다.
    - 다만 처음 설정된 파티션 개수가 최대치가 되므로 미래 증가량을 고려해 충분히 높은 값으로 선택해야 함
- 동적 파티셔닝
  - 파티션 수를 고정하기 어려운 경우 동적 파티셔닝을 사용할 수 있다.
  - 파티션 크기가 임계값을 넘어서면 파티션을 동적으로 분할하고 반대로 임곗값 아래로 떨어지면 인접한 파티션과 합친다.
  - 파티션 개수가 전체 데이터 용량에 맞춰 조정된다는 이점 존재
  - 빈 데이터베이스의 경우 파티션이 하나일 수밖에 없는데 이 때 HBase와 몽고 DB 등은 사전 분할을 지원한다.
    - 초기 파티션 집합을 설정 가능
- 노드 비례 파티셔닝
  - 파티션 개수와 노드대수가 독립적인 위 두 방법과 달리 노드 대수에 비례하여 파티션 개수를 고정하는 방식이다.
    - 카산드라, 케타마(Ketama) 등에서 사용
  - 노드 대수가 변함 없는 동안엔 데이터셋 크기에 비례해 파티션이 증가하지만 노드 대수를 늘리면 파티션 크기는 다시 작아져 개별 파티션 크기를 안정적으로 유지할 수 있다.

### 운영: 자동 재균형화와 수동 재균형화

- 완전 자동 재균형화
  - 관리자 개입 전혀 없이 자동으로 재균형화
- 완전 수동 재균형화
  - 관리자가 명시적으로 파티션을 노드에 할당하도록 설정
- 완전 자동과 수동의 중간 지점
  - 자동으로 파티션 할당을 제안하지만 반영되려면 관리자가 확정해야 한다.
- 재균형화 자동화 주의점
  - 편리할 수는 있지만 예측하기 어렵다.
  - 주의 깊게 처리하지 않으면 노드에 과부하가 걸릴 수 있고 재균형화 진행 중 다른 요청의 성능이 저하될 수도 있다.
  - ex) 노드 한 대에 과부하가 걸려 응답이 느려지면 장애로 탐지해버려 재균형화를 시작하는데 이는 더 큰 부하를 유발해 연쇄 장애가 발생할 우려가 있다.
- 이러한 이유로 재균형화 과정에 완전 자동화는 권장되지 않는다.

## 요청 라우팅

- 클라이언트는 특정 키를 읽을 때 어떤 IP와 포트로 접속해야할까?
  - 서비스 디스커버리(service discovery)가 필요
- 노드 찾기 방법
  - 클라이언트가 아무 노드에 접속한 후 요청을 처리하거나 해당 노드가 올바른 노드로 전달해 응답을 받기
  - 클라이언트의 요청을 먼저 라우팅 계층으로 보내고 라우팅 계층에서 각 요청을 처리할 노드를 알아내 요청을 전달
  - 클라이언트가 파티셔닝 방법과 노드 정보를 알고 있어 중개자 없이 올바른 노드로 직접 접속
- 모든 경우에 핵심 문제는 라우팅 결정을 내리는 구성요소가 어떻게 노드에 할당된 파티션 변경 사항을 인지하느냐이다.
  - 많은 분산 데이터 시스템은 주키버(ZooKeeper) 같은 코디네이션 서비스를 통해 할당 정보를 관리한다.
    - HBase, 솔라클라우드, 카프카 등이 사용
  - 몽고 DB는 자체 설정 서버 구현에 의존하고 몽고스(mongos) 데몬을 라우팅 계층으로 사용한다.
  - 가십 프로토콜(gossip protocol)을 사용할 경우 외부 서비스에 의존하지 않고 클러스터 상태 변화를 노드 사이에 퍼뜨리고 노드 간에 요청을 전달하며 알맞은 노드를 찾는다.
    - 카산드라, 리악 등이 사용

### 병렬 질의 실행

- 대규모 병렬 처리(massively parallel processing, MPP) 관계형 데이터베이스
  - 분석용으로 사용되는 복잡한 질의를 지원하는 전형적인 데이터 웨어하우스
  - MPP 질의 최적화기는 복잡한 질의를 여러 실행 단계와 파티션으로 분해하여 병렬적으로 실행될 수 있게 한다.
