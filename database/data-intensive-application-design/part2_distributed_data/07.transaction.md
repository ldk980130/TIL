# 07장 트랜잭션
## 애매모호한 트랜잭션의 개념

- 현대 거의 모든 관계형/비관계형 데이터베이스는 트랜잭션을 지원한다.
- NoSQL이 인기를 얻기 시작하면서 새로운 세대의 데이터베이스 중 다수는 트랜잭션을 완전히 포기하거나 약한 보장을 지원하기 시작했다.
- 이러한 분산 데이터베이스들의 등장은 고가용성을 유지하려면 트랜잭션을 포기해야 한다는 잘못된 믿음이 퍼지기도 했다.
- 트랜잭션에 존재하는 이점과 한계, 트레이드 오프를 이해할 필요가 있다.

### ACID의 의미

- 실제로는 데이터베이스마다 ACID 구현은 제각각이며 격리성에는 특히 모호함이 많이 있다.
- ACID 표준을 따르지 않는 시스템은 BASE라 불리기도 한다.
    - 기본적인 가용성(Basically Available)을 가지며 유연하고(Soft state), 최종적 일관성(Eventual consistency)을 지닌다는 뜻
- 원자성 (Atomicity)
    - 시스템은 연산을 실행하기 전이나 후의 상태만 있을 수 있으며 중간 상태에서 머물 수 없다.
    - 오류가 발생하면 트랜잭션을 어보트하고 해당 트랜잭션의 모든 내용을 취소하는 능력
    - 원자성은 시스템에 오류가 발생했을 때의 재연산 문제를 단순하게 만들어준다.
    - 원자성은 동시성과 관련이 없는데 이는 여러 프로세스의 동시 접근 시 무슨 일이 생기는지 설명하지 않기 때문이다.
        - 이 문제는 격리성과 관련이 있다.
- 일관성 (Consistency)
    - 일관성은 항상 진실이어야 하는 데이터에 대한 어떤 선언(불변식)을 지키는 속성이다.
    - 하지만 일관성은 애플리케이션 로직에서 제어되어야 하며 데이터베이스는 불변식을 위반하는 데이터를 쓰지 못하도록 막을 수 없다.
        - 외래 키 제약 조건 등은 제외
    - 다른 속성들과 달리 데이터베이스는 일관성을 달성하지 못한다고도 할 수 있다.
- 격리성 (Isolation)
    - 동시에 실행되는 트랜잭션은 서로 격리된다는 것을 의미
    - 직렬성 격리를 사용하면 여러 트랜잭션이 동시에 실행됐더라도 커밋 후의 결과가 순차적으로 실행됐을 때의 결과와 동일하도록 보장한다.
    - 하지만 직렬성 격리는 성능 손해를 동반하기에 거의 사용하지 않고 직렬성 보단 보장이 약하지만 스냅숏 격리를 사용하기도 한다.
- 지속성(Durability)
    - 트랜잭션이 성공적으로 커밋됐다면 장애가 발생하더라도 데이터는 손실되지 않는다는 보장
    - 단일 노드 데이터베이스에선 비휘발성 저장소에 데이터가 기록됐다는 것이고 복제 노드가 있는 데이터베이스에서는 성공적으로 다른 노드 몇 개에 저장했다는 것을 의미할 수도 있다.
    - 당연하지만 완벽한 지속성은 존재하지 않는다.
        - 모든 하드디스크와 백업이 파괴되는 경우

### 단일 객체 연산과 다중 객체 연산

- 다중 객체 트랜잭션 상황에서 데이터들이 동기화된 상태로 유지해야할 필요가 있다.
  - 원자성을 통해 오류가 발생해도 전부 반영되거나 전부 반영되지 않게 한다.
  - 격리성을 통해 여러 트랜잭션이 실행되어도 서로의 중간 내용을 볼 수 없게 한다.
- 비관계형 데이터베이스엔 관계형처럼 연산을 묶는 방법이 없는 경우가 많다.
  - 한 연산 내에 여러 키를 갱신하는 다중 연산에서 부분적으로 갱신된 상태가 도출될 수도 있는 것
- 원자성과 격리성은 단일 객체를 변경하는 경우에도 적용된다.
  - 원자성은 장애 복구용 로그를 써서 구현 가능
  - 격리성은 각 객체에 잠금을 사용해 구현 가능
  - 이러한 단일 객체 연산은 동시에 같은 객체에 쓰려고 할 때 갱신 손실을 방지하는데 유용하다.
- 다중 객체 트랜잭션의 필요성
  - 많은 분산 데이터베이스는 다중 객체 트랜잭션 지원을 포기했는데 이는 여러 파티션에 걸친 트랜잭션을 구현하기 매우 까다롭고 높은 가용성과 성능에도 방해되기 때문이다.
  - 단일 객체 연산만으로 충분한 사용 사례도 많지만 다중 객체 연산이 필요할 때도 있다.
    - 관계형 데이터 모델에서 외래 키 참조가 유효하도록 보장
    - 비정규화된 정보를 갱신할 때 한 번에 여러 객체를 갱신해야 한다.
    - 보조 색인이 있는 경우 값을 변경할 때 색인도 갱신되어야 한다.
- 오류 발생 시의 어보트 처리는 효과적이지만 어보트된 트랜잭션을 재시도하는 것은 생각해볼 필요가 있다.
  - 트랜잭션이 실제론 성공했지만 클라이언트에게 커밋 성공 메시지를 네트워크 오류로 알리지 못한 경우 재시도는 트랜잭션을 두 번 실행하게 한다.
  - 오류가 과부하 때문이라면 트랜잭션 재시도는 문제를 악화시킬 수 있다.
  - 일시적인 오류만 재시도 가치가 있고 영구적인 오류는 재시도해도 소용이 없다.
  - 트랜잭션 재시도가 외부 시스템에 부수 효과를 일으킬 수도 있다. ex) 이메일 전송 기능에 이메일이 2번 감
