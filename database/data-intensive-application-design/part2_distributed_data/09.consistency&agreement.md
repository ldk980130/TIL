# 09장 일관성과 합의
- 분산 시스템에서의 문제를 해결하는 방법
    - 전체 서비스가 실패하도록 두고 오류 메시지를 보여주기
    - 위 해결이 싫다면 결함을 견뎌낼(tolerating) 수 있도록 내결함성 구축하기

> 살아 있지만 틀린 게 나은가, 올바르지만 죽은 게 나은가?
>

- 내결함성이 지닌 분산 시스템이 극복해야 하는 것
    - 네트워크 상의 패킷 손실
    - 패킷 순서의 변경 및 중복
    - 네트워크 지연
    - 노드 장애
- 내결함성을 지닌 시스템을 구축하려면 유용한 보장을 해주는 범용 추상화를 찾고 애플리케이션에서 이 보장에 의존하게 해야 한다.
    - ex) 트랜잭션 추상화를 통해 충돌, 경쟁 조건, 디스크 장애로부터 애플리케이션이 신경쓰지 않게 해줌
    - 분산 시스템에서 중요한 추상화 중 하나는 바로 ‘합의’다.

## 일관성 보장

- 복제 데이터베이스는 대부분 최소한 최종적 일관성을 제공한다.
    - DB에 쓰기를 멈추고 불특정 시간 동안 기다린다면 결국 모든 읽기 요청이 같은 값을 반환한다는 뜻
    - 매우 약한 보장이기도 한데 언제 복제본에 값들이 수렴될지에 대해선 불확실하다.
    - 최종적 일관성의 에지 케이스는 시스템에 결함이 있거나 동시성이 높을 때만 분명히 드러난다.
- 이에 반해 강한 일관성 모델도 존재하는데 그 중 하나가 바로 선형성(linearizability)이다.

## 선형성

- 선형성
    - 정확한 정의는 매우 미묘하다.
    - 기본 아이디어는 시스템에 데이터 복사본이 하나만 있고 모든 연산은 원자적인 것처럼 보이게 만드는 것
- 선형성 시스템에선 클라이언트가 쓰기를 완료하면 데이터베이스를 읽는 모든 클라이언트는 그 값을 바로 볼 수 있어야 한다.
    - 선형성은 다시 말해 최신성 보장(recency guarangee)다.
    - 데이터 복사본이 하나만 있다는 환상을 유지하는 것은 뒤쳐진 캐시나 복제본에서 나온 값이 아니라고 보장해준다는 뜻

### 시스템에 선형성을 부여하는 것은 무엇인가?

- 여러 클라이언트가 동시에 같은 키를 읽고 쓴다고 가정했을 때 쓰기 연산과 시간이 겹치는 읽기 연산은 이전 값을 반환할 수도, 새로운 값을 반환할 수 도 있다.
    - 읽기 연산이 처리되는 시점에 쓰기의 영향을 받았는지 알 수 없기 때문
    - 하지만 이러한 현상은 ‘데이터의 단일 복사본’을 모방하는 시스템에 기대하는 바는 아니다.
- 시스템이 선형적이려면 한 클라이언트의 읽기가 새로운 값을 반환하면 이후의 모든 읽기 또한 새로운 값을 반환해야 한다.
    - 심지어 쓰기 연산이 아직 완료되지 않았더라도 말이다.
- 선형성을 만족하려면 모든 연산들이 항상 시간순으로 진행되어야 하고 결코 뒤로 가서는 안 된다.

### 선형성에 기대기

- 시스템이 선형적으로 동작하려면 요구되는 몇 가지 영역이 있다.
- 잠금과 리더 선출
  - 단일 리더 복제를 사용하는 것처럼 되어야 하기에 스플릿 브레인 현상을 방지해야 한다.
  - 그러려면 리더 선출 시 잠금을 사용할 필요가 있다.
  - 분산 잠금과 리더 선출을 위해 아파치 주키퍼 등의 코디네이션 서비스가 주로 이용된다.
- 제약 조건과 유일성 보장
  - 유일성 제약 조건은 데이터베이스에서 흔하다. ex) 이메일 주소는 사용자 당 유일해야 함
  - 데이터 기록 시 유일성을 강제하려면 선형성이 필요하다.
  - 실제 애플리케이션에서 때때로 이러한 제약을 느슨하게 다룰 때도 있다.
    - ex) 항공기 좌석 예매에서 좌석이 초과되었다면 고객 불편에 대한 보상을 해줄 수 있다.
  - 관계형 저장소에서 외래 키나 속성 제약 조건 등은 선형성을 요구하지 않고도 구현할 수 있다.
- 채널 간 타이밍 의존성
  - 선형성 위반은 시스템에 부가적인 통신 채널이 있으면 발견이 쉬워진다.
  - 선형성의 최신성 보장이 없으면 두 채널 사이에 경쟁 조건이 발생할 수 있다.
    - 웹 서버에서 이미지를 파일 저장소에 업로드 후 웹서버가 메시지 큐를 통해 이미지 크기 변경 모듈로 이미지 크기 리사이징을 시키는 경우
    - 이미지 변경 모듈이 메시지 큐로부터 요청을 받고 파일 저장소에서 리사이징할 이미지를 찾을 때 이미지의 과거 버전을 볼 수도, 아무것도 보지 못할 수도 있다.
  - 부가적인 통신 채널을 제어한다면 복잡성이 추가되겠지만 강한 일관성을 보장할 수 있다.

### 선형성 시스템 구현하기

- 선형성 구현을 간단하게 하는 방법은 정말 데이터 복사본을 하나만 사용하는 것이다.
- 하지만 단일 노드 시스템은 장애에 취약하기에 복제를 사용할 수밖에 없다.
- 복제 방식에 따른 선형성 고려
  - 단일 리더 복제 - 선형적이 될 가능성이 있음
    - 리더나 동기식으로 갱신된 팔로워에서의 읽기는 선형적일 가능성이 있다.
    - 하지만 모든 단일 리더 데이터베이스가 선형적인 것은 아니다.
    - 설계 때문일 수도, 스냅숏 격리나 동시성 버그 때문일 수도 있다.
  - 합의 알고리즘 - 선형적
    - 합의 프로토콜엔 스플릿 브레인과 복제본이 뒤쳐지는 문제를 막을 수 있다.
  - 다중 리더 복제 - 비선형적
    - 여러 노드에서 동시에 쓰기를 처리하고 비동기로 다른 노드에 복제하기 때문
  - 리더 없는 복제 - 아마도 비선형적
    - 정족수 읽기와 쓰기를 통해 엄격한 일관성을 달성할 수 있다고 하지만 정족수 설정에 따라 상이하기위 완전한 진실은 아니다.
    - 느슨한 정족수도 선형성의 가능성을 떨어뜨린다.
- 다이나모 스타일 모델(리더 없는 복제)에서 엄격한 정족수를 사용하더라도 네트워크 지연 변동이 심하면 경쟁 조건이 생길 수 있다.
  - 쓰기에 성공해야 하는 w개를 모두 만족하더라도 각 복제본에 쓰기를 반영하는 시간에 간격이 크다면 r개의 복제본으로부터 읽기 요청 시 타이밍이 따라 다른 결과를 받을 수 있다.
  - 다이나모 스타일에선 선형성을 제공하지 않는다고 보는 게 가장 안전

### 선형성의 비용

- 다중 리더 복제의 경우 네트워크가 단절되도 각 데이터센터는 정상 동작한다.
  - 각 데이터센터에 리더가 존재하기 때문
  - 쓰기 데이터는 단지 큐에 쌓였다가 네트워크 복구 시 다른 데이터센터로 전달되면 된다.
- 단일 리더 복제의 경우 네트워크가 끊기면 리더 없는 데이터센터는 동작할 수 없다.
  - 단일 리더에서는 모든 쓰기와 선형성 읽기는 리더로 보내져야 한다.
  - 팔로워 데이터센터로 접속한 클라이언트는 네트워크가 끊겨있으면 아무것도 할 수가 없다.
- 애플리케이션이 선형성을 요구하느나에 따라 동작이 아래처럼 달라진다.
  - 애플리케이션에서 선형성을 요구하는 경우 다른 복제 서버와 네트워크가 끊기면 문제가 고쳐질 때까지 오류를 반환해야 한다. (즉 가용성이 없다.)
  - 애플리케이션이 선형성을 요구하지 않는다면 복제 서버 간 연결이 끊기더라도 독립적으로 요청을 처리하면 된다. (가용성이 있지만 선형성이 없다.)
  - 즉 선형성이 필요 없다면 네트워크 문제에 더 강인하고 이를 CAP 정리라고 한다.
- CAP 정리
  - 보통 일관성(Consistency), 가용성(Availability), 분단 내성(Partition tolerance) 세 개 중 두 개만 만족시킬 수 있다는 정리
  - 하지만 네트워크 분단은 발생할 수밖에 없는 결함이다.
    - 네트워크 분단이 없다고 단정할 수 있다면 일관성, 가용성 둘 다 지킬 수 있다.
  - 따라서 CAP는 네트워크 분단이 생겼을 때 일관성과 가용성 중 하나를 선택하라는 의미로 보는게 좋다.
  - 이 외에도 CAP 논의에서 ‘가용성’에 대한 모순된 정의가 존재하고 많은 오해와 혼란이 있기에 CAP는 시스템을 잘 이해하는 데 도움이 되지 않는다.
- 선형성과 네트워크 지연
  - 현실에서 선형적인 시스템은 논랄 만큼 드물다.
    - 최신 다중코어 CPU의 램조차 선형적이지 않음
    - 좋은 성능을 위해 CPU 코어가 저마다 메모리 캐시와 저장 버퍼를 갖기 때문
  - 선형성 보장을 제공하지 않기를 택한 여러 분산 데이터베이스도 마찬가지다.
    - 주로 성능을 향상시키기 위해 선형성을 포기
  - 선형성을 제공하는 매우 빠른 알고리즘은 없지만 완화된 일관성 모델은 훨씬 빠를 수 있다.

## 순서화 보장

- 선형성 정의를 다시 말하면 연산들이 잘 정의된 순서대로 실행된다는 것을 암시한다.
- 또한 순서화, 선형성, 합의 사이에는 깊은 연결 관계가 있다.
  - 단일 리더 복제에서 리더의 주 목적은 쓰기 순서를 결정하는 것
  - 트랜잭션에서 직렬성은 연산들이 어떤 일련 순서에 따라 실행되는 것처럼 동작하도록 보장하는 것과 관련이 있다.
  - 분산 시스템에서 타임스탬프와 시계 사용은 무질서한 세상에 질서를 부여하려는 시도

### 순서화와 인과성

- 전체 순서(total ordered)와 부분 순서(partially ordered)
  - 전체 순서란 어떤 두 요소가 있으면 항상 어떤 것이 더 크고 작은지 말할 수 있다.
    - ex) 5와 13중 13이 더 크다고 말할 수 있다.
  - 하지만 수학적 집합은 전체 순서를 정할 수 없고 부분적으로 순서가 정해진다.
    - ex {a, b}가 {b, c}보다 클까?
    - 어떤 경우엔 한 집합이 다른 집합보다 크지만 다른 경우에는 비교 불가능하다.
  - 전체 순서와 부분 순서는 데이터베이스 일관성 모델에 반영된다.
    - 선형적 시스템에선 연산의 전체 순서를 정할 수 있다.
      - 선형적 데이터 스토어에는 동시적 연산이 없고 모든 연산은 하나의 타임라인에 따라 순서가 정해져 있다.
    - 인과성은 전체 순서가 아닌 부분 순서를 정의하는데 이는 연산들이 서로에 대해 순서를 정할 수 있지만 어떤 연산들은 비교할 수 없기 때문이다.
      - 두 이벤트에 인과 관계가 있다면 순서가 있지만 어떤 이벤트들은 인과 관계가 없다.
      - 심지어 두 연산 중 어떤 것도 다른 것보다 먼저 실행되지 않았다면 두 연산이 동시적이라고 말한다.
- 선형성은 인과적 일관성보다 강하다. (선형성이 인과성을 내포)
  - 어떤 시스템이 선형적이라면 인과성도 올바르게 유지한다.
  - 선형성이 인과성을 포함하는게 매력적이겠지만 시스템의 선형성은 높은 비용을 요구하고 가용성을 해친다.
  - 하지만 많은 경우 시스템이 진짜로 필요한 것은 선형성이 아닌 인과적 일관성이고 이는 더 효율적으로 구현될 수 있다.
- 인과적 의존성 담기
  - 비선형적 시스템이 인과성을 유지하려면 어떤 연산이 다른 어떤 연산보다 먼저 실행됐는지 알아야 한다.
    - 이는 부분 순서다.
    - 동시 실행 연산은 상관 없지만 인과가 있는 연산은 순서를 지키며 처리되어야 한다.
  - 인과적 의존성을 결정하려면 시스템의 노드에 관한 ‘지식’을 기술해야 한다.
    - ex) 같은 키에 대한 동시 쓰기 검출
    - ex) 데이터의 어떤 버전을 읽었는지 알기

### 일련번호 순서화

- 일련번호나 타임스탬프를 사용해서 이벤트 순서를 정할 수 있다.
  - 타임스탬프는 일 기준 시계가 아닌 논리적 시계에서 얻어도 된다.
- 인과성에 일관적인 전체 순서대로 일련번호를 생성할 수 있다.
  - 인과적으로 먼저 실행됐다면 전체 순서에서도 먼저다.
- 단일 리더 복제 데이터베이스에선 복제 로그가 전체 순서를 정의한다.
  - 리더는 연산마다 단조 증가 일련번호를 할당
  - 팔로워가 복제 로그에 나오는 순서대로 쓰기를 적용하면 팔로워 상태는 언제나 인과성에 일관적이다.
- 비인과적 일련번호 생성기
  - 단일 리더가 아니라면 연산에 사용할 일련번호가 겹칠 수도 있기에 다양한 방안이 사용된다.
    - 각 노드가 자신만의 독립적인 일련번호 집합 생성 (ex. 한 노드는 홀수만, 한 노드는 짝수만)
    - 해상도가 충분히 높은 타임스탬프
    - 각 노드 당 일련번호 블록을 미리 할당
  - 하지만 이렇게 생성한 일련번호는 인과성에 일관적이지 않아 연산들의 순서를 올바르게 담지 못한다.
- 램포트 타임스탬프
  - 인과성에 일관적인 일련번호를 생성하는 방법
  - 각 노드는 고유 식별자를 갖고 처리한 연산 개수를 카운터로 유지한다.
  - (카운터, 노드ID) 쌍의 형태고 카운터 값이 같으면 노드 ID가 더 큰 것이 타임스탬프가 크다.
  - 모든 노드와 클라이언트는 카운터 값 중 최댓값을 추적하고 모든 요청에 그 최댓값을 포함시킨다.
- 인과성에 일관적인 타임스탬프의 문제점은 연산의 전체 순서가 모든 연산을 모은 후에야 드러난다는 것이다.
  - 어떤 연산을 생성했지만 그것이 무엇인지 아직 알 수 없다면 연산 최종 순서를 만들 수 없다.
  - 만약 분산 환경에서 유일성 제약 조건을 구현하려면 전체 순서가 있는 것만으로는 충분치 않다.
  - 언제 전체 순서가 확정되는지 알아야 한다.
    - 유일성 제약이 있는 값을 생성하는 연산이 있고, 전체 순서상 그 연산보다 앞서는, 동일한 유일성 제약 값을 생성하는 연산을 다른 어떤 노드도 끼워 넣을 수 없다면 그 연산을 성공 처리해도 안전하다.

### 전체 순서 브로드캐스트

- 단일 리더 복제에선 한 노드를 리더로 선택하고 단일 CPU 코어에서 모든 연산을 차례대로 배열해 연산 전체 순서를 정한다.
- 분산 시스템에선 모든 노드에서 연산 전체 순서가 동일하도록 합의하기가 까다롭다.
  - 타임스탬프 순서화로 유일성 제약 조건을 구현하기 어려움
- 전체 순서 브로드캐스트(total order broadcast), 원자적 브로드캐스트(atomic broadcast)
  - 분산 시스템에서 전체 순서를 정하기 위해 노드 사이 메시지를 교환하는 프로토콜
  - 신뢰성 있는 전달 - 어떤 메시지도 손실되지 않고 한 노드에 전달되면 모든 노드에 전달된다.
  - 전체 순서가 정해진 전달 - 메시지는 모든 노드에 같은 순서로 전달된다.
- 전체 순서 브로드캐스트의 사용
  - 주키퍼나 etcd 같은 합의 서비스에선 전체 순서 브로드캐스트를 실제로 구현한다.
  - 전체 순서 브로드캐스트를 통해 모든 복제 서버가 같은 쓰기 연산을 순서대로 처리하면 복제 서버들은 일관성 있는 상태를 유지하게 된다. (상태 기계 복제)
  - 직렬성 트랜잭션을 구현하는 데도 사용할 수 있따.
  - 펜싱 토큰 기반 잠금 서비스 구현에도 유용하다.
- 전체 순서 브로드캐스트로 선형성 저장소 구현
  - 전체 순서 브로드캐스트는 선형성과 완전 똑같진 않지만 밀접한 관계가 있다.
  - 전체 순서 브로드캐스트는 비동기식이라 고정된 순서로 메시지가 전달되지만 언제 전달될진 보장되지 않는다.
    - 어떤 수신자는 뒤쳐질 수 있다.
  - 전체 순서 브로드캐스트를 추가 전용 로그로 사용해 선형성 compare-and-set 연산을 통해 유일성 제약을 아래와 같이 구현할 수 있다.
    - 메시지를 로그에 추가해 점유하기 원하는 유일값을 시험적으로 가리킴
    - 로그를 읽고, 추가한 메시지가 되돌아오기를 기다림
    - 원하는 값을 점유하려고 있는 메시지가 있는지 확인한다. 원하는 유일 값에 해당하는 첫 번째 메시지가 자신의 메시지라면 성공, 다른 사용자가 보낸 메시지라면 연산을 어보트시킨다.
  - 이는 선형성 쓰기를 보장하지만 선형성 읽기를 보장하진 않는데 읽기를 선형적으로 하려면 몇 가지 선택지가 있다.
    - 로그를 통해 순차 읽기 하는 방법 - 로그에 메시지를 추가하고 로그를 읽어 메시지가 되돌아왔을 때 실제 읽기를 수행하는 것.
    - 로그에서 최신 로그 메시지의 위치를 선형적 방법으로 얻을 수 있다면 그 위치를 질의하고 그 위치까지의 모든 항목이 전달 되기를 기다린 후 읽기를 수행
    - 쓰기 실행 시 동기식으로 갱신된 최신성이 보장된 복제 서버에서 읽기
- 선형성 저장소를 사용해 전체 순서 브로드캐스트 구현하는 것도 가능하다.
  - 전체 순서 브로드캐스트를 통해 보내고 싶은 메시지에 선형성 정수로 increment-and-get 연산을 수행 후 얻은 값을 일련번호로 메시지에 붙이면 수신자들은 일련번호 순서대로 메시지를 전달한다.
  - 램포트 타임스탬프와는 달리 틈이 없는 순열을 형성한다.
    - 메시지 4를 받고 6을 받았다면 메시지 5를 기다려야 한다는 것을 알 수 있음
    - 램포트 타임스탬프에선 불가능하다.
  - 원자적 increment-and-get 연산이 지원되는 선형성 정수를 만드는 것은 실패가 없다면 쉽다.
    - 문제는 네트워크 등 장애 시 그 값을 복구하는 것
  - 선형성 일련번호 생성기에 고심하다 보면 합의 알고리즘에 도달하게 된다.
