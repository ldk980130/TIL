# 09장 일관성과 합의
- 분산 시스템에서의 문제를 해결하는 방법
    - 전체 서비스가 실패하도록 두고 오류 메시지를 보여주기
    - 위 해결이 싫다면 결함을 견뎌낼(tolerating) 수 있도록 내결함성 구축하기

> 살아 있지만 틀린 게 나은가, 올바르지만 죽은 게 나은가?
>

- 내결함성이 지닌 분산 시스템이 극복해야 하는 것
    - 네트워크 상의 패킷 손실
    - 패킷 순서의 변경 및 중복
    - 네트워크 지연
    - 노드 장애
- 내결함성을 지닌 시스템을 구축하려면 유용한 보장을 해주는 범용 추상화를 찾고 애플리케이션에서 이 보장에 의존하게 해야 한다.
    - ex) 트랜잭션 추상화를 통해 충돌, 경쟁 조건, 디스크 장애로부터 애플리케이션이 신경쓰지 않게 해줌
    - 분산 시스템에서 중요한 추상화 중 하나는 바로 ‘합의’다.

## 일관성 보장

- 복제 데이터베이스는 대부분 최소한 최종적 일관성을 제공한다.
    - DB에 쓰기를 멈추고 불특정 시간 동안 기다린다면 결국 모든 읽기 요청이 같은 값을 반환한다는 뜻
    - 매우 약한 보장이기도 한데 언제 복제본에 값들이 수렴될지에 대해선 불확실하다.
    - 최종적 일관성의 에지 케이스는 시스템에 결함이 있거나 동시성이 높을 때만 분명히 드러난다.
- 이에 반해 강한 일관성 모델도 존재하는데 그 중 하나가 바로 선형성(linearizability)이다.

## 선형성

- 선형성
    - 정확한 정의는 매우 미묘하다.
    - 기본 아이디어는 시스템에 데이터 복사본이 하나만 있고 모든 연산은 원자적인 것처럼 보이게 만드는 것
- 선형성 시스템에선 클라이언트가 쓰기를 완료하면 데이터베이스를 읽는 모든 클라이언트는 그 값을 바로 볼 수 있어야 한다.
    - 선형성은 다시 말해 최신성 보장(recency guarangee)다.
    - 데이터 복사본이 하나만 있다는 환상을 유지하는 것은 뒤쳐진 캐시나 복제본에서 나온 값이 아니라고 보장해준다는 뜻

### 시스템에 선형성을 부여하는 것은 무엇인가?

- 여러 클라이언트가 동시에 같은 키를 읽고 쓴다고 가정했을 때 쓰기 연산과 시간이 겹치는 읽기 연산은 이전 값을 반환할 수도, 새로운 값을 반환할 수 도 있다.
    - 읽기 연산이 처리되는 시점에 쓰기의 영향을 받았는지 알 수 없기 때문
    - 하지만 이러한 현상은 ‘데이터의 단일 복사본’을 모방하는 시스템에 기대하는 바는 아니다.
- 시스템이 선형적이려면 한 클라이언트의 읽기가 새로운 값을 반환하면 이후의 모든 읽기 또한 새로운 값을 반환해야 한다.
    - 심지어 쓰기 연산이 아직 완료되지 않았더라도 말이다.
- 선형성을 만족하려면 모든 연산들이 항상 시간순으로 진행되어야 하고 결코 뒤로 가서는 안 된다.

### 선형성에 기대기

- 시스템이 선형적으로 동작하려면 요구되는 몇 가지 영역이 있다.
- 잠금과 리더 선출
  - 단일 리더 복제를 사용하는 것처럼 되어야 하기에 스플릿 브레인 현상을 방지해야 한다.
  - 그러려면 리더 선출 시 잠금을 사용할 필요가 있다.
  - 분산 잠금과 리더 선출을 위해 아파치 주키퍼 등의 코디네이션 서비스가 주로 이용된다.
- 제약 조건과 유일성 보장
  - 유일성 제약 조건은 데이터베이스에서 흔하다. ex) 이메일 주소는 사용자 당 유일해야 함
  - 데이터 기록 시 유일성을 강제하려면 선형성이 필요하다.
  - 실제 애플리케이션에서 때때로 이러한 제약을 느슨하게 다룰 때도 있다.
    - ex) 항공기 좌석 예매에서 좌석이 초과되었다면 고객 불편에 대한 보상을 해줄 수 있다.
  - 관계형 저장소에서 외래 키나 속성 제약 조건 등은 선형성을 요구하지 않고도 구현할 수 있다.
- 채널 간 타이밍 의존성
  - 선형성 위반은 시스템에 부가적인 통신 채널이 있으면 발견이 쉬워진다.
  - 선형성의 최신성 보장이 없으면 두 채널 사이에 경쟁 조건이 발생할 수 있다.
    - 웹 서버에서 이미지를 파일 저장소에 업로드 후 웹서버가 메시지 큐를 통해 이미지 크기 변경 모듈로 이미지 크기 리사이징을 시키는 경우
    - 이미지 변경 모듈이 메시지 큐로부터 요청을 받고 파일 저장소에서 리사이징할 이미지를 찾을 때 이미지의 과거 버전을 볼 수도, 아무것도 보지 못할 수도 있다.
  - 부가적인 통신 채널을 제어한다면 복잡성이 추가되겠지만 강한 일관성을 보장할 수 있다.

### 선형성 시스템 구현하기

- 선형성 구현을 간단하게 하는 방법은 정말 데이터 복사본을 하나만 사용하는 것이다.
- 하지만 단일 노드 시스템은 장애에 취약하기에 복제를 사용할 수밖에 없다.
- 복제 방식에 따른 선형성 고려
  - 단일 리더 복제 - 선형적이 될 가능성이 있음
    - 리더나 동기식으로 갱신된 팔로워에서의 읽기는 선형적일 가능성이 있다.
    - 하지만 모든 단일 리더 데이터베이스가 선형적인 것은 아니다.
    - 설계 때문일 수도, 스냅숏 격리나 동시성 버그 때문일 수도 있다.
  - 합의 알고리즘 - 선형적
    - 합의 프로토콜엔 스플릿 브레인과 복제본이 뒤쳐지는 문제를 막을 수 있다.
  - 다중 리더 복제 - 비선형적
    - 여러 노드에서 동시에 쓰기를 처리하고 비동기로 다른 노드에 복제하기 때문
  - 리더 없는 복제 - 아마도 비선형적
    - 정족수 읽기와 쓰기를 통해 엄격한 일관성을 달성할 수 있다고 하지만 정족수 설정에 따라 상이하기위 완전한 진실은 아니다.
    - 느슨한 정족수도 선형성의 가능성을 떨어뜨린다.
- 다이나모 스타일 모델(리더 없는 복제)에서 엄격한 정족수를 사용하더라도 네트워크 지연 변동이 심하면 경쟁 조건이 생길 수 있다.
  - 쓰기에 성공해야 하는 w개를 모두 만족하더라도 각 복제본에 쓰기를 반영하는 시간에 간격이 크다면 r개의 복제본으로부터 읽기 요청 시 타이밍이 따라 다른 결과를 받을 수 있다.
  - 다이나모 스타일에선 선형성을 제공하지 않는다고 보는 게 가장 안전

### 선형성의 비용

- 다중 리더 복제의 경우 네트워크가 단절되도 각 데이터센터는 정상 동작한다.
  - 각 데이터센터에 리더가 존재하기 때문
  - 쓰기 데이터는 단지 큐에 쌓였다가 네트워크 복구 시 다른 데이터센터로 전달되면 된다.
- 단일 리더 복제의 경우 네트워크가 끊기면 리더 없는 데이터센터는 동작할 수 없다.
  - 단일 리더에서는 모든 쓰기와 선형성 읽기는 리더로 보내져야 한다.
  - 팔로워 데이터센터로 접속한 클라이언트는 네트워크가 끊겨있으면 아무것도 할 수가 없다.
- 애플리케이션이 선형성을 요구하느나에 따라 동작이 아래처럼 달라진다.
  - 애플리케이션에서 선형성을 요구하는 경우 다른 복제 서버와 네트워크가 끊기면 문제가 고쳐질 때까지 오류를 반환해야 한다. (즉 가용성이 없다.)
  - 애플리케이션이 선형성을 요구하지 않는다면 복제 서버 간 연결이 끊기더라도 독립적으로 요청을 처리하면 된다. (가용성이 있지만 선형성이 없다.)
  - 즉 선형성이 필요 없다면 네트워크 문제에 더 강인하고 이를 CAP 정리라고 한다.
- CAP 정리
  - 보통 일관성(Consistency), 가용성(Availability), 분단 내성(Partition tolerance) 세 개 중 두 개만 만족시킬 수 있다는 정리
  - 하지만 네트워크 분단은 발생할 수밖에 없는 결함이다.
    - 네트워크 분단이 없다고 단정할 수 있다면 일관성, 가용성 둘 다 지킬 수 있다.
  - 따라서 CAP는 네트워크 분단이 생겼을 때 일관성과 가용성 중 하나를 선택하라는 의미로 보는게 좋다.
  - 이 외에도 CAP 논의에서 ‘가용성’에 대한 모순된 정의가 존재하고 많은 오해와 혼란이 있기에 CAP는 시스템을 잘 이해하는 데 도움이 되지 않는다.
- 선형성과 네트워크 지연
  - 현실에서 선형적인 시스템은 논랄 만큼 드물다.
    - 최신 다중코어 CPU의 램조차 선형적이지 않음
    - 좋은 성능을 위해 CPU 코어가 저마다 메모리 캐시와 저장 버퍼를 갖기 때문
  - 선형성 보장을 제공하지 않기를 택한 여러 분산 데이터베이스도 마찬가지다.
    - 주로 성능을 향상시키기 위해 선형성을 포기
  - 선형성을 제공하는 매우 빠른 알고리즘은 없지만 완화된 일관성 모델은 훨씬 빠를 수 있다.
