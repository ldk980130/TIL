# 05장 복제
- 복제가 필요한 이유
    - 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄인다.
    - 시스템 일부에 장애가 발생해도 지속적으로 동작할 수 있게 가용성을 높인다.
    - 읽기 질의를 제공하는 장비 수를 확장해 읽기 처리량을 늘린다.
- 복제에서 모든 어려움은 복제된 데이터의 변경 처리에 있다.
- 노드 간 변경 복제를 위한 세 가지 인기 알고리즘이 있다.
    - 단일 리더 (single-leader)
    - 다중 리더 (multi-leader)
    - 리더 없는 (leaderless)

## 리더와 팔로워

- 복제 서버(replica) : 데이터베이스 복사본을 저장하는 각 노드
- 리더 기반 복제(leader-based replication)
    - 또는 능동/수동, 마스터 슬레이브 복제라고도 한다.
    - 복제 서버 중 하나를 리더(마스터 or 프라이머리)로 지정 후 리더가 먼저 데이터를 기록하게 된다.
    - 다른 복제 서버(팔로워 or 슬레피브)는 리더의 데이터 변경을 복제 로그나 변경 스트림 일부로 전달 받아 복사본을 갱신한다.
    - 쓰기는 리더에게만 허용되고 질의는 팔로워에게 가능하다.
- 이러한 복제 모드는 다양한 데이터베이스에 내장된 기능으로 제공한다.

### 동기식 대 비동기식 복제

- 동기식 복제
    - 리더는 팔로워가 쓰기를 수신했는지 확인할 때까지 대기한다.
    - 메시지 처리 전까지 상당한 지연이 발생할 수 있다.
    - 장점은 리더와 팔로워가 일관성 있게 최신 데이터 복사본을 가지는 것을 보장한다.
    - 단점은 팔로워가 응답하지 않는다면 쓰기가 처리될 수 없다.
- 비동기식 복제
    - 리더는 팔로워가 수신했는지 기다리지 않는다.
    - 리더에만 쓰기를 성공하면 되기에 지연이 낮다.
    - 팔로워가 응답하지 않더라도 서비스를 지속할 수 있다.
- 보통 리더 기반 복제는 완전 비동기식으로 구성한다.
    - 팔로워에 쓰기가 유실될 수 있어 지속성을 보장하지는 못한다.
    - 그럼에도 비동기식 복제는 많이 사용되는 방식이다.

### 새로운 팔로워 설정

- 새로운 팔로워를 설정해야할 때가 있다.
    - 복제 서버 수 증설
    - 장애 노드의 대체
- 새로운 팔로워 설정 시 리더의 데이터를 복사하는 방식
    - 전체 데이터베이스를 가능한 잠그지 않고 스냅숏을 가져온다.
    - 스냅숏을 새로운 팔로워 노드에 복사한다.
    - 팔로워는 리더에 연결해 스냅숏 이후의 데이터 변경을 요청한다.
    - 팔로워가 스냅숏 이후 변경의 미처리분을 모두 처리했을 때 따라잡았다고 말하고 이제부터 리더에 발생하는 데이터 변화를 이어 처리 가능하다.

### 노드 중단 처리

- 팔로워 장애: 따라잡기 복구
  - 팔로워는 리더로부터 수신한 데이터 변경 로그를 보관한다.
  - 팔로워에 장애가 발생하면 마지막으로 처리된 트랜잭션의 변경 로그를 확인해 복구되고 나서 이후 데이터 변경을 모두 리더에게 요청할 수 있다.
  - 변경이 모두 적용되면 리더를 따라잡게 된다.
- 리더 장애: 장애 복구 (fail over)
  - 리더에 장애 발생 시 팔로워 중 하나를 새로운 리더로 승격해야 한다.
  - 클라이언트는 새로운 리더로 연결을 재설정해야하며 팔로워 또한 새로운 리더로부터 데이터 변경을 소비하기 시작해야 한다.
  - 이 같은 장애 복구는 수동 또는 자동으로 진행할 수 있는데 꽤나 까다롭다.

### 복제 로그 구현

- 구문 기반 복제
  - 리더가 모든 쓰기 요청(구문(statement))을 기록한 뒤 쓰기 실행 후 구문 로그를 팔로워에 전송
  - 팔로워는 SQL 구문을 파싱하고 실행한다.
  - 구문 기반 복제의 허점
    - `NOW`나 `RAND` 같은 비결정적 함수 호출은 복제 서버마다 다른 값을 생성할 수도 있다.
    - 자동증가 칼럼 같이 DB 데이터에 의존한다면 각 복제 서버에서 정확히 같은 순서로 실행되지 않으면 다른 결과가 나올 수 있다.
    - 부수 효과를 가진 구문은 각 복제 서버에서 다른 부수 효과가 발생할 수도 있다.
- 쓰기 전 로그 배송
  - 모든 쓰기를 append-only 바이트 열 로그로 저장하고 팔로워가 이 로그를 처리하면 리더와 정확히 같은 데이터 구조의 복제본을 만들 수 있다.
  - PostgreSQL과 오라클 등에서 사용된다.
  - 쓰기 전 로그 배송의 단점
    - 로그가 제일 저수준의 데이터를 기록하기에 저장소 엔진과 밀접하게 엮인다.
    - 데이터베이스가 저장소 형식을 다른 버전으로 변경한다면 리더와 팔로워의 소프트웨어 버전을 다르게 실행할 수 없다.
    - 만약 복제 프로토콜이 버전 불일치를 허용하지 않는다면 업그레이드 시 다운 타임이 필요하다.
- 논리적(로우 기반) 로그 복제
  - 복제 로그와 저장소 엔진 내부를 분리하기 위해 논리적 로그(logical log)를 사용하는 형식
  - 관계형 데이트베이스용 논리적 로그는 대개 로우 단위의 레코드 열이다.
    - 삽입된 로우의 로그는 모든 칼럼의 새 값을 포함
    - 삭제된 로우의 로그는 로우를 색별하는 정보를 포함
    - 갱신된 로우의 로그는 로우를 식별하는 정보와 모든 칼럼의 새 값을 포함
  - MySQL의 이진 로그가 이 접근 방식을 사용
  - 논리적 로그는 저장소 엔진 버전을 다르게 실행해도 호환 가능하다.
  - 논리적 로그 형식은 외부 애플리케이션이 파싱하기 쉬운 구조이기도 하다.
- 트리거 기반 복제
  - 위 복제 방식들과 달리 유연성이 필요한 경우 트리거를 통해 사용자 정의 코드를 등록할 수 있다.
    - ex) 관계형 데이터베이스에서 사용하는 트리거 or 스토어드 프로시저
  - 사용자 정의 애플리케이션 코드는 데이터가 변경되면 자동으로 실행된다.
    - 데이터 변경을 분리된 테이블에 로깅할 수 있는 기회를 가져 외부 프로세스가 이를 읽을 수도 있다.
  - 트리거 기반 복제는 많은 오버헤드가 발생하지만 유연성 때문에 유용한 경우가 있다.
