# 05장 복제
- 복제가 필요한 이유
    - 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄인다.
    - 시스템 일부에 장애가 발생해도 지속적으로 동작할 수 있게 가용성을 높인다.
    - 읽기 질의를 제공하는 장비 수를 확장해 읽기 처리량을 늘린다.
- 복제에서 모든 어려움은 복제된 데이터의 변경 처리에 있다.
- 노드 간 변경 복제를 위한 세 가지 인기 알고리즘이 있다.
    - 단일 리더 (single-leader)
    - 다중 리더 (multi-leader)
    - 리더 없는 (leaderless)

## 리더와 팔로워

- 복제 서버(replica) : 데이터베이스 복사본을 저장하는 각 노드
- 리더 기반 복제(leader-based replication)
    - 또는 능동/수동, 마스터 슬레이브 복제라고도 한다.
    - 복제 서버 중 하나를 리더(마스터 or 프라이머리)로 지정 후 리더가 먼저 데이터를 기록하게 된다.
    - 다른 복제 서버(팔로워 or 슬레피브)는 리더의 데이터 변경을 복제 로그나 변경 스트림 일부로 전달 받아 복사본을 갱신한다.
    - 쓰기는 리더에게만 허용되고 질의는 팔로워에게 가능하다.
- 이러한 복제 모드는 다양한 데이터베이스에 내장된 기능으로 제공한다.

### 동기식 대 비동기식 복제

- 동기식 복제
    - 리더는 팔로워가 쓰기를 수신했는지 확인할 때까지 대기한다.
    - 메시지 처리 전까지 상당한 지연이 발생할 수 있다.
    - 장점은 리더와 팔로워가 일관성 있게 최신 데이터 복사본을 가지는 것을 보장한다.
    - 단점은 팔로워가 응답하지 않는다면 쓰기가 처리될 수 없다.
- 비동기식 복제
    - 리더는 팔로워가 수신했는지 기다리지 않는다.
    - 리더에만 쓰기를 성공하면 되기에 지연이 낮다.
    - 팔로워가 응답하지 않더라도 서비스를 지속할 수 있다.
- 보통 리더 기반 복제는 완전 비동기식으로 구성한다.
    - 팔로워에 쓰기가 유실될 수 있어 지속성을 보장하지는 못한다.
    - 그럼에도 비동기식 복제는 많이 사용되는 방식이다.

### 새로운 팔로워 설정

- 새로운 팔로워를 설정해야할 때가 있다.
    - 복제 서버 수 증설
    - 장애 노드의 대체
- 새로운 팔로워 설정 시 리더의 데이터를 복사하는 방식
    - 전체 데이터베이스를 가능한 잠그지 않고 스냅숏을 가져온다.
    - 스냅숏을 새로운 팔로워 노드에 복사한다.
    - 팔로워는 리더에 연결해 스냅숏 이후의 데이터 변경을 요청한다.
    - 팔로워가 스냅숏 이후 변경의 미처리분을 모두 처리했을 때 따라잡았다고 말하고 이제부터 리더에 발생하는 데이터 변화를 이어 처리 가능하다.

### 노드 중단 처리

- 팔로워 장애: 따라잡기 복구
  - 팔로워는 리더로부터 수신한 데이터 변경 로그를 보관한다.
  - 팔로워에 장애가 발생하면 마지막으로 처리된 트랜잭션의 변경 로그를 확인해 복구되고 나서 이후 데이터 변경을 모두 리더에게 요청할 수 있다.
  - 변경이 모두 적용되면 리더를 따라잡게 된다.
- 리더 장애: 장애 복구 (fail over)
  - 리더에 장애 발생 시 팔로워 중 하나를 새로운 리더로 승격해야 한다.
  - 클라이언트는 새로운 리더로 연결을 재설정해야하며 팔로워 또한 새로운 리더로부터 데이터 변경을 소비하기 시작해야 한다.
  - 이 같은 장애 복구는 수동 또는 자동으로 진행할 수 있는데 꽤나 까다롭다.

### 복제 로그 구현

- 구문 기반 복제
  - 리더가 모든 쓰기 요청(구문(statement))을 기록한 뒤 쓰기 실행 후 구문 로그를 팔로워에 전송
  - 팔로워는 SQL 구문을 파싱하고 실행한다.
  - 구문 기반 복제의 허점
    - `NOW`나 `RAND` 같은 비결정적 함수 호출은 복제 서버마다 다른 값을 생성할 수도 있다.
    - 자동증가 칼럼 같이 DB 데이터에 의존한다면 각 복제 서버에서 정확히 같은 순서로 실행되지 않으면 다른 결과가 나올 수 있다.
    - 부수 효과를 가진 구문은 각 복제 서버에서 다른 부수 효과가 발생할 수도 있다.
- 쓰기 전 로그 배송
  - 모든 쓰기를 append-only 바이트 열 로그로 저장하고 팔로워가 이 로그를 처리하면 리더와 정확히 같은 데이터 구조의 복제본을 만들 수 있다.
  - PostgreSQL과 오라클 등에서 사용된다.
  - 쓰기 전 로그 배송의 단점
    - 로그가 제일 저수준의 데이터를 기록하기에 저장소 엔진과 밀접하게 엮인다.
    - 데이터베이스가 저장소 형식을 다른 버전으로 변경한다면 리더와 팔로워의 소프트웨어 버전을 다르게 실행할 수 없다.
    - 만약 복제 프로토콜이 버전 불일치를 허용하지 않는다면 업그레이드 시 다운 타임이 필요하다.
- 논리적(로우 기반) 로그 복제
  - 복제 로그와 저장소 엔진 내부를 분리하기 위해 논리적 로그(logical log)를 사용하는 형식
  - 관계형 데이트베이스용 논리적 로그는 대개 로우 단위의 레코드 열이다.
    - 삽입된 로우의 로그는 모든 칼럼의 새 값을 포함
    - 삭제된 로우의 로그는 로우를 색별하는 정보를 포함
    - 갱신된 로우의 로그는 로우를 식별하는 정보와 모든 칼럼의 새 값을 포함
  - MySQL의 이진 로그가 이 접근 방식을 사용
  - 논리적 로그는 저장소 엔진 버전을 다르게 실행해도 호환 가능하다.
  - 논리적 로그 형식은 외부 애플리케이션이 파싱하기 쉬운 구조이기도 하다.
- 트리거 기반 복제
  - 위 복제 방식들과 달리 유연성이 필요한 경우 트리거를 통해 사용자 정의 코드를 등록할 수 있다.
    - ex) 관계형 데이터베이스에서 사용하는 트리거 or 스토어드 프로시저
  - 사용자 정의 애플리케이션 코드는 데이터가 변경되면 자동으로 실행된다.
    - 데이터 변경을 분리된 테이블에 로깅할 수 있는 기회를 가져 외부 프로세스가 이를 읽을 수도 있다.
  - 트리거 기반 복제는 많은 오버헤드가 발생하지만 유연성 때문에 유용한 경우가 있다.

## 복제 지연 문제

- 애플리케이션이 비동기 팔로워에서 데이터를 읽을 때 팔로워가 뒤쳐진다면 지난 정보를 볼 수도 있다.
- 물론 이러한 불일치는 일시적인 상태이고 최종적 일관성에 의해 팔로워는 결국 리더와 일치하게 될 것이다.
- 하지만 시스템이 가용량 근처에서 동작하거나 네트워크 문제 발생 시 지연은 수 초에서 수 분으로 증가하며 문제가 발생할 수 있다.

### 자신이 쓴 내용 읽기

- 복제 지연으로 인해 사용자가 자신이 제출한 데이터를 즉시 볼 수 없다면 데이터가 유실된 것처럼 보일 것이다.
- 쓰기 후 읽기 일관성
  - 사용자가 페이지를 재로딩 했을 때 자신의 모든 갱신을 볼 수 있음을 보장
  - 다른 사용자에 대해선 일정 시간 이후까지 갱신을 보장하지 않을 수도 있다.
- 리더 기반 복제 시스템에서 쓰기 후 읽기 일관성 보장 방법들
  - 사용자가 수정한 내용은 무조건 리더에서 읽기를 보장
    - ex) 소셜 네트워크에서 사용자 프로필(자신의 데이터) 질의는 무조건 리더에서 하도록 규칙 지정
  - 마지막 갱신 시각 기준 1분 동안은 리더에서 모든 읽기를 수행
    - 애플리케이션 내 대부분 내용을 사용자가 편집 가능하다면 생각할 수 있는 방안
    - 또한 복제 지연을 모니터링하여 리더보다 1분 이상 늦은 모든 팔로워에 대한 질의를 금지할 수 있다.
  - 클라이언트가 가장 최근 쓰기의 타임프탬프를 기억하고 복제 서버가 아직 최신 내용이 아닌 경우에는 다른 복제 서버가 읽기를 처리하거나 따라잡을 때까지 질의를 대기시킬 수 있다.
- 동일 사용자가 여러 디바이스로 접근할 때 디바이스 간 쓰기 후 일관성을 제공해야 한다면 고려할 점이 늘어난다.
  - 사용자의 마지막 갱신 타임스탬프를 기억하려면 다른 디바이스의 갱신 시각은 알 수 없기에 이 메타데이터는 중앙집중식으로 관리해야 한다.
  - 복제 서버가 여러 데이터센터 간 분산돼 있다면 사용자 디바이스의 요청을 동일 데이터센터로 라우팅해야 한다.

### 단조 읽기

- 비동기식 팔로워 환경에선 시간이 거꾸로 흐르는 현상을 볼 수도 있다.
  - 서로 다른 복제 서버에서 여러 읽기를 수행할 때 첫 번째 질의보다 두 번째 질의에서 더 과거의 데이터를 불러올 수도 있다.
- 단조 읽기 (monotonic read)
  - 시간이 거꾸로 흐르는 현상이 발생하지 않게 보장하는 방법
  - 강한 일관성보다는 덜하지만 최종적 일관성보다는 더 강한 보장이다.
  - 데이터를 읽을 때 이전 값을 볼 수도 있지만 여러 번 반복해 읽어도 시간이 되돌아가는 현상은 적어도 방지한다.
- 단조 읽기를 달성하는 한 방법은 읽기가 항상 동일한 복제 서버에서 수행되게끔 하는 것이다.

### 일관된 순서로 읽기

- 세 번째 복제 지연 이상 현상으로 ‘인과성 위반’이 있다.
  - ex) A와 B의 채팅 대화를 재 3자인 C가 관찰할 때 B가 질문하기도 전에 A의 대답이 먼저 채팅창에 보이는 현상이 발생할 수도 있다.
  - 파티셔닝(샤딩된) 데이터베이스에서 서로 다른 파티션은 독립적으로 동작하기 때문에 발생하는 문제로 쓰기의 전역 순서가 없다.
- 인과성 위반을 방지하려면 ‘일관된 순서로 읽기(Consistent Prefix Read)’가 필요하다.
  - 일련의 쓰기가 특정 순서로 발생한다면 모든 사용자는 같은 순서로 쓰여진 내용을 보게 됨을 보장
  - 한 가지 해결책으로는 인과성이 있는 데이터는 동일 파티션에 기록되게끔 하는 방법이 있지만 일부 애플리케이션에선 효율적이지 않다.

### 복제 지연을 위한 해결책

- 복제는 비동기식으로 동작하지만 사용자에겐 동기식으로 동작하는 척 하는 것이 문제 해결 방안이다.
- 트랜잭션은 애플리케이션이 더 단순해지기 위헤 데이터베이스가 제공하는 강력한 보장이다.
- 하지만 분산 환경에서 트랜잭션은 성능과 가용성 측면에서 너무 비싸고 확장성이 없다.
- 때문에 최종적 일관성을 사용해야 한다는 주장이 있고 일부 사실이지만 지나치게 단순화된 대답이다.
