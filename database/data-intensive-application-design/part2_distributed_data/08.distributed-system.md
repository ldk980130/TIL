# 08장 분산 시스템의 골칫거리
## 결함과 부분 장애

- 부분 장애(partial failure)
    - 분산 시스템에선 어떤 부분은 잘 동작하지만 다른 부분은 예측할 수 없이 고장날 수도 있다.
    - 부분 장애는 비결정적이다.
    - 네트워크와 관련되어 어떨 때는 동작하지만 어떨 때는 실패한다.

### 클라우드 컴퓨팅과 슈퍼컴퓨팅

- 대규모 컴퓨팅 시스템 구축 방법 종류
    - 고성능 컴퓨팅 분야 - 슈퍼컴퓨터 등으로 계산 비용이 매우 높은 과학 계산 작업에 사용된다.
    - 클라우드 컴퓨팅 - 데이터센터, IP 네트워크로 연결된 상용 컴퓨터 등과 관련돼 있다.
    - 고성능 컴퓨팅과 클라우드 컴퓨팅의 중간 지점인 전통적인 기업형 데이터 센터
- 이 책에선 인터넷 서비스를 구현하는 시스템을 집중적으로 다루며 다음과 같은 특징이 있다.
    - 언제라도 사용자에게 지연이 낮은 서비스를 제공해야 한다.
    - 부분 장애 가능성을 받아들이고 소프트웨어에 내결함성 메커니즘이 필요하다.
    - 지리적으로 분산된 배포를 하기에 통신 대부분이 인터넷을 거친다.
- 분산 시스템에선 의심, 비관주의, 편집증을 가지는 것이 좋다.
    - 발생 가능성이 낮은 결함이더라도 광범위하게 고려하고 테스트할 필요가 있다.

## 신뢰성 없는 네트워크

- 전통적 인터넷 서비스를 위한 분산 시스템은 비공유 시스템이다.
    - 즉 네트워크로 연결된 다수의 장비
    - 상대적으로 저렴하고 지리적으로 분산되어 높은 신뢰성 확보가 가능
- 인터넷과 데이터센터 내부 네트워크 대부분은 비동기 패킷 네트워크이기에 여러 가지가 잘못될 수 있다.
    - 요청이 손실 됐을 수도 있다.
    - 요청이 큐에서 대기하다 나중에 전송될 수 있다.
    - 원격 노드에 장애가 생겼을 수 있다.
    - 원격 노드가 일시적으로 응답하기를 멈췄지만 나중에 다시 응답할 수 있다.
    - 원격 노드가 요청을 처리했지만 응답이 네트워크에서 손실됐을 수 있다.
    - 원격 노드가 요청을 처리했지만 응답이 지연되다 나중에 전송될 수 있다.

### 현실의 네트워크 결함

- 100% 신뢰성 있는 네트워크를 만드는 방법은 아직 없는 듯 하다.
    - EC2 같은 공개 클라우드 서비스는 일시적 네트워크 결함이 자주 발생한다.
    - 비공개 데이터센터는 더 안정적일 순 있지만 네트워크 토폴로지 재구성을 유발하고 패킷이 1분 이상 지연될 수도 있다.
    - 상어가 해저 케이블을 물어뜯어 손상시키기도 한다.
- 네트워크 결함이 드물더라도 일어날 수 있기에 소프트웨어는 이를 처리할 수 있어야 한다.
    - 네트워크 결함을 견디도록 처리하기 보다 사용자에게 오류를 보여주는 것도 타당한 방법이다.
    - 소프트웨어가 네트워크 문제에 반응하여 복구될 수 있도록 보장하는 것이 중요하다.

### 결함 감지

- 많은 시스템은 결함 있는 노드를 자동으로 감지할 수 있어야 한다.
- 하지만 네트워크의 불확실성 때문에 노드가 동작 중인지 구별이 어렵다.

### 타임아웃과 기약 없는 지연

- 타임아웃은 결함을 감지하는 수단이지만 얼마나 기다려야 하는지 간단하지 않다.
  - 타임아웃이 길면 노드가 죽었다고 판단하기까지 대기 시간이 길어진다.
  - 타임아웃이 짧으면 노드가 일시적으로 느려졌을 뿐일 때도 죽었다고 선언할 위험이 높아진다.
- 시스템이 이미 높은 부하에 있다면 성급한 노드 결함 선언은 문제를 악화시킬 수 있다.
  - 연쇄적인 장애 유발

### 네트워크 혼잡과 큐 대기

- 컴퓨터 네트워크에서 패킷 지연의 변동성은 큐 대기 때문인 경우가 많다.
  - 여러 노드가 같은 목적지로 패킷을 보내려 하면 네트워크 스위치는 패킷을 큐에 넣고 한 번에 하나씩 목적지 네트워크 링크로 넘겨야 한다. (네트워크 혼잡)
  - 패킷이 목적지에 도착해도 모든 CPU 코어가 바쁜 상태라면 준비가 될 때까지 OS가 큐에 넣어 둔다.
  - TCP는 흐름 제어를 수행하면서 자신의 송신률을 제한하기에 데이터는 네트워크에 들어가기 전에도 부가적인 큐 대기를 할 수도 있다.
  - TCP는 타임아웃 안에 확인 응답을 받지 않으면 패킷 손실로 간주하고 손실 패킷을 자동으로 재전송하는데 이로 인한 지연도 존재한다.
- 큐 대기 지연은 시스템의 최대 용량까지 광범위하게 일어난다.
- 좋은 방법은 고정된 타임아웃을 설정하는 대신 지속적으로 응답 시간과 변동성을 측정해 타임아웃을 동적으로 조절하는 것이다.
  - 아카(Akka)와 카산드라 그리고 TCP 재전송 타임아웃도 비슷한 방법을 사용한다.

### 동기 네트워크 대 비동기 네트워크

- 동기식 네트워크
  - 요청과 응답이 직렬적으로 이루어져 한 작업이 완료될 때까지 다음 작업이 진행되지 않는다.
  - 데이터가 여러 라우터를 거치더라도 큐 대기 문제를 거치지 않는다.
  - 큐 대기가 없기에 네트워크 종단 지연의 최대치가 고정돼 있다.
  - ex) 전화 통화 - 전화 회선은 다른 누구도 사용할 수 없는 고정된 대역폭을 사용하며 초당 비트 개수가 상당히 고정돼 있다.
- 비동기 네트워크
  - 요청과 응답이 병렬적으로 이루어지며 요청을 보낸 후 응답을 기다리지 않고 다른 작업을 수행한다.
  - TCP 연결의 경우 네트워크 대역폭을 기회주의적으로 사용해 가변 크기의 데이터 블록을 짧은 시간 안에 전송하려 한다.
  - ex) 웹 페이지 요청, 이메일 전송 등 - 순간적으로 몰리는 트래픽에 최적화됨
- 회선(동기식 네트워크)을 통해 파일 등을 전송하는 작업은 대역폭 할당을 추정해야 하기에 어렵다.
  - 추정치가 너무 낮으면 네트워크 용량을 쓰지 않고 남겨 둔 상태로 전송이 불필요하게 느려진다.
  - 추정치가 너무 높으면 회선은 구성될 수 없다.
    - 회선 교환은 대역폭 할당을 보장할 수 없다면 회선 생성을 허용하지 않기 때문
  - 반대로 TCP는 네트워크 용량에 맞춰 데이터 전송률을 동적으로 조절한다.
- 이러한 이유로 현대 웹 서비스들은 비동기 네트워크를 사용할 수밖에 없고, 네트워크 변동성으로 인한 기약 없는 지연이 발생할 것이라고 가정해야 한다.

## 신뢰성 없는 시계

- 분산 시스템에서 시계와 시간은 중요하다.
  - 통신이 즉각적이지 않기 때문
  - 네트워크 상의 개별 장비는 자신의 시계를 갖고 있기에 오차가 발생

### 단조 시계 대 일 기준 시계

- 현대 컴퓨터는 최소 두 가지 종류의 시계를 갖고 있다.
- 일 기준 시계(time-of-day clock)
  - 직관적으로 시계에 기대하는 일을 하는 시계로 현재 날짜와 시간을 반환한다.
  - ex) 리눅스와 자바는 에포크(epoch) 이래로 흐른 초(또는 ms)를 반환한다.
  - 일 기준 시계는 보통 NTP로 동기화되는데 여러 장비 간 타임스탬프들은 이상적으로 동일한 의미를 지닌다는 뜻이다.
  - 일 기준 시계는 로컬 시계가 NTP 서버보다 너무 앞선다던지 문제가 존재한다.
- 단조 시계(monotonic clock)
  - 타임아웃이나 서비스 응답 지속 시간을 재는 데 적합한 시계
  - ex) 리눅스의 `clock_gettime`과 자바의 `System.nanoTime()`
  - 한 시점의서의 시계 값과 다른 시점에서의 값의 차이로 시간이 얼마나 흘렀는지 알 수 있다.
  - 하지만 두 대의 다른 장비에서 나온 단조 시계 값을 비교하는 것은 의미가 없는데 이는 동일한 것을 의미하지 않기 때문
    - 심지어 CPU마다 독립된 타이머가 있을 수도 있다.
  - 분산 시스템에서 시간 경과를 재는 데 단조 시계를 사용하는 것은 일반적으로 괜찮다. (측정이 다소 부정확해도 민감하지 않음)

### 시계 동기화와 정확도

- 단조 시계는 동기화 필요가 없지만 일 기준 시계는 NTP 서버 등에 맞춰 설정되어야 유용하다.
- GPS 수신기, 정밀 시간 포로토콜과 세심한 배포 및 모니터링을 통해 높은 정확도를 가지는 시계를 만들 수 있긴 하다.
- 하지만 상당한 노력과 전문 기술이 필요하고 동기화가 잘못되는 수많은 시나리오가 있다.
  - NTP 데몬 설정이 잘못되는 경우
  - 방화벽이 NTP 트래픽을 차단하는 경우

### 동기화된 시계에 의존하기

- 시계는 사용하기 쉬워 보이지만 많은 함정이 존재하기에 견고한 소프트웨어는 잘못된 시계에 대비할 필요가 있다.
  - 동기화된 시계를 사용한다면 모든 장비의 시계 차이를 모니터링해야 한다.
- 이벤트 순서화용 타임스탬프
  - 분산 시스템에서 발생하는 이벤트들에는 이벤트 발행 시간인 타임스탬프를 기록한다.
  - 같은 값에 접근하는 이벤트들에 대해 최종 쓰기 승리(last write wins)를 적용하려 해도 어떤 쓰기가 가장 “최근” 값인지는 로컬 일 기준 시계에 의존하게 된다.
    - 정확한 NTP 동기화를 필요로 하는데 어려운 일이다.
  - 논리적 시계(logical clock)는 증가하는 카운터를 기반으로 하며 이벤트 순서화의 안전한 대안으로 사용된다.
    - 일 기준 시간이나 경과 초 수를 측정하지 않고 이벤트의 상대적인 순서만 측정
- 시계 읽기의 신뢰 구간
  - NPT 서버와의 동기화에 오차가 있기 때문에 장비의 일 기준 시계가 마이크로초/나노초 해상도로 시간을 읽을 수 있어도 실제로 정확한 것은 아니다.
  - ex) 어떤 장비의 현재 시간이 10.3초와 10.5초 사이일 확률이 95%임을 알아도 그보다 더 정확히는 알 수 없다.
  - 대부분의 시스템은 이러한 불확실성을 노출하지 않는다.
  - 예외적으로 스패너(Spanner)의 구글 트루타임(TrueTime) API는 로컬 시계의 신뢰 구간을 명시적으로 보고한다.
    - 현재 시간을 요청사면 가능한 타임스탬프 범위인 신뢰구간[earliest, latest]을 받는다.
- 전역 스냅숏용 동기화된 시계
  - 데이터베이스의 스냅숏 격리에선 트랜잭션은 단조 증가하는 트랜잭션 ID가 필요하다.
  - 하지만 분산 환경에선 트랜잭션 ID에 대한 코디네이션이 필요하고 각 노드에서 발생한 트랜잭션들 중 뭐가 더 높은 ID를 가지는지 판단할 수 있어야 한다.
  - 동기화된 일 기준 시계의 타임스탬프를 트랜잭션 ID로 쓰기에는 앞서 설명한 불확실성이 걸린다.
  - 스패너의 트루타임을 통해 트랜잭션 ID를 부여할 수 있는데 두 신뢰 구간이 겹치지 않는다면 선후관계를 파악할 수 있고 겹친다면 순서를 확신할 수 없다.
    - 트랜잭션 타임스탬프가 인과성을 보장하기 위해 스패너는 읽기 쓰기 트랜잭션을 커밋하기 전 의도적으로 신뢰 구간 길이만큼 기다린다.
