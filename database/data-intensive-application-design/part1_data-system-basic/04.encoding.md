# 04장 부호화의 발전
- 대부분의 경우 애플리케이션 기능을 변경하려면 데이터도 함께 변경해야 한다.
- 관계형 데이터베이스는 모든 데이터가 하나의 스키마를 따른다.
    - ALTER 구문으로 변경될 순 있지만 특정 시점엔 정확히 하나의 스키마가 적용
- NoSQL 등에선 스키마를 강요하지 않아 여러 데이터 타입이 섞여 표현될 수 있다.
- 스키마가 변경될 때 애플리케이션 코드도 변경되는데 시스템이 원활히 실행되려면 양방향으로 호환성을 유지해야 한다.
    - 하위 호완성 - 새로운 코드는 예전 코드가 기록한 데이터를 읽을 수 있어야 한다.
    - 상위 호환성 - 예전 코드는 새로운 코드가 기록한 데이터를 읽을 수 있어야 한다.

## 데이터 부호화 형식

- 프로그램은 보통 두 가지 형태로 표현된 데이터로 동작된다.
    - object, struct, list, array, hash table, tree 등은 메모리상에서 다루어진다.
    - 보통 CPU에서 효율적으로 다루기 위해 포인터를 이용해 최적화된다.
- 데이터를 파일에 쓰려면 일련의 바이트열 형태로 부호화해야 한다.
    - 이 바이트열은 보통 메모리에서 사용하는 데이터 구조와 상당히 다르다.
- 부호화
    - 직렬화나 마샬링이라고도 함
    - 인메모리 표현에서 바이트열로의 전환
- 복호화
    - 파싱, 역직렬화, 언마샬링이라고도 함
    - 바이트열에서 인메모리 표현으로의 전환

### 언어별 형식

- 많은 프로그래밍 언어는 객체를 바이트열로 부호화하는 기능을 내장한다.
    - ex) 자바의 - `java.io.Serializable`
- 하지만 일시적인 목적 외에 언어에 내장된 부호화 방식은 일반적으로 좋지 않다.
    - 해당 프로그래밍 언어와 묶여 있어 다른 언어에서 데이터를 읽기 매우 어려움
    - 동일 객체 유형 데이터를 복원하려면 복호화 과정이 임의 클래스를 인스턴스화할 수 있어야 하는데 이는 종종 보안의 원인이 된다.
    - 데이터 버전 관리는 보통 부호화 라이브러리에선 나중에 생각하게 된다.
    - 효율성도 종종 나중에 생각하게 된다.
        - ex) 자바의 내장 직렬화는 성능이 좋지 않고 비대해지는 부호화로 유명

### JSON과 XML, 이진 변형

- 표준화된 부호화로서 JSON과 XML이 있고 강력하진 않지만 CSV도 나름 인기 있다.
- 위 세 부호화는 일부 미묘한 문제가 존지한다.
    - 수(number)의 부호화에 많은 애매함이 존재
        - XML과 CSV에는 수와 숫자로 구성된 문자열을 구분할 수 없다.
        - JSON은 구분하지만 정밀도를 지정하지 못한다.
    - 수에 대한 애매함은 큰 수를 다룰 때 문제가 된다.
    - JSON과 XML은 유니코드 문자열은 잘 지원하지만 이진 문자열을 지원하지 않는다.
    - JSON, XML은 모두 스키마를 지원하지만 익히고 구현하기가 난해하다.
        - 스키마 사용을 강제하지 않기에 데이터를 부호화/복호화할 때 하드코딩이 필요할 수도 있다.
    - CSV는 스키마가 없기에 애플리케이션 로직이 매우 번거로워진다.
- 이러한 결점에도 JSON, XML, CSV는 데이터 교환 형식으로 사용하기 매우 좋다.
    - ex) 한 조직에서 다른 조직으로 데이터를 전송
- JSON, XML과 같은 형식은 이진 형식보다 훨씬 많은 공간을 사용한다.
    - 때문에 JSON, XML 용으로 사용 가능한 다양한 이진 부호화의 개발로 이어졌다.

### 스리프트와 프로토콜 버퍼

- 아파치 스리프트(Apache Thrift)와 프로토콜 버퍼(Protocol Buffers, protobuf)는 같은 원리를 기반으로 한 이진 부호화 라이브러리이다.
- 두 라이브러리 모두 부호화할 데이터를 위한 스키마가 필요하다.

```
// 스리프트 스키마의 예
struct Person {
	1: required string username,
	2: optional i64 favoriteNumber,
	3: optional list<string> interests
}
```

- JSON 부호화와의 큰 차이점으로는 필드 태그를 사용한다는 것이다.
    - 부호화된 데이터에 필드 이름 대신 필드 태그(1, 2, 3)를 포함한다.
    - 필드 이름 철자 없이도 어떤 필드를 다루는지 알려주는 간단한 빙법
    - 필드 타입과 태그 숫자로 단일 바이트로 표현
- 또 하나의 차이점은 required나 optional 표시로 필수 여부를 표현한다.
- 아파치 스리프트는 필드 태그를 통해 뛰어난 호환성을 자랑한다.
    - 각 필드를 이름이 아닌 태그 숫자로만 구분하기에 스키마의 필드 이름을 변경하기 쉽다.
    - 새로운 태그 번호를 부여하며 새로운 필드를 추가할 수 있는데 예전 코드에서 해당 스키마를 읽을 때 인식할 수 없는 태그 번호는 간단히 무시가 가능하다. (상위 호환성)
    - 한 태그 번호는 남아 있는 한 계속 같은 의미를 가지기에 새로운 코드가 예전 데이터를 항상 읽을 수 있다. (하위 호환성)
