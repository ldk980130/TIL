# 03장 저장소와 검색

- 기본적으로 데이터베이스는 두 가지 작업을 수행한다.
    - 데이터를 저장
    - 후에 그 데이터를 요청 시 데이터 제공
- 데이터베이스의 저장과 검색 내부 메커니즘을 개발자가 주의해야 하는 이유
    - 여러 저장소 엔진 중 애플리케이션에 적합한 엔진을 선택해야 하기 때문
    - 특정 작업부하 유형에서 좋은 성능을 내게끔 엔진을 조정해야 하는 경우가 있음

## 데이터베이스를 강력하게 만드는 데이터 구조

- 가장 간단한 데이터베이스를 생각해보면 다음 두 가지 기능을 제공할 것이다.
    - `db_set` : 데이터 저장
    - `db_get` : 데이터 조회
- key-value 저장소라고 한다면 db_set 함수는 좋은 성능을 보여준다.
    - 실제로 많은 데이터베이스는 내부적으로 append-only 데이터 파일인 로그(log)를 사용하는데 매우 유용하다.
    - 데이터베이스에서 ‘로그’는 일반적인 의미로 연속된 추가 전용 레코드로서의 의미를 갖는다.
- 반면 db_get 함수는 데이터베이스에 많은 레코드가 있다면 성능이 좋지 않다.
    - 풀 스캔을 해야하기 때문에 검색 비용이 O(n)이다.
- 색인 : 데이터베이스에서 특정 키를 효율적으로 찾기 위해 사용하는 데이터 구조
    - 색인의 일반적인 개념은 어떤 부가적인 메타데이터를 유지하는 것
    - 색인을 잘 선택했다면 읽기 속도가 향상된다.
    - 하지만 모든 색인은 쓰기 속도를 떨어뜨린다.
- 개발자나 DBA는 애플리케이션의 패턴을 잘 이해하고 수동으로 색인을 선택해야 한다.
    - 애플리케이션에 가장 큰 이득을 주는 색인을 선택해 오버헤드를 최소화해야 함

### 해시 색인

- 인메모리 해시맵 색인
    - 키-값 데이터 구조를 가장 간단하게 색인하는 방법
    - 키를 데이터 파일의 바이트 오프셋에 매핑해 인메모리 해시 맵을 유지하는 전략
    - 값을 조회하려면 해시 맵을 사용해 데이터 파일에서 오프셋을 찾아 값을 읽는다.
- 해시 맵을 모두 메모리에 유지한다면 고성능 읽기, 쓰기를 보장할 수 있다.
    - 단 모든 키가 메모리에 저장된다는 전제가 필요하다.
    - 값은 한 번의 디스크 탐색으로 디스크에 적재할 수 있기에 메모리보다 더 많은 공간을 사용할 수 있다.
    - 각 키 값이 자주 갱신되면서 고유 키가 많지 않은 경우에 유용
- 파일에 데이터가 추가되며 디스크 공간이 부족해지면 세그먼트로 로그를 나누는 방식으로 해결한다.
    - 특정 크기에 도달하면 세그먼트 파일을 닫고 새로운 세그먼트 파일에 쓰기를 계속 수행
    - 세그먼트 파일들에 대해 컴팩션을 수행 가능 (컴팩션은 로그에서 중복된 키를 버리고 각 키의 최신 갱신 값만 유지하는 것을 의미)
        - 세그먼트는 쓰여진 후 변경할 수 없기에 병합할 세그먼트는 새 파일로 만든다.
- 각 세그먼트는 키를 파일 오프셋에 매핑한 자체 인메모리 해시 테이블을 갖는다.
    - 키의 값을 찾으려면 최신 세그먼트를 먼저 확인 후 차례로 세그먼트들을 확인해간다.
    - 병합 과정을 통해 세그먼트 수를 적게 유지하기에 많은 해시 맵을 확인하지 않아도 된다.
- 위 사항을 실제 구현하려면 많은 세부 사항을 고려해야 한다.
    - 파일 형식 - 바이너리 형식을 사용하는 편이 더 빠르고 간단 (CSV 보다는)
    - 레코드 삭제 - 삭제 시 데이터 파일에 특수한 삭제 레코드를 추가하고 세그먼트 병합 시 삭제된 키의 이전 값을 무시하게 한다.
    - 고장 복구
        - 인메모리 해시맵 복구를 위해 세그먼트 전체를 읽는 것은 오버헤드가 크다.
        - 비트캐스크는 각 세그먼트 해시맵의 스냅숏을 디스크에 저장해 복구 속도를 높인다.
    - 부분적 레코드 쓰기
        - 데이터베이스는 로그에 레코드를 추가하는 도중에 죽을 수 있기에 체크섬으로 로그의 손상된 부분을 탐지해 무시한다.
    - 동시성 제어 - 데이터 파일 세그먼트는 추가 전용이거나 불변이므로 다중 스레드로 동시 읽기를 할 수 있다.
- 추가 전용(append only) 설계는 여러 측면에서 좋은 설계다.
    - 추가와 세그먼트 병합은 순차 쓰기 작업이기에 무작위 쓰기보다 훨씬 빠르다.
    - 동시성과 고장 복구가 훨씬 간단하다.
    - 오래된 세그먼트 병합은 시간이 지남에 따라 조각화되는 데이터 파일 문제를 피할 수 있다.
- 해시 테이블 색인의 제약 사항
    - 해시 테이블이 메모리에 저장되므로 키가 너무 많으면 문제가 된다.
    - 범위 질의에 효율적이지 않다.
