# 03장 저장소와 검색

- 기본적으로 데이터베이스는 두 가지 작업을 수행한다.
    - 데이터를 저장
    - 후에 그 데이터를 요청 시 데이터 제공
- 데이터베이스의 저장과 검색 내부 메커니즘을 개발자가 주의해야 하는 이유
    - 여러 저장소 엔진 중 애플리케이션에 적합한 엔진을 선택해야 하기 때문
    - 특정 작업부하 유형에서 좋은 성능을 내게끔 엔진을 조정해야 하는 경우가 있음

## 데이터베이스를 강력하게 만드는 데이터 구조

- 가장 간단한 데이터베이스를 생각해보면 다음 두 가지 기능을 제공할 것이다.
    - `db_set` : 데이터 저장
    - `db_get` : 데이터 조회
- key-value 저장소라고 한다면 db_set 함수는 좋은 성능을 보여준다.
    - 실제로 많은 데이터베이스는 내부적으로 append-only 데이터 파일인 로그(log)를 사용하는데 매우 유용하다.
    - 데이터베이스에서 ‘로그’는 일반적인 의미로 연속된 추가 전용 레코드로서의 의미를 갖는다.
- 반면 db_get 함수는 데이터베이스에 많은 레코드가 있다면 성능이 좋지 않다.
    - 풀 스캔을 해야하기 때문에 검색 비용이 O(n)이다.
- 색인 : 데이터베이스에서 특정 키를 효율적으로 찾기 위해 사용하는 데이터 구조
    - 색인의 일반적인 개념은 어떤 부가적인 메타데이터를 유지하는 것
    - 색인을 잘 선택했다면 읽기 속도가 향상된다.
    - 하지만 모든 색인은 쓰기 속도를 떨어뜨린다.
- 개발자나 DBA는 애플리케이션의 패턴을 잘 이해하고 수동으로 색인을 선택해야 한다.
    - 애플리케이션에 가장 큰 이득을 주는 색인을 선택해 오버헤드를 최소화해야 함

### 해시 색인

- 인메모리 해시맵 색인
    - 키-값 데이터 구조를 가장 간단하게 색인하는 방법
    - 키를 데이터 파일의 바이트 오프셋에 매핑해 인메모리 해시 맵을 유지하는 전략
    - 값을 조회하려면 해시 맵을 사용해 데이터 파일에서 오프셋을 찾아 값을 읽는다.
- 해시 맵을 모두 메모리에 유지한다면 고성능 읽기, 쓰기를 보장할 수 있다.
    - 단 모든 키가 메모리에 저장된다는 전제가 필요하다.
    - 값은 한 번의 디스크 탐색으로 디스크에 적재할 수 있기에 메모리보다 더 많은 공간을 사용할 수 있다.
    - 각 키 값이 자주 갱신되면서 고유 키가 많지 않은 경우에 유용
- 파일에 데이터가 추가되며 디스크 공간이 부족해지면 세그먼트로 로그를 나누는 방식으로 해결한다.
    - 특정 크기에 도달하면 세그먼트 파일을 닫고 새로운 세그먼트 파일에 쓰기를 계속 수행
    - 세그먼트 파일들에 대해 컴팩션을 수행 가능 (컴팩션은 로그에서 중복된 키를 버리고 각 키의 최신 갱신 값만 유지하는 것을 의미)
        - 세그먼트는 쓰여진 후 변경할 수 없기에 병합할 세그먼트는 새 파일로 만든다.
- 각 세그먼트는 키를 파일 오프셋에 매핑한 자체 인메모리 해시 테이블을 갖는다.
    - 키의 값을 찾으려면 최신 세그먼트를 먼저 확인 후 차례로 세그먼트들을 확인해간다.
    - 병합 과정을 통해 세그먼트 수를 적게 유지하기에 많은 해시 맵을 확인하지 않아도 된다.
- 위 사항을 실제 구현하려면 많은 세부 사항을 고려해야 한다.
    - 파일 형식 - 바이너리 형식을 사용하는 편이 더 빠르고 간단 (CSV 보다는)
    - 레코드 삭제 - 삭제 시 데이터 파일에 특수한 삭제 레코드를 추가하고 세그먼트 병합 시 삭제된 키의 이전 값을 무시하게 한다.
    - 고장 복구
        - 인메모리 해시맵 복구를 위해 세그먼트 전체를 읽는 것은 오버헤드가 크다.
        - 비트캐스크는 각 세그먼트 해시맵의 스냅숏을 디스크에 저장해 복구 속도를 높인다.
    - 부분적 레코드 쓰기
        - 데이터베이스는 로그에 레코드를 추가하는 도중에 죽을 수 있기에 체크섬으로 로그의 손상된 부분을 탐지해 무시한다.
    - 동시성 제어 - 데이터 파일 세그먼트는 추가 전용이거나 불변이므로 다중 스레드로 동시 읽기를 할 수 있다.
- 추가 전용(append only) 설계는 여러 측면에서 좋은 설계다.
    - 추가와 세그먼트 병합은 순차 쓰기 작업이기에 무작위 쓰기보다 훨씬 빠르다.
    - 동시성과 고장 복구가 훨씬 간단하다.
    - 오래된 세그먼트 병합은 시간이 지남에 따라 조각화되는 데이터 파일 문제를 피할 수 있다.
- 해시 테이블 색인의 제약 사항
    - 해시 테이블이 메모리에 저장되므로 키가 너무 많으면 문제가 된다.
    - 범위 질의에 효율적이지 않다.

### SS테이블

- 기존 해시 색인은 다음 특징이 있었다.
  - 로그 구조화 저장소인 세그먼트에 키-값 쌍 연속이 쓰여진 순서대로 존재
  - 같은 키를 갖는 값 중 나중 값이 이전 값보다 우선
- SS 테이블 : 정렬된 문자열 테이블 (Sorted String Table)
  - 일련의 키-값 쌍을 키로 정렬
  - 각 키는 세그먼트 파일 내 한 번만 나타나야 하고 이는 컴팩션 과정에서 보장한다.
- 기존 해시 색인과 다른 SS 테이블의 장점
  - 세그먼트 병합은 파일이 사용 가능한 메모리보다 크더라도 간단하고 효율적이다. (병합정렬 알고리즘과 유사)
  - 특정 키를 파일에서 찾기 위해 메모리에 모든 키 색인을 유지할 필요가 없다.
    - 키가 정렬되어 있기에 메모리에 있는 키를 보고 어떤 오프셋 범위에 있는지 찾을 수가 있다.
    - 수 킬로바이트 정도의 스캔은 매우 빠르기에 메모리 내 색인은 수 킬로바이트당 하나로 충분하게 되는 것
  - 디스크 공간이 절약되고 I/O 대역폭 사용을 줄일 수 있다.
    - 읽기 요청 시 인메모리 색인을 보고 요청 범위를 특정 가능하기에 해당 범위 레코드들을 블록으로 그룹화하고 디스크에 쓰기 전 압축한다.
    - 인메모리 색인의 각 항목은 압축된 블록의 시작을 가리키게 된다.

### SS 테이블 생성과 유지

- 쓰기 요청이 들어오면 멤테이블(memtable) 데이터 구조에 추가한다.
  - 멤테이블: 인메모리에 유지되는 레드 블랙 트리 같은 균형 트리 (blanced tree)
- 멤테이블이 임계값보다 커지면 SS테이블 파일로 디스크에 기록 (가장 최신 세그먼트가 된다.)
- 읽기 요청이 발생하면 먼저 멤테이블에서 찾고 그 다음엔 최신 세그먼트에서부터 찾기 시작한다.
- 가끔 세그먼트 컴펙션 과정을 백그라운드에서 수행한다.
- 장애 시 멤테이블의 가장 최신 쓰기가 손실될 수 있기에 복구할 때 사용할 분리된 로그를 디스크 상에 유지해야 한다.

### SS 테이블에서 LSM 트리 만들기

- LSM (Log-Structured Merge-Tree) 저장소 엔진
  - 정렬된 파일 병합과 컴팩션 원리를 기반으로 하는 저장소 엔진
  - 즉 SS테이블을 기반으로 하는 저장소 엔진이라 볼 수 있다.
- LSM이 사용되는 라이브러리 또는 DB
  - 레벨 DB와 록스 DB 또는 내장 키-값 저장소 엔진 라이브러리에서 사용
  - 카산드라와 HBase에서도 유사한 저장소 엔진을 사용
  - 엘라스틱서치나 솔라에서 사용하는 전문 검색 색인 엔진인 루씬(Lucene)에서도 용어 사전(term dictionary)를 저장할 때 유사한 방법을 사용

### 성능 최적화

- 블룸 필터 (Bloom filter)
  - LSM 트리 알고리즘은 존재하지 않는 키 검색은 멤테이블 → 전체 세그먼트를 탐색하기에 느리다.
  - 없는 키에 접근하는 경우를 최적화하기 위해 키가 없음을 알려주는 블룸 필터를 사용한다.
- SS 테이블을 압축하고 병합하는 순서와 시기를 결정하는 다양한 전략이 존재
  - 크기 계층(size-tiered) 컴팩션 : 상대적으로 더 작은 SS테이블을 더 큰 SS테이블에 연이어 병합
  - 레벨 컴팩션 (leveled compaction) : 키 범위를 더 작은 SS 테이블로 나누고 오래된 데이터는 개별 “레벨”로 이동시켜 컴팩션을 점진적으로 진행해 디스크 공간을 덜 사용한다.
- LSM 트리의 기본 개념은 백그라운드에서 연쇄적으로 SS테이블을 지속적으로 병합하는 것
  - 데이터셋이 가능한 메모리보다 훨씬 크더라도 효과적인 방법
  - 데이터가 정렬되어 있어 질의를 효율적으로 실행 가능
  - 디스크 쓰기가 순차적이기에 높은 쓰기 처리량 보장 가능
