# 02장 데이터 모델과 질의 언어
- 데이터 모델은 소프트웨어 개발에서 제일 중요한 부분이다.
    - 문제를 어떻게 생각해야 하는지 지대한 영향을 미침
- 대부분의 애플리케이션은 하나의 데이터 모델을 다른 데이터 모델 위에 계층을 둬서 만든다.
    - 개발자는 현실을 보고 객체나 데이터 구조, API를 모델링한다.
    - 데이터 구조 저장 시에는 JSON이나 XML 문서, 관계형 DB 테이블이나 그래프 모델 같은 범용 모델로 표현한다.
    - DB 소프트웨어를 개발하는 엔지니어는 JSON/XML/관계형/그래프 데이터를 메모리나 디스크 또는 네트워크 바이트 단위로 표현하는 방법을 결정한다.
    - 더 낮은 수준에서 하드웨어 엔지니어는 전류, 빛의 파동, 자기장 등 관점에서 바이트를 표현한다.
- 각 계층은 명확한 데이터 모델을 제공해 하위 계층의 복잡성을 숨긴다.
- 하나의 데이터 모델을 완전히 익히는 데도 많은 노력이 필요하다.
    - 애플리케이션에 적합한 데이터 모델을 선택하는 작업은 상당히 중요하다.

## 관계형 모델과 문서 모델

- 오늘날 가장 잘 알려진 데이터 모델은 관계형 모델 기반의 SQL이다.
    - 데이터는 테이블이라 불리는 관계(Relation)로 구성된다.
    - 각 관계는 순서 없는 튜플(tuple) 모음이다.
- 관계형 데이터베이스의 근원은 비즈니스 데이터 처리에 있다.
    - 트랜잭션 처리, 일괄 처리 등
- 오늘날의 대부분의 서비스는 여전히 관계형 데이터베이스를 통해 제공된다.

### NoSQL의 탄생

- NoSQL은 관계형 모델의 우위를 뒤집으려는 가장 최신 시도다.
- NoSQL DB를 채택하는 데 다음과 같은 원동력이 있다.
    - 높은 쓰기 처리량 달성을 관계형 DB보다 쉽게 할 수 있는 뛰어난 확장성 필요
    - 무료 오픈소스 소프트웨어에 대한 선호도 확산
    - 관계형 모델에서 지원하지 않는 특수 질의 동작
    - 관계형 스키마의 제한에 대한 불만과 더욱 동적이고 표현력이 풍부한 데이터 모델에 대한 바람

### 객체 관계형 불일치

- 임피던스 불일치
    - 객체지향 프로그래밍 언어로 개발한 코드와 데이터베이스 모델 사이의 분리
    - 보통 두 모델 사이에 전환계층이 필요해진다.
- 하이버네이트 같은 ORM을 사용해 두 모델 간 차이를 개선할 순 있지만 완벽히 숨길 수는 없다.
    - 관계형 스키마에서 ‘이력서’ 같은 데이터를 표현하기 쉽지 않다.
    - ‘이력서’ 같은 데이터 구조는 모든 내용을 갖추고 있는 문서라 JSON 표현에 매우 적합하다.

### 다대일과 다대다 관계

- 중복된 데이터를 정규화하려면 다대일 관계가 필요하다.
    - 어떤 값을 평문으로 저장하는 것이 아닌 외부 테이블로 두고 ID를 참조
    - 관계형 모델에선 조인이 쉬워 다른 테이블을 참조하는 것이 일반적
    - 문서 모델에는 적합하지 않은 관계
- 데이터베이스 자체가 조인을 지원하지 않으면 애플리케이션 코드에서 조인을 흉내내야 한다.
    - 문서 데이터베이스는 일대다 트리 구조를 위해 조인이 필요하지 않아 조인에 대한 지원이 보통 약하다.
### 관계형 데이터베이스와 오늘날의 문서 데이터베이스

- 문서 데이터 모델을 선호하는 주된 이유는 다음과 같다.
  - 스키마 유연성
  - 지역성에 기인한 더 나은 성능
  - 일부 애플리케이션의 경우 사용하는 데이터 구조와 더 가깝기 때문
- 어떤 데이터 모델이 애플리케이션 코드를 더 간단하게 할까?
  - 애플리케이션에서 다루는 데이터가 문서와 비슷하다면 문서 모델을 이용하는 것이 좋다.
  - 문서 구조를 여러 테이블로 찢는 관계형 기법은 복잡한 코드를 발생시킨다.
  - 다대다 관계를 사용해야한다면 문서 모델의 매력은 떨어진다.
    - 조인이 필요하면 애플리케이션 코드가 많이 복잡해진다.
  - 데이터 항목 간 관계 유형에 따라 어떤 모델이 코드를 간결하게 하는지 상이해진다.
- 문서 모델에서의 스키마 유연성
  - JSON은 문서의 데이터에 어떤 스키마를 강요하지 않는다.
  - 문서 데이터베이스는 스키마리스(schemaless)로 불리지만 어느정도 유형을 가정하긴 한다.
    - ‘쓰기 스키마’와 반대되는 ‘읽기 스키마’를 가진다.
    - ‘읽기 스키마’는 동적 타입 확인하 유사하고 ‘쓰기 스키마’는 정적 타입 확인과 유사하다.
  - 스키마 변경이 필요할 때 관계형 DB에선 마이그레이션이 필요하다.
    - 때론 매우 오랜 중단 시간을 야기할 수도 있다.
- 질의를 위한 데이터 지역성
  - 문서는 보통 JSON, XML로 부호화된 단일 연속 문자열이나 이진 변형으로 저장된다.
  - 자주 전체 문서에 접근해야 한다면 저장소 지역성을 활용하면 성능 이점이 있다.
    - ex) 웹 페이지 상에 문서를 보여줄 때
    - 지역성의 이점은 한 번에 문서의 많은 부분이 필요할 때만 적용된다.
    - 일반적으로 문서를 아주 작게 유지하면서 문서의 크기가 증가하는 쓰기를 피하라고 권장
- 문서 데이터베이스와 관계형 데이터베이스의 통합
  - 대부분의 관계형 데이터베이스 시스템은 2000대 중반 이후로 XML을 지원한다.
  - PostgreSQL과 MySQL은 JSON 문서에 대해 비슷한 수준의 지원을 제공한다.
  - 관계형과 문서 데이터베이스는 시간이 지나면서 점점 비슷해지고 있다.
  - 관계형과 문서의 혼합은 미래 데이터베이스들이 가야 할 올바른 길이다.

## 데이터를 위한 질의 언어

- SQL은 선언형 질의 언어이고 IMS나 코다실은 명령형 코드로 데이터베이스에 질의한다.
  - 프로그래밍 언어는 명령형 언어다.
- 명령형 언어
  - 특정 순서로 특정 연산을 수행하게끔 지시
  - 연산이 어떻게 수행될지를 세세히 제어한다.
- 선언형 언어
  - 선언형 질의는 목표 달성을 위한 방법이 아닌 알고자 하는 데이터가 어떻게 반환될지만 지정하면 된다.
    - 어떤 색인을 사용할지, 어떤 순서로 실행할지는 DB 시스템이 해야할 일
  - 선언형 언어는 명령형 API보다 더 간결히 작업할 수 있다.
  - 중요한 점은 상세 구현이 숨겨져 있어 질의를 변경하지 않고 성능을 향상시킬 수 있다는 점이다.
  - 선언형 언어는 세부적인 알고리즘을 지정하는 것이 아닌 결과의 패턴만 지정하기에 병렬 실행으로 더 빨라질 가능성이 크다.
    - 명령형 언어의 경우 명령어를 특정 순서로 수행하게끔 지정하기에 병렬 처리가 어렵다.

### 웹에서의 선언형 질의

- 선언형 질의 언어의 장점은 DB에만 국한되지 않는다.
- 웹 브라우저에서 선언형 CSS 스타일을 사용하는 편이 명령형 자바스크립트로 스타일을 다루기보다 훨씬 낫다.

### 맵리듀스 질의

- 맵리듀스(MapReduce)는 많은 컴퓨터에서 대량의 데이터를 처리하기 위한 프로그래밍 모델이다.
  - 일부 NoSQL 데이터 저장소는 제한된 형태의 맵리듀스를 지원한다.
  - 많은 문서를 대상으로 읽기 전용 질의 수행 시 사용한다.
- 맵리듀스는 선언형 질의 언어도 완전한 명령형 질의도 아닌 그 중간 정도다.
  - 여러 함수형 프로그래밍 언어에 존재하는 `map`과 `reduce` 함수를 기반으로 한다.
- 예를 들어 아래 예제는 PostgreSQL의 질의와 몽고 DB의 맵리듀스 기능을 비교한 코드다.
  - 한 달에 얼마나 자주 상어를 발견하는지 알아보기 위해

```sql
SELECT date_trunc('month', observation_timestamp) AS observation_month, 
	sum(num_animals) AS total_animals
FROM observations
WHERE faily = 'Sharks' 
GROUP BY obervation_month;
```

```jsx
db.observations.mapReduce(
	function map() { // 2
		var year = this.observationTimestamp.getFullYear();
		var month = this.observationTimestamp.getMonth() + 1;
		emit(year + "-" month, this.numAnimals); // 3
	},
	function reduce(key, values) { // 4
		return Array.sum(values); // 5
	},
	{
		query: { family: "Sharks" }, // 1
		out: "monthlySharkReport"
	}
)
```

1. 상어 종만 거르기 위한 필터를 선언적으로 지정
2. `map`은 자바스크립트 함수다.
   - 질의와 일치하는 모든 문서에 대해 한 번씩 호출
   - `this`는 문서 객체로 설정
3. `map` 함수는 키(년 - 월)와 값(관측치에 있는 동물 수)을 방출한다.
4. `map`이 방출한 키-값 쌍은 키로 그룹화된다.
   - 같은 키를 갖는 모든 키-값 쌍은 `reduce` 함수를 한 번씩 호출한다.
5. `reduce` 함수는 특정 월의 모든 동물 수를 합친다.
6. 최종 출력은 `monthlySharkReport` 컬렉션에 기록한다.

- 몽고 DB의 `map`과 `reduce`는 순수 함수여야 한다.
  - 입력으로 전달된 데이터만 사용
  - 추가적인 데이터베이스 질의 불가
  - 부수 효과가 없어야 함
  - 때문에 데이터베이스가 임의 순서로 어디서나 함수를 실행 가능하고 장애가 발생해도 함수를 재실행할 수 있다.
- 일부 SQL 데이터베이스도 자바스크립트 함수로 확장될 수 있다.
- 맵리듀스의 사용성 문제
  - 연계된 자바스크립트 함수 두 개를 신중하게 작성해야 한다. (종종 매우 어렵다.)
