# 4장 레디스 자료 구조 활용 사례
## sorted set을 이용한 실시간 리더보드

- 리더보드란 경쟁자들의 순위와 현재 점수를 보여주는 순위표다.
- 리더보드는 사용자 증가에 따라 가공할 데이터가 몇 배로 증가한다.
    - 스코어 기반으로 데이터를 정렬하기 때문
- 또한 실시간으로 반영되어야 하기에 여러 수학적 계산이 빠르게 수행되어야 한다.
- 레디스의 `sorted set`을 사용하면 데이터는 정렬돼 들어간다.

```bash
> ZADD daily-score:220817 28 player:286
(integer) 1

> ZADD daily-score:220817 400 player:234
(integer) 1
```

- `ZRANGE` 커맨드로 스코어가 낮은 순서부터 출력 가능하고 `ZREVRANGE` 커맨드로 잘라서 조회할 수 있다.
    - `ZREVRANGE`은 내림차순

```bash
> ZREVRANGE daily-score:220817 0 2 withscores
1) "player:234"
2) "400"
3) "player:24"
4) "357"
5) ...
```

### 데이터 업데이트

- 데이터를 업데이트 해야 한다면 다음 커맨드로 쉽게 가능하다.
    - 중복으로 저장되지 않기에 스코어만 다르면 신규 입력으로 업데이트 된다.
    - 그에 맞춰 데이터 순서도 다시 정렬된다.

```bash
ZADD daily-score:220817 200 player:286
```

- `ZINCRBY` 커맨드로 입력값만큼 증가시킬 수도 있다.

```bash
# 원래 245였다면 345로 업데이트
ZINCRBY daily-score:220817 100 player:24
```

### 랭킹 합산

- 주간 누적 랭킹은 레디스의 `ZUNIONSTORE` 커맨드로 쉽게 구현할 수 있다.
  - `ZUNIONSTORE` - 지정한 키에 연결된 각 아이템의 스코어를 합산하는 커맨드
- `ZUNIONSTORE`는 `<생성할 키 이름><합산할 키 개수><합산할 키>…`와 같이 사용할 수 있다.
- 아래 예제는 22년 8월 15일부터 17일까지 데이터를 합산한다.

```bash
> ZUNIONSTORE weekly-score:2208-3 3 daily-score:220815 daily-score:220816 daily-score:220817
(integer) 4

# 합산된 데이터 순으로 정렬
> ZREVRANGE weekly-score:2208-3 0 -1 withscores
1) "player:24"
2) "650"
3) ...
```

- `ZUNIONSTORE`로 데이터를 합칠 때 가중치를 줄 수도 있다.
  - 만약 16일에 스코어 2배 이벤트가 있었다면?

```bash
> ZUNIONSTORE weekly-score:2208-3 3 daily-score:220815 
daily-score:220816 daily-score:220817 weights 1 2 1
(integer) 4
```

### sorted set을 이용한 최근 검색 기록

- 최근 검색 기록 요구 사항은 다음과 같이 정리할 수 있다.
  - 유저별로 다른 키워드 노출
  - 검색 내역 중복 제거
  - 가장 최근 검색한 5개 키워드만 노출
- RDB였다면 아래 쿼리가 필요할 것이다.
  - `SELECT * FROM keyword WEHRE user_id = 123 ORDER BY req_date DESC LIMIT 5`
  - `keyword` 테이블을 관리하려면 중복 제거, 주기적으로 오래된 기록 삭제 작업 등이 필요하다.
  - 검색 기록이 늘어날 수록 데이터 관리가 어려워진다.
- `sorted set`을 사용하면 관리 포인트가 크게 줄어든다.
  - 기본이 중복을 허용하지 않음
  - 기본이 정렬해서 관리
  - 음수 인덱스를 사용해 몇 개 이상이 저장되지 않도록 강제할 수 있다.

```bash
# 데이터 저장 (검식 일시를 스코어로 사용)
> ZADD search-keyword:123 20221106143501 코듀로이
(integer) 1

# 데이터 조회 (최근 5개 조회)
> ZREVRANGE search-keyword:123 0 4 withscores

# 음수 인덱스로 6번째로 오래된 기록 삭제
# 데이터가 6개가 됐을 때 가장 오래전 저장된 데이터는 인덱스 0, 음수로 하면 -6이다.
> ZREMRANGEBYRANK search-keyword -6 -6
```

### set을 이용한 태그 기능

- 블로그 게시글에서 태그 기능을 사용하려면 RDB에선 적어도 2개 테이블이 필요하다.
  - `tag`, `post_tag`
- 레디스 `set`을 사용하면 간단하게 태그 기능을 구현할 수 있다.
  - 아래 코드처럼 게시글-태그, 태그-게시글 양방향으로 데이터를 저장
  - 이렇게 하면 게시글의 태그 조회, 태그 별 게시글 조회를 쉽게 할 수 있다.

```bash
> SADD post:47:tags REDIS DataStore IT
(integer) 3

> SADD tag:REDIS:posts 47
1

> SADD tag:DataStore:posts 47
1

> SADD tag:IT:posts 47
1

> SMEMBERS tag:IT:posts
1) "22"
2) "47"
3) "53"
```

- `SINTER` 커맨드로 2개 이상의 태그에 속하는 게시글을 조회할 수 있다.
  - 교집합을 찾는 커맨드

```bash
> SINTER tag:IT:posts tag:DataStore:posts
1) "47"
```

### 랜덤 데이터 추출

- 랜덤 데이터 추출은 보통 게임에서 가챠 등에서 많이 활용된다.
- RDB에서 랜덤 데이터 추출은 `ORDER BY RAND()` 함수를 많이 사용한다.
  - 쿼리 결과값을 랜덤하게 정렬
  - 조건 절에 맞는 모든 행을 읽고 임시 테이블에 정렬, 그리고 limit에 해당할 때까지 데이터를 추출
  - 데이터가 1만 건 이상이라면 부하가 많이 가는 방법
- 레디스를 사용하면 O(1)의 시간 복잡도를 이용해 랜덤 데이터를 추출할 수 있다.
- `RANDOMKEY` 커맨드는 레디스의 전체 키 중 하나를 무작위로 반환한다.
  - 하지만 보통 레디스의 키가 한 종류의 데이터만 저장하지 않는다.
    - `hash`, `set`, `sorted set` 등은 여러 데이터를 한 키에 저장
- `HRANDFIELD`, `SRANDMEMBER`, `ZRANDMEMBER`는 각각 `hash`, `set`, `sorted set`에 저장된 아이템 중 랜덤한 값을 추출한다.

```bash
> HRANDFILED user:hash
"Id:4615"

# COUNT 옵션으로 원하는 개수만큼 랜덤 아이템을 반환할 수 있다.
# COUNT 옵션을 양수로 설정하면 중복 없는 랜덤, 음수는 중복 있는 랜덤이 반환
> HRANDFILED user:hash 2
1) "Id:4615"
2) "Id:134"
```

## 레디스에서의 다양한 카운팅 방법

- 데이터 개수를 세는 작업은 자주 발생한다.
  - 단순 개수 파악
  - 약간의 오차를 허용하면서 매우 큰 데이터셋을 처리할 때

### 좋아요 처리하기

- 실시간 트래픽이 많다면 좋아요는 1초에 몇만개 이상 발생할 수도 있고 이를 RDB에서 처리하면 성능에 악영향을 끼칠 수 있다.
  - 좋아요 개수 증가가 필요
  - 하나의 유저는 한 번만 좋아요를 누를 수 있음
  - 어떤 유저가 좋아요를 눌렀는지 파악할 수 있어야 함
- 레디스 `set`으로 좋아요 로직을 간단히 구현할 수 있다.
  - 댓글 id 기준으로 `set`을 생성
  - 좋아요 한 유저의 id를 `set`에 저장

```bash
# 12554 댓글에 유저:967이 좋아요를 누름
> SADD comment-like:12554 967

# 댓글별 좋아요 누른 수
> SCARD comment-like:12554
(integer) 3
```

### 읽지 않은 메시지 수 카운팅

- 채팅 애플리케이션에서 사용자가 속한 채널별로 읽지 않은 메시지를 카운팅, 관리하려 한다.
  - 메시지가 도착할 때마다 RDB를 업데이트 하는 대신 레디스에 임시로 저장한 후 필요할 때 한 번에 업데이트할 수 있다.
  - RDB 부하를 최소화, 성능 향상 목적
  - 사용자 ID를 키, 채널의 ID를 아이템 키로 활용해 숫자 형태 메시지 카운트를 관리하면 된다.

```bash
# user:234가 4234 채널에 새로운 메시지 수신
> HINCRBY user:234 channel:4234 1
(integer) 1

# 누군가 메시지를 삭제했다면
> HINCRBY user:234 channel:4234 -1
(integer) 26
```

- `hash` 구조는 객체 구조에서 카운트를 효과적으로 관리할 수 있는 방법이다.

### DAU 구하기

- DAU란 하루 동안 서비스에 방문한 사용자 수를 의미한다.
  - 실제 서비스를 사용한 유니크 수를 파악할 수 있는 지표
- 사용자 접근 로그 같은 접속 로그와 배치 처리로 계산할 수 있지만 실시간 데이터는 확인할 수 없다.
- 하루 방문 유저 ID를 레디스 `set`에 저장할 수도 있다.
  - 하지만 하루 1000만 명 이상 유저가 방문한다면 성능 저하로 이어진다.
  - 보통 키 하나당 저장하는 아이템은 최대 2, 300만 개까지로 권장
  - 메모리 부하도 엄청날 것이다.
- 레디스 비트맵을 이용하면 메모리 효율적으로 실시간 서비스의 DAU를 확인할 수 있다.
  - 비트맵 - `string` 자료 구조에 bit 연산이 가능하도록 구현됨
  - 1천만 사용자는 1천만 개 비트로 나타낼 수 있으며 이는 약 1.2MB
  - `string` 최대 길이는 512MB이기에 하나의 키로 천만 사용자는 문제 없다.

```bash
# 2022-11-06에 유저 id=14를 방문 처리
> SETBIT uv:20221106 14 1
(integer) 0

# 해당 일자 접근 유저 수 확인
>BITCOUNT uv:20221106
(integer) 3
```

- `BITOP` 커맨드로 AND, OR, XOR, NOT 연산을 할 수 있다.

```bash
# 특정 기간 동안 매일 방문한 사용자 구하기
# 연속 출석 유저 정보를 새로운 비트맵인 event:202211에 저장
> BITOP AND event:202211 uv:20221101 uv:20221102 uv:20221103
(integer) 2
```

### hyperloglog 이용한 애플리케이션 미터링

- 사용자가 서비스를 얼마나 사용했는지 측정하는 ‘미터링’이 필요할 때가 있다.
  - 미터링 솔루션은 사용 내역을 이용하기 때문에 대용량 데이터를 처리할 수 있어야 한다.
  - 규모에 따라 초당 수천 건 이상 작업이 발생할 수 있다.
- 다음 조건을 만족한다면 `hyperloglog` 사용을 고려할 수 있다.
  - 집합 내 유일한 데이터 개수를 카운팅 해야 한다.
  - 1% 미만 오차는 허용 가능하다.
  - 카운팅할 때 사용한 정확한 데이터를 다시 확인하지 않아도 된다.
- 아래는 `hyperloglog`를 이용해 유저의 월별 api 호출 횟수를 계산하는 방법이다.
  - 유저 ID를 키로, api 호출 시 저장되는 로그 식별자를 `hyperloglog`에 저장할 수 있다.

```bash
# 2022-11에 userID=245인 유저의 호출 횟수 계산
> PFADD 202211:user:245 49483
(integer) 1

> PFADD 202211:user:245 32714
(integer) 1

> PFADD 202211:user:245 49483
(integer) 1

# 중복되지 않은 데이터 개수 확인
> PFCOUNT 202211:user:245
(integer) 2
```

- `hyperloglog`는 `set`과 비슷하지만 용량은 12KB로 고정된다.
- `PFMERGE` 커맨드로 여러 `hyperloglog`를 합칠 수 있어 합산 데이터를 간단히 계산할 수 있다.

## Geospatial Index를 이용한 위치 기반 애플리케이션 개발

### 위치 데이터란

- 위치 데이터는 주로 경도와 위도(x, y) 좌표 쌍으로 표현된다.
- 이러한 공간 데이터 처리는 쉽지 않다.
- 사용자의 위치가 실시간으로 변할 때 이 데이터를 저장, 처리할 수 있는 신속한 데이터 저장소가 필요하다.
  - 모든 사용자의 정보를 1초마다 업데이트한다면?

### 레디스에서의 위치 데이터

- 레디스는 `geo` 자료 구조로 공간 정보 데이터를 처리할 수 있다.
  - 다른 데이터와 마찬가지로 데이터는 메모리에서 관리되기에 빠르다.
  - `geo set`과 pub/sub을 함께 사용한다면 특정 이벤트를 해당 지역 근처 사용자에게 실시간 알림을 보낼 수도 있다.
- `geo set`은 공간 관리에 특화된 데이터로 내부적으로 `sorted set`으로 저장된다.

```bash
# 142 유저의 현재 위치를 저장
> GEOADD user 50.2342452353 14.4235423546t 142
```

- 이 외에도 여러 커맨드를 사용해 위치 기반 기능을 제공한다.
  - `GEOPOS` - 저장된 데이터의 경도, 위도를 조회
  - `GEOSEARCH` - 일정 공간 범위 내 키값을 조회 (ex. 주변 맛집 검색)
