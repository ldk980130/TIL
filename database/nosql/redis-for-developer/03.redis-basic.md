# 3장 레디스 기본 개념

## 레디스의 자료 구조

### string

- `string`에는 최대 512MB의 문자열을 저장할 수 있다.
- 모든 종류의 문자열을 binary-safe하게 처리할 수 있다.
    - 이미지 같은 바이트 값, HTTP 응답 등 다양한 데이터를 저장 가능
- `string`은 키와 값이 일대일로 연결되는 유일한 자료 구조
- `SET` 커맨드로 `string` 데이터를 저장하고 `GET`으로 조회한다.

```bash
> SET hello world
ok

> GET hello
"world"
```

- 기존에 값이 있었다면 기존 값은 새 값으로 대체된다.
- `NX` 옵션을 통해 키가 없을 때만 새 키를 저장하도록 할 수 있다.
- 반대로 `XX` 옵션으로 키가 있을 때만 덮어 쓰기를 하고 새로운 키는 생성하지 않도록 할 수 있다.

```bash
> SET hello newal NX
(nil)

> SET hello newal XX
ok

> GET hello
"newal"
```

- `string` 자료구조는 숫자 형태 데이터도 저장할 수 있다.
- `INCR`, `INCRBY` 키워드로 숫자를 원자적으로 조작할 수 있다.
    - 원자적이라는 것은 여러 클라이언트가 경쟁 상태를 발생시킬 일이 없음을 의미

```bash
> SET counter 100
ok

> INCR counter
(integer) 101

> INCRBY counter 50
(integer) 151
```

- `MSET`, `MGET` 커맨드로 여러 키를 한 번에 조작 가능하다.
    - 성능이 중요한 대규모 시스템에서 적절히 사용한다면 네트워크 통신을 줄여 서비스 응답 속도를 전반적으로 올릴 수 있다.

```bash
> MSET a 10 b 20 c 30
ok

> MGET a b c
1) "10"
2) "20"
3) "30"
```

### list

- `list`는 순서를 가지는 문자열의 목록이다
  - 인덱스를 이용해 접근 가능
  - 일반적으로 스택과 큐로 사용됨
- 하나의 `list`에는 최대 42억여 개의 아이템을 저장할 수 있다.
- 기본적인 커맨드
  - `LPUSH` - 왼쪽에 데이터를 추가
  - `RPUSH` - 오른쪽에 데이터 추가
  - `LRANGE` - list의 데이터를 조회
  - `LPOP` - 첫 번째 아이템을 삭제하며 반환한다.
  - `LTRIM` - 시작과 끝 아이템 인덱스를 인자로 전달 받아 범위에 속하지 않은 아이템은 모두 삭제
    - `LPUSH`와 함께 적절히 사용하면 고정된 길이의 큐를 쉽게 유지할 수 있다.
      - `LPUSH` 후 `LTRIM`
    - 데이터를 일단 쌓고 주기적인 배치 처리로 삭제하는 것 보다 이러한 방식이 훨씬 효율적이다.
      - 매번 큐의 마지막만 삭제하므로 O(1)
  - `LINSERT` - 원하는 데이터 앞이나 뒤에 데이터를 추가
    - `BEFORE`, `AFTER` 옵션을 통해 앞, 뒤 중 선택할 수 있다.
  - `LSET` - 저장한 인덱스 데이터를 신규 값으로 덮어쓸 수 있다.
  - `LINDEX` - 원하는 인덱스의 데이터를 확인 가능
