# 5장 레디스를 캐시로 사용하기
## 레디스와 캐시

### 캐시란?

- 캐시란 데이터 원본보다 빠르고 효율적으로 엑세스할 수 있는 임시 데이터 저장소를 의미
- 애플리케이션이 다음 조건을 만족한다면 캐시 도입 후 성능을 효과적으로 개선할 수 있다.
    - 원본 저장소에서 데이터를 검색, 계산하는 시간이 오래 걸림
    - 캐시에서 데이터를 가져오는 것이 원본에서 가져오는 것보다 빨라야 한다.
    - 캐싱된 데이터는 잘 변하지 않는 데이터
    - 캐싱된 데이터는 자주 검색되는 데이터
- 캐시의 장점
    - 애플리케이션 응답 속도 단축
    - 원본 데이터 저장소 커넥션을 줄일 수 있다.
    - 캐시를 적절히 배치하여 애플리케이션 확장 또한 가능하다.
    - 애플리케이션 리소스를 줄일 수 있다.
    - 서비스 구성에 따라 원본 데이터 저장소에 장애가 발생해도 캐시를 이용할 수 있다.

### 캐시로서의 레디스

- 레디스는 사용이 간단
    - 키-값 형태
    - 다양한 자료 구조 제공
- 레디스는 데이터 검색, 반환이 상당히 빠르다.
    - 모든 데이터를 메모리에 저장 (인메모리 데이터 저장소)
    - 평균 읽기 및 쓰기 작업 속도가 1ms 미만
    - 초당 수백만 건 작업이 가능
- 레디스는 자체적으로 고가용성 솔루션
    - 레디스의 센티널 또는 클러스터 기능을 사용 가능
    - 마스터 노드 장애를 자동으로 감지해 페일오버를 발생시킴
    - 레디스 클러스터를 텅해 스케일 아웃 또한 쉽게 처리 가능
### 캐싱 전략 - look aside

- 데이터를 읽을 때 주로 사용하는 일반적인 배치 방법
- 읽고자 하는 데이터를 캐시에서 먼저 찾고 캐시에 데이터가 있으면 바로 반환하는데 이를 ‘캐시 히트’라고 한다.
- 캐시에 데이터가 없으면 원본에서 찾고 이를 캐시에 저장한다.
  - lazy loading
- 장점은 레디스에 문제가 생기더라도 원본 저장소를 계속 이용하면서 서비스 장애로 이어지지 않는다는 점이다.
  - 원본 DB에 트래픽이 몰려 부하가 발생하고 성능이 느려질 수는 있어도 말이다.
- 캐시를 사용하고 있지 않다가 캐시를 배치하게 되면 초반에 대규모 캐시 미스가 일어나 (원본 조회 + 캐시 저장) 성능이 느려지게 된다.
  - 이럴 때 DB에서 캐시로 데이터를 미리 밀어넣는 ‘캐시 워밍’을 할 수도 있다.

### 캐싱 전략 - 쓰기 전략과 캐시의 일관성

- 캐시는 원본의 복사이기 때문에 캐시 불일치가 일어날 수 있다.
  - 원본과 캐시의 데이터가 불일치
  - ex) 원본 DB에 반영된 값을 캐시에도 반영하기 전에 캐시에서 이전 값을 읽어 버리는 경우
- write through
  - DB를 업데이트할 때마다 매번 캐시도 함께 업데이트 하는 방식
  - 캐시는 항상 최신 데이터를 가질 수 있지만 쓰기 시간이 많이 소요된다.
  - 이 방식을 사용한다면 데이터 저장 만료 시간을 사용할 것을 권장한다.
    - 다시 사용되지 않을 데이터도 무조건 캐시에 저장되기 때문
    - 캐시는 재사용될 만한 데이터에 적용하는 것이 좋다.
- cache invalidation
  - DB에 값을 업데이트할 때마다 캐시 데이터는 삭제하는 방식
- write behind (write back)
  - 쓰기가 빈번한 서비스에 고려할 수 있는 방식
  - 대량의 쓰기 작업 시 많은 디스크 I/O를 피하기 위해 캐시에 값을 먼저 업데이트
  - 이후 특정 시간 간격 등에 따라 비동기적으로 DB에 업데이트
  - 저장되는 데이터가 실시간으로 정확하지 않아도 되는 경우 유용하다.
    - ex) 유튜브 동영상 좋아요 수
  - 물론 캐시에 문제가 생기는 경우 그 동안의 데이터가 날아갈 수도 있는 위험성이 존재한다.
