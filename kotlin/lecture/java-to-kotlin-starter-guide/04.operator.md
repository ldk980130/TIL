# Lec 04. 코틀린에서 연산자를 다루는 방법
## 1. 단항 연산자 / 산술 여산자

- 단항 연산자
    - `++`, `--`
- 산술 연산자
    - `+`, `-`, `*`, `/`, `%`
- 산술 대입 연산자
    - `+=`, `-=`, `*=`, `/=`, `%=`

## 2. 비교 연산자와 동등성, 동일성

### 비교 연산자

- 비교 연산자
    - `<`, `>`, `>=`, `<=`
- 자바와 동일하지만 객체를 비교할 때 비교 연산자를 사용하면 자동으로 `compareTo`를 호출해준다.
    - `person1` < `person2`

### 동등성과 동일성

- 동일성(Identity): 완전히 동일한 객체인가? 즉 주소가 같은가?
- 동등성(Equality): 두 객체의 값이 같은가?
- 자바에서는 동일성에 `==`, 동등성에 `equals`를 사용했다.
- 코틀린에서는 동일성에 `===`, 동등성에 `==`를 사용한다.
    - `==` 사용 시 간접적으로 `equals`를 호출

## 3. 논리 연산자 / 코틀린에 있는 특이한 연산자

### 논리 연산자

- `&&`, `||`, `!`
- 자바와 완전 동일하다.
- 자바처럼 Lazy 연산을 수행
    - Lazy 연산 - 논리 연산자 조합, 순서에 따라 뒤의 연산을 하지 않고 메서드를 실행하는 것

### 코틀린의 특이한 연산자

- `in` / `!in`
    - 컬렉션이나 범위에 포함되어 있다, 포함되어 있지 않다
    - `println(1 in numbers)`
- `a..b`
    - `a` 부터 `b`까지의 범위 객체를 생성
- `a[i]`
    - `a`에서 Index로 값을 가져온다.
- `a[i] = b`
    - `a`의 특정 Index에 `b`를 넣는다.

## 4. 연산자 오버로딩

- 코틀린에서는 객체마다 연산자를 직접 정의할 수 있다.
- 연산자 오버로딩을 하기 이해선 `operator` 키워드를 사용한다.

```kotlin
data class Money(
  val amount: Long
) {
  operator fun plus(other: Money): Money {
    return Money(this.amount + other.amount)
  }
}
```

```kotlin
val money1 = Money(1_000L)
val money2 = Money(2_000L)
println(money1 + money2) // Money(amount=3_000)
```

- `+`는 `plus`, `-`는 `minus`를 사용하는 식으로 각 연산자에 대응하는 메서드를 `operator`와 함께 정의하여 오버로딩하면 된다.
