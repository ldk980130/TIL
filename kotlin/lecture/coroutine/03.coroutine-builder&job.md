# 3강 코루틴 빌더와 Job
## [1] runBlocking

- `runBlocking`은 새로운 코루틴을 만든다.
- 이렇게 코루틴을 만드는 함수를 코루틴 빌더라고 한다.

```kotlin
fun main(): Unit = runBlocking {

}
```

- 이름에 blocking이 들어가 있다.
    - 만들어진 코루틴과 그 안의 코루틴이 모두 완료될 때까지 스레드를 블락 시킨다.
    - 스레드가 블락되면 해제될 때까지 다른 코드를 실행할 수 없다.

```kotlin
fun main() {
  runBlocking {
    printWithThread("START")
    launch {
      delay(2_000L) // 코루틴을 지정 시간 동안 지연시킴
      printWithThread("LAUNCH END")
    }
}
  printWithThread("END")
}
```

```kotlin
[main] START
[main] LAUNCH END
[main] END
```

- 위 코드에서 END는 `runBlocking` 코루틴이 모두 실행될 때까지는 출력될 수 없다.
- `runBlocking`은 이처럼 스레드를 블락시키기에 프로그램에 진입하는 최초 진입 함수나 테스트 코드를 시작할 때만 쓰는 것이 좋다.

## [2] launch

- 반환 값이 없는 코루틴을 만든다.
- `runBlocking`과 다르게 코루틴을 제어할 수 있는 객체 `Job`을 반환 받는다.
    - 제어할 수 있다는 건 시작, 취소, 종료를 제어할 수 있다는 것이다.

- `CoroutineStart.LAZY` 옵션을 주면 `job.start()`를 호출할 때까지 실행되지 않는다.
    - 아래 코드에선 1초 기다리고 실행된다.

```kotlin
fun main(): Unit = runBlocking {
  val job = launch(start = CoroutineStart.LAZY) {
    printWithThread("Hello launch")
  }
  delay(1_000L)
  job.start()
}
```

- `cancel()` 함수로 코루틴을 취소시킬 수도 있다.
    - 아래 코드에선 원래 5까지 출력해야 하지만 2까지만 출력하게 된다.

```kotlin
fun main(): Unit = runBlocking {
  val job = launch {
    (1..5).forEach {
      printWithThread(it)
      delay(500) // 1초에 2까지 출력
    } 
  }
  delay(1_000L) // 1초 기다리고
  job.cancel() // cancel 호출
}
```

- `join()`으로 코루틴이 끝날 때까지 대기할 수도 있다.
- 아래 코드는 실행 되는데 1초 조금 넘게 걸린다.
    1. `job1`이 실행되고 `delay` 시작
    2. `job1`이 대기하는 순간 `job2`가 시작
    3. `job1`과 `job2`가 함께 대기
    4. `job1`의 대기가 먼저 끝나고 “Job1” 출력
    5. `job2`의 대기가 끝나거 “Job 2” 출력

```kotlin
fun main(): Unit = runBlocking {
  val job1 = launch {
    delay(1_000)
    printWithThread("Job 1")
}
  val job2 = launch {
    delay(1_000)
    printWithThread("Job 2")
} }
```

- 하지만 `join`을 쓰면 `job1`이 끝날 때까지 `job2`를 기다리게 할 수 있다.

```kotlin
fun main(): Unit = runBlocking {
  val job1 = launch {
    delay(1_000)
    printWithThread("Job 1")
  }
  job1.join()
  val job2 = launch {
    delay(1_000)
    printWithThread("Job 2")
} }
```
