# 아이템 45 불필요한 객체 생성을 피하라
- 객체 생성은 언제나 비용이 들고, 상황에 따라선 굉장히 큰 비융이 들어갈 수도 있다.

## 객체 생성 비용은 항상 클까?

- 어떤 객체를 랩(wrap)하면 크게 세 가지 비용이 발생한다.
    - 객체는 더 많은 용량을 차지한다.
    - 요소가 캡슐화되어 있다면 접근에 추가적인 함수 호출이 필요하다.
        - 함수 호출에 대해선 큰 비용이 발생하지 않지만 수많은 객체를 처리한다면 비용이 커진다.
    - 객체는 생성되고, 메모리에 할당되고 이에 대한 레퍼런스를 만드는 등 작업이 필요하다.
        - 적은 비용이지만 모이면 큰 비용이 된다.
- 객체를 제거함으로써 위 세 가지 비용을 모두 피할 수 있다.

## 객체 선언

- 객체 선언을 사용하면 객체를 매번 생성하지 않고 재사용할 수 있다. (싱글톤)
    - 인스턴스는 하나만 만들고 다른 곳에서 활용하는 방식
- immutable 객체를 정의할 때 매우 유용하다.
- 다만 mutable 객체에 사용하면 공유 상태 관리와 관련된 버그를 검출하기 어렵다.
    - mutable 객체는 캐시하지 않는다는 규칙을 지키는 편이 좋다.

```kotlin
sealed class LinkedList<out T>

class Node<out T>(
	val head: T,
	val tail: LinkedList<T>,
): LinkedList<T>()

// 링크드리스트에서 Empty 노드를 싱글톤으로 사용
class Empty<T>: LinkedList<T>()

// 사용
val list: LinkedList<Int> = Node(1, Node(2, Node(3, Empty())))
```

## 캐시를 활용하는 팩토리 함수

- 팩토리 함수로 객체를 만드는 경우 캐시를 반환할 수 있다.
    - ex) stdlib의 `emptyList`는 이를 활용해서 구현되어 있다.

```kotlin
fun <T> emptyList(): List<T> {
	return EMPTY_LIST
}
```

- 아래는 재귀를 활용한 피보나치 함수가 캐시를 활용하는 예제 코드다.
    - 캐시가 존재하면 추가적인 계산 없이 결과를 도출할 수 있다.

```kotlin
private val FIB_CACHE = mutableMapOf<Int, BigInteger>()

fun fib(n: Int): BigInteger = FIB_CACHE.getOrPut(n) {
	if (n <= 1) BigInteger.ONE else fib(n - 1) + fib(n - 2)
}
```

- 다만 캐시를 위한 더 많은 메모리가 필요하게 된다.
- 메모리가 필요할 때 GC가 자동으로 메모리를 해제해 주는 SoftReference를 사용하면 더 좋다.
    - SoftReference - GC가 값을 정리할 수도, 정리하지 않을 수도 있다. 일반적인 JVM의 경우 메모리가 부족한 경우에만 정리한다.
    - WeakReference - GC가 값을 정리하는 것을 막지 않기에 다른 레퍼런스가 이를 사용하지 않으면 곧바로 제거된다.
- 캐시는 메모리와 성능의 트레이드 오프가 발생하므로 잘 설계하기 쉽지 않다.

## 무거운 객체를 외부 스코프로 보내기

- 무거운 객체를 외부 스코프로 보내는 방식은 성능을 위한 유용한 트릭이다.
  - ex) 컬렉션 처리에서 이루어지는 무거운 연산은 외부로 빼는 것이 좋다.

```kotlin
// 컬렉션 내부의 최댓값 수를 세는 확장 함수
fun <T: Comparable<T>> Iterable<T>.countMax(): Int {
	val max = this.max() // max 값을 찾아 두고 이를 활용해서 수를 세기에 가독성과 성능이 좋아진다.
	return count { it == max }
}
```

- 어떻게 보면 연산을 외부로 추출한다는 게 당연할 수도 있지만 많이 실수하는 부분이다.
- 또 하나의 예로 문자열 정규식 패턴은 꽤 복잡한 연산이라 호출할 때마다 만들면 비용이기에 아래처럼 외부 스코프로 추출하면 좋다.
- 또한 불필요한 생성을 막기 위해 지연 초기화를 활용할 수도 있다.

```kotlin
private val IS_VALID_EMAIL_REGEX by lazy {
	"/*...*/".toRegex()
}
```

## 지연 초기화

- 무거운 클래스는 지연되게 만드는 것이 좋을 때가 있다.

```kotlin
class A {
	val b by lazy { B() }
	
	// ...
}
```

- 지연 초기화엔 단점도 존재하는데 메서드 호출이 빨라야 하는 경우를 고려해야 한다.
  - 백엔드 API 컨트롤러의 경우 지연되게 만들었다면 첫 호출 때 초기화가 이루어지며 많이 느려질 것이다.
  - 또한 백엔드 애플리케이션에선 지연되게 만들면 성능 테스트가 복잡해진다.

## 기본 자료형 사용하기

- 기본 자료형이란 숫자와 문자 등 내장 자료형을 뜻한다.
  - 코틀린/JVM 컴파일러는 내부적으로 최대한 기본 자료형을 사용한다.
- 다만 아래 두 상황에서 기본 자료형을 랩(wrap)한 자료형이 사용된다.
  - nullable 타입 연산 (기본 자료형은 `null`일 수 없다)
  - 타입을 제네릭으로 사용할 때
- 즉 기본 자료형을 사용할 수 있을 때 최대한 사용하면 코드를 최적화할 수 있다.
  - 다만 코틀린/JVM과 일부 코틀린/Native 버전에만 의미가 있다. (코틀린/JS에선 의미 X)
  - 또한 숫자에 대한 작업이 여러 번 반복될 때만 의미가 있다.
- 기본 자료형에 의한 최적화는 사실 그렇게까지 중요하지 않을 수 있지만 라이브러리를 구현한다면 성능이 중요한 경우가 있기에 활용하면 좋다.
