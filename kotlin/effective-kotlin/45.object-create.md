# 아이템 45 불필요한 객체 생성을 피하라
- 객체 생성은 언제나 비용이 들고, 상황에 따라선 굉장히 큰 비융이 들어갈 수도 있다.

## 객체 생성 비용은 항상 클까?

- 어떤 객체를 랩(wrap)하면 크게 세 가지 비용이 발생한다.
    - 객체는 더 많은 용량을 차지한다.
    - 요소가 캡슐화되어 있다면 접근에 추가적인 함수 호출이 필요하다.
        - 함수 호출에 대해선 큰 비용이 발생하지 않지만 수많은 객체를 처리한다면 비용이 커진다.
    - 객체는 생성되고, 메모리에 할당되고 이에 대한 레퍼런스를 만드는 등 작업이 필요하다.
        - 적은 비용이지만 모이면 큰 비용이 된다.
- 객체를 제거함으로써 위 세 가지 비용을 모두 피할 수 있다.

## 객체 선언

- 객체 선언을 사용하면 객체를 매번 생성하지 않고 재사용할 수 있다. (싱글톤)
    - 인스턴스는 하나만 만들고 다른 곳에서 활용하는 방식
- immutable 객체를 정의할 때 매우 유용하다.
- 다만 mutable 객체에 사용하면 공유 상태 관리와 관련된 버그를 검출하기 어렵다.
    - mutable 객체는 캐시하지 않는다는 규칙을 지키는 편이 좋다.

```kotlin
sealed class LinkedList<out T>

class Node<out T>(
	val head: T,
	val tail: LinkedList<T>,
): LinkedList<T>()

// 링크드리스트에서 Empty 노드를 싱글톤으로 사용
class Empty<T>: LinkedList<T>()

// 사용
val list: LinkedList<Int> = Node(1, Node(2, Node(3, Empty())))
```

## 캐시를 활용하는 팩토리 함수

- 팩토리 함수로 객체를 만드는 경우 캐시를 반환할 수 있다.
    - ex) stdlib의 `emptyList`는 이를 활용해서 구현되어 있다.

```kotlin
fun <T> emptyList(): List<T> {
	return EMPTY_LIST
}
```

- 아래는 재귀를 활용한 피보나치 함수가 캐시를 활용하는 예제 코드다.
    - 캐시가 존재하면 추가적인 계산 없이 결과를 도출할 수 있다.

```kotlin
private val FIB_CACHE = mutableMapOf<Int, BigInteger>()

fun fib(n: Int): BigInteger = FIB_CACHE.getOrPut(n) {
	if (n <= 1) BigInteger.ONE else fib(n - 1) + fib(n - 2)
}
```

- 다만 캐시를 위한 더 많은 메모리가 필요하게 된다.
- 메모리가 필요할 때 GC가 자동으로 메모리를 해제해 주는 SoftReference를 사용하면 더 좋다.
    - SoftReference - GC가 값을 정리할 수도, 정리하지 않을 수도 있다. 일반적인 JVM의 경우 메모리가 부족한 경우에만 정리한다.
    - WeakReference - GC가 값을 정리하는 것을 막지 않기에 다른 레퍼런스가 이를 사용하지 않으면 곧바로 제거된다.
- 캐시는 메모리와 성능의 트레이드 오프가 발생하므로 잘 설계하기 쉽지 않다.
