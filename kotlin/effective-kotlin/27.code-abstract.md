# 아이템 27 변화로부터 코드를 보호하려면 추상화를 사용하라
- 추상화를 통해 사용자가 세부 사항을 알지 못해도 괜찮다는 장점이 있다.
- 추상화를 통해 변화로부터 코드를 보호하는 행위가 어떤 자유를 가져오는지 세 가지 사례를 통해 살펴보자.

## 상수

- 리터럴은 아무것도 설명하지 않기에 코드에 반복적으로 등장할 때마다 문제가 된다.

```kotlin
fun isPasswordValid(text: String): Boolean {
	if (text.length < 7) return false
	// ...
}
```

- 이를 상수로 추출한다면 쉽게 이해할 수 있고 변경하기도 쉽다.

```kotlin
const val MIN_PASSWORD_LENGTH = 7

fun isPasswordValid(text: String): Boolean {
	if (text.length < MIN_PASSWORD_LENGTH) return false
	// ...
}
```

## 함수

- 자주 사용하는 기능은 보통 함수로 만든다.

```kotlin
// 화면에 토스트 메시지를 출력하는 확장 함수
fun Context.toast(message: String, duration: Int = Toast.LENGTH_LONG) {
	Toast.makeText(this, message, duration).show()
}
```

- 만약 토스트가 아니라 스낵바라는 형태로 출력해야 한다고 요구사항이 변경되면 어떻게 변경할까?
- 함수 이름을 변경하고 내부 구현을 변경할 순 있지만 이는 추천하지 않는다.
    - 함수 이름을 직접 바꾸는 것은 위험할 수 있다.
    - 다른 모듈이 이 함수에 의존하고 있다면 큰 문제가 발생할 수 있다.
    - 함수 이름을 한 번에 바꾸는 건 쉽지만 파라미터는 한 번에 바꾸기 쉽지 않다.
- 메시지 출력 방식이 바뀐다면 중요한 것은 출력 방법이 아니라 메시지를 출력하고 싶다는 의도이다.

```kotlin
fun Context.showMessage( // 메시지를 출력한다는 추상적인 이름
	message: String, 
	duration: MessageLength = MessageLength.LONG),
) {
	// ...
}
```

- 함수는 추상화를 표현하는 수단이며 어떤 추상화를 표현하는지 시그니처가 알려주기에 의미 있는 이름은 굉장히 중요하다.
- 함수는 매우 단순한 추상화지만 제한이 많다.
    - 함수는 상태를 유지하지 않는다.
    - 함수 시그니처의 변경은 프로그램 전체에 큰 영향을 줄 수도 있다.
