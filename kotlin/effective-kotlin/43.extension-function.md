# 아이템 43 API의 필수적이지 않는 부분을 확장 함수로 추출하라
- 클래스 메서드를 정의할 때 멤버로 정의할지, 확장 함수로 정의할지 결정해야 한다.
    - 두 방식은 거의 비슷하다. (호출 방식 등)
- 멤버와 확장의 가장 큰 차이점은 확장은 따로 가져와서 사용해야 한다는 점이다.
    - 확장은 일반적으로 다른 패키지에 위치한다.
    - 직접 멤버를 추가할 수 없는 경우 확장을 사용한다.
    - 데이터와 행위를 분리하도록 설계된 프로젝트에서도 사용된다.
- 확장은 임포트에서 사용해야 하기에 같은 타입에 같은 이름으로 여러개 만들 수도 있다.
    - 여러 라이브러리에서 여러 메서드를 받을 수도 있다.
    - 다만 다른 동작을 하는 같은 이름의 확장이 있다는 점은 위험할 수 있다.
- 확장 함수는 가상(virtual)이 아니기에 파생 클래스에서 오버라이드할 수 없다.
    - 확장 함수는 컴파일 시점에 정적으로 선택되기 때문
    - 상속을 목적으로 설계된 요소는 확장 함수로 만들면 안 된다.

```kotlin
open class C
class D: C()

fun C.foo() = "c"
fun D.foo() = "d"

fun main() {
	val d = D()
	print(d.foo()) // d
	
	val c: C = d
	print(c.foo()) // c
}
```

- 확장 함수는 ‘첫 번재 아규먼트로 리시버가 들어가는 일반 함수’로 컴파일되기에 이런 차이가 발생한다.

```kotlin
fun foo('this$receiver': C) = "c"
fun foo('this$receiver': D) = "d"
```

- 확장 함수는 클래스가 아닌 타입에 정의하는 것이기에 nullable 또는 제네릭 타입에도 정의할 수 있다.

```kotlin
inline fun CharSequence?.isNullOrBlank(): Boolean { /*...*/ }

public fun Iterable<Int>.sum(): Int { /*...*/ }
```

- 중요한 차이점으로 확장 함수는 클래스 레퍼런스에서 멤버로 표시되지 않는다.
    - 때문에 어노테이션 프로세서가 따로 처리하지 않는다.
    - 확장 함수로 추출하면 어노테이션 프로세서로부터 숨겨진다.

## 정리

- 확장 함수는
    - 읽어 들여야 한다.
    - virtual이 아니다.
    - 멤버 보다 낮은 우선 순위를 갖는다.
    - 클래스 위가 아니라 타입 위에 만들어진다.
    - 클래스 레퍼런스에 나오지 않는다.
- API의 필수적인 부분이 아닌 부분은 확장 함수로 만드는 것이 여러모로 좋다.
