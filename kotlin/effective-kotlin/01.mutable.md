# 아이템 1 가변성을 제한하라
- 코틀린은 모듈로 프로그램을 설계한다.
    - 클래스, 객체, 함수, 타입 별칭, 톱레벨 프로퍼티 등
    - 모듈 중 일부는 상태를 가질 수 있다.
        - `var` 또는 `mutable` 객체 사용
- 상태를 적절하게 관리하는 것은 꽤 어렵다.
    - 디버깅이 힘들다. 상태 변경이 많으면 이를 추적하기가 까다롭고 예상치 못한 상태 변화는 큰 문제가 된다.
    - 가변성이 있으면 코드 실행을 추론하기가 어려워진다.
    - 멀티스레드 프로그램일 때는 적절한 동기화가 필요하다.
    - 모든 상태를 테스트해야 하므로 테스트하기 어렵다.
    - 상태 변경 시 이러한 변경을 다른 부분에 알려야 하는 경우가 있다.
- 가변성의 단점 때문에 이를 완전하게 제한하는 언어가 바로 순수 함수형 언어이다.
    - 하지만 가변성에 너무 많은 제한이 걸려 있어 프로그램 작성하기가 굉장히 어렵다.

## 코틀린에서 가변성 제한하기

### 읽기 전용 프로퍼티 (val)

- `val`을 사용해 읽기 전용 프로퍼티를 만들면 일반적인 방법으로는 값이 변하지 않는다.
- 다만 읽기 전용 프로퍼티가 mutable 객체를 담고 있다면 내부적으로 변할 수 있다.

```kotlin
val list = mutableListOf(1, 2, 3)
```

- `val` 프로퍼티는 값이 변경될 수 있긴 하지만 프로퍼티 레퍼런스 자체를 변경할 수 없어 동기화 문제를 줄일 수 있다.
- 읽기 전용 프로퍼티는 사용자 정의 게터로도 정의할 수 있다.
    - `var` 프로퍼티를 사용하는 `val` 프로퍼티는 `var` 프로퍼티가 변할 때 변할 수 있다.

```kotlin
var name: String = "Marcin"
var surname: String = "Moskaja"
val fullname 
	get() = "$name $surname"
```

- 코틀린 프로퍼티는 기본적으로 캡슐화되어 있다.
    - 사용자 정의 게터와 세터까지 가질 수 있다.
    - 때문에 API를 변경하거나 정의할 때 굉장히 유연하다.
- `val`는 읽기 전용이지만, 불변을 의미하는 것은 아니다.
    - 또한 이는 게터 또는 델리게이트(delegate)로 정의할 수도 있다.
    - 만약 완전 변경이 필요 없다면 final 프로퍼티를 사용하는 것이 좋다.
- `val`는 정의 옆에 상태가 바로 적히므로 코드 실행을 예측하는 것이 쉽고 스마트 캐스트 등의 추가 기능을 활용할 수 있다.

### 가변 컬렉션과 읽기 전용 컬렉션 구분하기

- 코틀린에선 컬렉션도 가변과 불변으로 나뉜다.
    - `Iterable`, `Collection`, `Set`, `List` 인터페이스는 읽기 전용 컬렉션
    - `MutableIterable`, `MutableCollection`, `MutableSet`, `MutableList` 인터페이스는 읽고 쓸 수 있는 컬렉션
    - `mutable`이 붙은 인터페이스는 읽기 전용 인터페이스를 상속 받아 변경을 위한 메서드를 추가한 것 뿐이다.
- 읽기 전용 컬렉션이 내부 값을 변경할 수 없는 것은 아니지만 읽기 전용 인터페이스가 이를 지원하지 않기에 불변인 것이다.
    - ex) `Iterable<T>.map`과 `.filter` 등 함수는 `ArrayList`를 리턴하는데 이는 변경 가능하다.
    - 컬렉션을 진짜 불변으로 만들지 않고 읽기 전용으로 설계함으로써 더 많은 자유를 얻을 수 있었다.
        - 실제 컬렉션을 리턴함으로써 플랫폼 고유 컬렉션을 사용할 수 있음
- 다만 개발자가 ‘시스템 해킹’을 시도해서 다운캐스팅을 할 때 문제가 된다.

```kotlin
val list = listOf(1, 2, 3)

if (list is MutableList) { // 이렇게 하지 말자
	list.add(4)
}
```

- `mutable`로 변경해야 한다면 `list.toMutableList`를 활용하면 된다.
    - 복제(copy)를 활용하는 방법
