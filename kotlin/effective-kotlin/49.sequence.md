# 아이템 49 하나 이상의 처리 단계를 가진 경우에는 시퀸스를 사용하라
- `Iterable`과 `Sequence`는 비슷하지만 완전 다른 형태로 동작한다.
- `Sequence`는 지연 처리되는데 데코레이터 패턴으로 꾸며진 새로운 시퀸스가 리턴되어 `toList` 등의 최종 연산이 이루어질 때 연산이 수행된다.
    - 반면 `Iterable`는 연산이 이루어질 때마다 `List`가 만들어진다.
- 시퀸스 처리의 장점
    - 자연스러운 처리 순서를 유지
    - 최소한만 연산
    - 무한 시퀸스 형태로 사용 가능
    - 각각 단계에서 컬렉션을 만들지 않는다.

## 순서의 중요성

- 이터러블과 시퀸스 처리는 연산 순서가 달라지면 다른 결과가 나온다.
- 시퀸스 처리는 요소 하나하나의 연산을 한꺼번에 적용한다.
    - 이를 element-by-element order 또는 lazy order라 부른다.
- 이터러블은 요소 전체를 대상으로 연산을 차근차근 적용한다.
    - 이를 step-by-step order 또는 eager order라 부른다.

```kotlin
sequenceOf(1, 2, 3)
	.filter { print("F$it, "); it % 2 == 1 }
	.map { print("M$it, "); it * 2 }
	.forEach { print("E$it, ") }
// 출력: F1, M1, E2, F2, F3, M3, E6,

listOf(1, 2, 3)
	.filter { print("F$it, "); it % 2 == 1 }
	.map { print("M$it, "); it * 2 }
	.forEach { print("E$it, ") }
// 출력: F1, F2, F3, M1, M3, E2, E6
```

- 위 같은 컬렉션 처리 함수가 아닌 고전적인 반복문과 조건문을 사용한다면 이는 시퀸스 처리인 lazy order로 동작한다.
    - 즉 시퀸스 처리의 순서가 더 자연스러운 처리라고 볼 수 있다.

## 최소 연산

- 컬렉션에 어떤 처리를 적용하고, 앞의 요소 10개만 필요한 상황이 종종 있다.
    - 이터러블의 경우 원하는 처리를 컬렉션 전체에 적용한 뒤 앞 요소 10개를 사용해야 한다.
    - 하지만 시퀸스는 앞 요소 10개에만 원하는 처리를 적용할 수 있다.

```kotlin
(1..10).asSequence()
	.filter { print("F$it, "); it % 2 == 1 }
	.map { print("M$it, "); it * 2 }
	.find { it > 5 }
// 출력: F1, M1, F2, F3, M3,

(1..10)
	.filter { print("F$it, "); it % 2 == 1 }
	.map { print("M$it, "); it * 2 }
	.find { it > 5 }
// 출력: F1, F2, F3, F4, F5 ... M1, M3, M5, M7, M9
```

- 중간 처리 단계를 모든 요소에 적용할 필요가 없다면 시퀸스를 사용하는 것이 좋다.

## 무한 시퀸스

- 시퀸스는 최종 연산 전까지 어떠한 처리도 하지 않기에 무한 시퀸스를 통해 필요한 값만 추출하는 것이 가능하다.
    - `generateSequence` 또는 `sequence`로 무한 시퀸스를 만들 수 있다.

```kotlin
generateSequence(1) { it + 1 } // 초기값과 그 다음 요소의 계산 방법을 지정
	.map { it * 2 }
	.take(10)
	.forEach { print("$it, ") }
// 출력: 2, 4, 6, 8, 10, 12, 14, 16, 18, 20
```

- 무한 시퀸스를 사용할 땐 값을 몇 개 활용할지 지정해야 한다.
    - 그렇지 않으면 무한히 반복한다.
    - `take`, `first` 등과 같은 종결 연산이 필요
    - `find`, `any`, `all`, `none`, `indexOf`도 무한을 끊을 순 있지만 원하는 요소를 못찾으면 무한 반복에 빠지니 지양해야 한다.

## 각 단계에서 컬렉션을 만들어 내지 않음

- 표준 컬렉션 함수는 각 단계에서 컬렉션을 만들기에 이 또한 비용이다.
  - 무거운 컬렉션의 경우 굉장히 큰 비용이 든다.
- 저자가 여러 방면으로 실험해본 결과 하나 이상의 처리 단계를 포함하는 컬렉션 처리의 경우 시퀸스를 사용하면 20~40% 정도의 성능이 향상된다.

## 시퀸스가 빠르지 않은 경우

- 컬렉션 전체를 기반으로 처리해야 하는 연산은 시퀸스를 사용해도 빨라지지는 않는다.
- 대표적으로 stdlib의 `sorted`가 있다.
  - `sorted`의 경우 `List`로 변환 후 자바 stdlib의 `sort`를 사용한다.
  - 시퀸스보다 일반적인 컬렉션이 더 빠르다.
  - 또한 `sorted`의 경우 무한 시퀸스와 함께 사용하면 무한 반복에 빠지니 주의해야 한다.

## 자바 스트림의 경우

- 자바 8의 스트림도 시퀸스처럼 lazy하게 동작하여 마지막 처리 단계에서 연산이 일어난다.
- 다만 코틀린 시퀸스와 자바 스트림은 다음 세 가지 차이점이 존재한다.
  - 코틀린 시퀸스가 더 많은 처리 함수를 갖고 있고 더 사용하기 쉽다.
  - 자바 스트림은 병렬 함수를 사용해 병렬 모드로 실행할 수 있는데 이는 멀티 코어 환경에서 큰 성능적 이점을 가져온다. (다만 몇 가지 결함에 주의해야 한다.)
  - 코틀린 시퀸스는 코틀린/JVM, 코틀린/JS, 코틀린/네이티브 등 일반적인 모듈에서 사용 가능하지만 자바 스트림은 코틀린/JVM에서만 동작한다.
- 병렬 모드로 성능적 이득을 얻을 수 있는 곳에서만 자바 스트림을 사용하고, 일반적인 경우엔 코틀린 시퀸스를 사용하는 것이 더 좋다.

## 코틀린 시퀸스 디버깅

- 코틀린 시퀸스와 자바 스트림은 모두 디버깅 기능이 지원된다.
  - 자바 스트림 - Java Stream Debugger 플러그인
  - 코틀린 시퀸스 - Kotlin Sequence Debugger 플러그인
- Kotlin Sequence Debugger의 경우 Kotlin 플러그인에 통합되어 있다.
