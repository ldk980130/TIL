# 아이템 49 하나 이상의 처리 단계를 가진 경우에는 시퀸스를 사용하라
- `Iterable`과 `Sequence`는 비슷하지만 완전 다른 형태로 동작한다.
- `Sequence`는 지연 처리되는데 데코레이터 패턴으로 꾸며진 새로운 시퀸스가 리턴되어 `toList` 등의 최종 연산이 이루어질 때 연산이 수행된다.
    - 반면 `Iterable`는 연산이 이루어질 때마다 `List`가 만들어진다.
- 시퀸스 처리의 장점
    - 자연스러운 처리 순서를 유지
    - 최소한만 연산
    - 무한 시퀸스 형태로 사용 가능
    - 각각 단계에서 컬렉션을 만들지 않는다.

## 순서의 중요성

- 이터러블과 시퀸스 처리는 연산 순서가 달라지면 다른 결과가 나온다.
- 시퀸스 처리는 요소 하나하나의 연산을 한꺼번에 적용한다.
    - 이를 element-by-element order 또는 lazy order라 부른다.
- 이터러블은 요소 전체를 대상으로 연산을 차근차근 적용한다.
    - 이를 step-by-step order 또는 eager order라 부른다.

```kotlin
sequenceOf(1, 2, 3)
	.filter { print("F$it, "); it % 2 == 1 }
	.map { print("M$it, "); it * 2 }
	.forEach { print("E$it, ") }
// 출력: F1, M1, E2, F2, F3, M3, E6,

listOf(1, 2, 3)
	.filter { print("F$it, "); it % 2 == 1 }
	.map { print("M$it, "); it * 2 }
	.forEach { print("E$it, ") }
// 출력: F1, F2, F3, M1, M3, E2, E6
```

- 위 같은 컬렉션 처리 함수가 아닌 고전적인 반복문과 조건문을 사용한다면 이는 시퀸스 처리인 lazy order로 동작한다.
    - 즉 시퀸스 처리의 순서가 더 자연스러운 처리라고 볼 수 있다.

## 최소 연산

- 컬렉션에 어떤 처리를 적용하고, 앞의 요소 10개만 필요한 상황이 종종 있다.
    - 이터러블의 경우 원하는 처리를 컬렉션 전체에 적용한 뒤 앞 요소 10개를 사용해야 한다.
    - 하지만 시퀸스는 앞 요소 10개에만 원하는 처리를 적용할 수 있다.

```kotlin
(1..10).asSequence()
	.filter { print("F$it, "); it % 2 == 1 }
	.map { print("M$it, "); it * 2 }
	.find { it > 5 }
// 출력: F1, M1, F2, F3, M3,

(1..10)
	.filter { print("F$it, "); it % 2 == 1 }
	.map { print("M$it, "); it * 2 }
	.find { it > 5 }
// 출력: F1, F2, F3, F4, F5 ... M1, M3, M5, M7, M9
```

- 중간 처리 단계를 모든 요소에 적용할 필요가 없다면 시퀸스를 사용하는 것이 좋다.

## 무한 시퀸스

- 시퀸스는 최종 연산 전까지 어떠한 처리도 하지 않기에 무한 시퀸스를 통해 필요한 값만 추출하는 것이 가능하다.
    - `generateSequence` 또는 `sequence`로 무한 시퀸스를 만들 수 있다.

```kotlin
generateSequence(1) { it + 1 } // 초기값과 그 다음 요소의 계산 방법을 지정
	.map { it * 2 }
	.take(10)
	.forEach { print("$it, ") }
// 출력: 2, 4, 6, 8, 10, 12, 14, 16, 18, 20
```

- 무한 시퀸스를 사용할 땐 값을 몇 개 활용할지 지정해야 한다.
    - 그렇지 않으면 무한히 반복한다.
    - `take`, `first` 등과 같은 종결 연산이 필요
    - `find`, `any`, `all`, `none`, `indexOf`도 무한을 끊을 순 있지만 원하는 요소를 못찾으면 무한 반복에 빠지니 지양해야 한다.
