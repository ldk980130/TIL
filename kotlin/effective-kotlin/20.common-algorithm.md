# 아이템 20 일반적인 알고리즘을 반복해서 구현하지 말라
- 일반적인 알고리즘은 이미 존재하는 경우가 많다.

```kotlin
val percent = when { // 숫자를 특정 범위에 맞추는 알고리즘
	numberFromUser > 100 -> 100
	numberFromUser < 0 -> 0 
	else -> numberFromUser
}

val percent = numberFromUser.coerceIn(0, 100) // 이미 stdlib에 존재
```

- 이미 있는 것을 활용하는 것의 장점
    - 코드 작성 속도가 빨라진다.
    - 구현을 읽지 않아도 함수 이름만 봐도 무엇을 하는지 바로 알 수 있다.
    - 직접 구현할 때 발생하는 실수를 줄일 수 있다.
    - 제작자들이 한 번만 최적화하면 이 함수를 활용하는 모든 곳이 최적화 혜택을 받을 수 있다.

## 표준 라이브러리 살펴보기

- stdlib 라이브러리는 확장 함수를 활용해서 만들어진 라이브러리로 굉장히 거대한 유틸리티 라이브러리다.
- 하나하나 살펴보는 것이 매우 번거롭지만 그럴만한 가치가 있다.

## 나만의 유틸리티 구현하기

- 상황에 따라선 표준 라이브러리에 없는 알고리즘이 필요할 때가 있다.
- 이는 범용 유틸리티 함수로 정의하는 것이 좋다.
    - 여러 번 사용되지 않는다 해도 아래처럼 만드는 것이 좋다.
    - 잘 알려진 수학적 개념(product)로 개발자들이 함수 의미를 쉽게 예측 가능하고 재사용될 가능성이 높기 때문

```kotlin
fun Iterable<Int>.product() = // 컬렉션 내의 모든 숫자 곱을 계산
	fold(1) { acc, i -> acc * i } 
```

- 많이 사용되는 알고리즘 추출 방법
    - 톱레벨 함수
    - 프로퍼티 위임
    - 클래스 등
- 확장함수는 위 방법들과 비교해 다음 장점이 있다.
    - 상태를 유지하지 않기에 행위를 나타내기 좋다.
    - 톱레벨 함수와 비교해서, 구체적인 타입이 있는 객체에만 사용을 제한할 수 있다.
    - 수정할 객체를 아규먼트로 주입 받는 것보다 확장 리시버로 사용하는 것이 가독성이 더 좋다.
    - 객체에 정의한 함수보다 자동 완성 기능 등의 제안이 이루어지므로 쉽게 찾을 수 있다.
