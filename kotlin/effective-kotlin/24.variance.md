# 아이템 24 제네릭 타입과 variance 한정자를 활용하라

```kotlin
class Cup<T>
```

- 위 코드에서 `T`는 variance 한정자(`out` 또는 `in`)이 없기에 invariant(불공변성)이다.
    - 불공변이라는 것은 제네릭 타입 간 서로 관련성이 없다는 의미이다.
    - `Cup<Int>`와 `Cup<Number>`, `Cup<Any>`는 서로 관련이 없다.
- 관련성이 필요하다면 variance 한정자를 붙여야 하는데 서브타입만 제네릭 타입으로 허용하려면 `out` 한정자가 필요하다.
    - `A`가 `B`의 서브타입일 때 `Cup<A>`가 `Cup<B>`이 서브타입이 된다.
    - 이는 convariant(공변성)이라 말한다.

```kotlin
open class Dog
class Puppy: Dog()

class Cup<out T>

val b: Cup<Dog> = Cup<Puppy> // OK
val a: Cup<Puppy> = Cup<Dog>() // error
```

- `in` 한정자는 반대 의미로 constravariant(반변성)으로 만든다.
    - `A`가 `B`의 서브타입일 때 `Cup<A>`가 `Cup<B>`의 슈퍼타입이 된다.

```kotlin
class Cup<in T>

val b: Cup<Dog> = Cup<Puppy> // error
val a: Cup<Puppy> = Cup<Dog>() // ok
```

## 함수 타입

- 코틀린 타입 시스템에선 파라미터 타입은 더 높은 타입으로, 리턴 타입은 더 낮은 타입으로 이동한다.
    - 코틀린 함수 타입의 모든 파라미터 타입은 contravariant
    - 코틀린의 모든 리턴 타입은 convariant이다.
    - `Int` → `Number` → `Any` 타입 순으로 더 상위 타입인 걸 염두하고 `(Int) → Any` 타입의 함수를 생각해보자.

```kotlin
fun printProcessedNumber(transaction: (Int) -> Any) {
	print(transaction(42))
}

val intToDouble: (Int) -> Number = { it.toDouble() }
val numberAsText: (Number) -> Any = { it.toShort() }
val identity: (Number) -> Number = { it }

printProcessedNumber(intToDouble)
printProcessedNumber(numberAsText)
printProcessedNumber(identity)
```
