# 아이템 46 함수 타입 파라미터를 갖는 함수에 inline 한정자를 붙여라

- 코틀린 표준 라이브러리의 고차 함수 대부분은 `inline` 한정자가 붙어 있다.
    - 고차 함수(higher-order function) - 함수를 파라미터로 받는 또는 함수를 리턴하는 함수

```kotlin
inline fun repeat(times: Int, action: (Int) -> Unit) {
	for (index in 0 until times) { action(index) }
}
```

- `inline` 한정자는 ‘함수를 호출하는 부분’을 ‘함수 본문’으로 대체하며 다음 장점이 있다.
    - 타입 아규먼트에 reified 한정자를 붙여 사용 가능
    - 함수 타입 파라미터를 가진 함수가 훨씬 빠르게 동작
    - 비지역(non-local) 리턴을 사용할 수 있다.

```kotlin
repeat(10) { print(it) }

// 컴파일 후
for (index in 0 until times) { 
	print(index) 
}
```

## 타입 아규먼트를 reified로 사용할 수 있다.

- 제네릭은 컴파일과 함께 타입과 관련된 내용이 제거된다.
    - 따라서 런타임에 제네릭 타입에 대한 연산을 할 수가 없다.

```kotlin
fun <T> printTypeName() {
	print(T::class.simpleName) // 오류
}
```

- 함수를 인라인으로 만들고 `reified` 한정자를 지정하면 이 제한을 무시할 수 있다.
    - `reified` 한정자로 타입 파라미터를 사용한 부분이 타입 아규먼트로 대체된다.

```kotlin
inline fun <reified T> printTypeName() {
	print(T::class.simpleName)
}

// 사용
printTypeName<Int>() // Int
printTypeName<Char>() // Char
printTypeName<String>() // String
```

## 함수 타입 파라미터를 가진 함수가 훨씬 빠르게 동작

- 모든 함수는 `inline` 한정자를 붙이면 조금 더 빠르게 동작한다.
    - 함수 호출과 리턴을 위해 점프하는 과정과 백스택을 추적하는 과정이 없기 때문
- 하지만 함수 파라미터를 가지지 않는 함수에선 이러한 차이가 큰 성능 차이를 발생시키지 않는다.
- 코틀린 JVM에서 함수 타입은 익명 클래스 또는 일반 클래스 기반으로 객체로 만들어진다.
    - ex) `() → Unit`는 `Function0<Unit>`로 컴파일
    - 즉 함수 본문을 객체로 랩하기에 코드 속도가 느려진다.
- 인라인 함수와 아닌 함수의 더 중요한 차이는 함수 리터럴 내부에서 지역 변수를 캡쳐할 때 확인 가능하다
    - 아래 코드에서처럼 불필요한 래핑이 발생하기에 큰 반복문 안에선 성능 차이가 누적된다.

```kotlin
var l = 1L
noinlineRepeat(100_000_000) {
	l += it
}

// 인라인이 아닌 람다에선 지역 변수 l을 직접 사용할 수 없어
// 컴파일 중 아래와 같이 레퍼런스 객체로 래핑되고
// 람다 표현식 내부에선 이를 사용한다.
val a = Ref.LongRef()
a.element = 1L
noinlineRepeat(100_000_000) {
	a.element = a.element + it
}
```
