# 10.3 스키마 레지스트리 실습

## 10.3.1 스키마 레지스트리와 클라이언트 동작

- 카프카는 pub/sub 모델이기에 프로듀서/컨슈머는 직접 통신을 주고받지 않는다.
- 컨슈머가 메시지를 읽기 위해선 프로듀서가 정의한 스키마 정보를 알아야 한다.
- 컨플루언트 문서 참고
    - https://docs.confluent.io/platform/current/schema-registry/fundamentals/index.html

<img width="572" height="362" alt="Image" src="https://github.com/user-attachments/assets/e9b14766-69da-4fc8-91ad-c331e96b128a">

1. 에이브로 프로듀서는 스키마 레지스트리의 스키마 유효성 여부를 확인한다.
    1. `io.confluent.kafka.serializers.KafkaAvroSerializer` 사용
    2. 스키마가 확인되지 않으면 스키마를 등록, 캐시
2. 스키마 레지스트리는 현 스키마가 저장소에 저장된 스키마와 동일한 것인지, 진화한 것인지 확인한다.
    1. 스키마에 문제가 없다면 프로듀서에 고유 ID를 응답
    2. 고유 ID는 스키마에 할당되는, 순차 증가하는 값이다.
3. 프로듀서는 스키마 레지스트리로부터 받은 스키마 ID를 참고해 메시지를 카프카에 전송한다.
    1. 이 때 스키마 전체 내용이 아닌 오로지 메시지와 ID만 전송한다.
    2. JSON은 키:벨류 전체를 전송해야 하지만 에이브로 덕에 스키마 ID와 벨류만 보낼 수 있어 효율적이다.
4. 에이브로 컨슈머는 카프카 토픽에 저장된 메시지를 읽는다.
    1. `io.confluent.kafka.serializers.KafkaAvroDeserializer` 역직렬화 사용
    2. 이 때 스키마 ID가 없다면 컨슈머는 스키마 레지스트리로부터 가져온다.

- 이처럼 프로듀서/컨슈머는 서로 직접 통신하진 않지만 스키마 레지스트리와 통신하며 스키마 정보를 알 수 있다.
- 스키마 레지스트리 덕에 전송/컨슘하는 메시지 크기를 줄일 수 있다.
    - 적은 네트워크 대역폭 사용
