# 13장 증권 거래소

## 1단계: 문제 이해 및 설계 범위 확정

- 기능 요구사항
    - 간단히 주식만 거래한다고 가정
        - 새 주문
        - 체결되지 않은 주문 취소
    - 주문 유형은 지정가 주문만 가능
    - 시간 내 거래 처리
    - 거래소는 규제 시설이므로 위험성 점검이 가능해야 한다.
        - ex) 한 사용자가 하루에 거래할 수 있는 애플 주식을 백만 주 이하로 제한하는 규칙이 있다고 할 때 이를 위반한 거래가 있는지 점검
    - 사용자 지갑 관리
- 비기능 요구사항
    - 가용성: 최소 99.99%
    - 결함 내성: 빠른 복구 메커니즘이 필요
    - 지연 시간
        - 왕복 지연 시간이 밀리초 수준이어야 한다.
        - p99 지연 시간이 중요
    - 보안
        - 거래소는 계좌 신설 전에 사용자 신원 확인을 위한 KYC 확인을 수행
        - DDoS 공격 방지 장치 구비
- 개략적 규모 추정
    - 100가지 주식
    - 하루 10억 건 주문
    - 월~금 오전 9시 30분 ~ 16시까지 (6.5시간)
    - QPS: 10억 / (6.5 * 3600) =~ 43,000
    - 최대 QPS: 5 * QPS = 215,000
        - 거래량은 장 시작 직후, 마감 직전이 훨씬 높다.

## 2단계 개략적 설계안 제시 및 동위 구하기

### 용어 정리

- 브로커
    - 대부분 개인 고객은 브로커 시스템을 통해 거래소와 거래한다.
    - 개인 사용자가 증권을 거래하고, 시장 데이터를 확인하도록 사용자 인터페이스를 제공한다.
- 기관 고객
    - 전문 증권 거래 소프트웨어를 사용하여 대량으로 거래한다.
    - 대규모 주문을 하기에 주문 분할 같은 기능을 필요로 한다.
- 지정가 주문
    - 가격이 고정된 매수 또는 매도 주문
    - 시장가 주문과는 달리 체결이 즉시 이루어지지 않을 수 있고 부분 체결될 수도 있다.
- 시장가 주문
    - 가격을 지정하지 않는 주문으로 시장가로 즉시 체결된다.
- 봉 차트
    - 특정 기간 동안의 주가
    - 일정 시간 간격 동안 시장의 시작가, 종가, 최고가, 최저가를 표시할 수 있다.
    - 1분, 5분, 1일, 1주일, 1개월 간격이 존재
- FIX
    - Financial Information Exchange Protocol, 금융 정보 교환 프로토콜
    - 증권 거래 정보 교환을 위한 기업 중립적 통신 프로토콜

### 개략적 설계안

- 아래는 주식 주문의 거래 흐름이다.
    1. 고객에 브로커의 웹 또는 모바일 앱을 통해 주문한다.
    2. 브로커가 주문을 증권 거래소에 전송한다.
    3. 주문이 클라이언트 게이트웨이에 도착하고, 게이트웨이는 유효성 검사, 속도 제한, 인증, 정규화 등의 게이트 키핑을 수행한다.
    4. 주문 관리자가 위험 관리자가 설정한 규칙에 따라 위험성 점검을 수행한다.
    5. 위험 관리자가 위험성을 검증해 주문 관리자에 응답한다.
    6. 위험성 점검 과정을 통과한 주문에 대해 주문 관리자는 지갑에 주문 처리 자금이 충분한지 확인한다.
    7. 주문 관리자는 시퀸서를 통해 주문을 체결 엔진으로 전송한다.
    8. 체결 엔진은 매수, 매도 측 각각 하나씩 두 개의 집행 기록을 생성한다. (나중에 시퀸서는 주문 집행 기록을 일정 순서로 정렬할 것이다.)
    9. 주문 집행 사실을 클라이언트에 전송한다.

```mermaid
graph LR
    Broker["브로커"]
    CGW["클라이언트 게이트웨이"]
    OM["주문 관리자"]
    Wallet["지갑 (주문 관리자 내부)"]
    Seq["시퀸서"]
    RM["위험 관리자"]
    ME["체결 엔진"]

    Broker -->|1.주문 요청| CGW
    CGW -->|2.유효성 검사 후 주문 전달| OM
    OM -->|3.위험성 점검 요청| RM
    RM -->|4.위험성 검증 결과| OM
    OM -->|5.자금 확인| Wallet
    OM -->|6.주문 전송| Seq
    Seq -->|7.주문 전달| ME

```

- 다음은 시장 데이터 흐름을 따라 주문이 체결 엔진부터 데이터 서비스를 거쳐 브로커로 전달되어 집행되기까지의 과정이다.
    - M1. 체결 엔진은 주문이 체결되면 집행 기록 스트림을 만들어 시장 데이터 게시 서비스로 전송한다.
    - M2. 시장 데이터 게시 서비스는 집행 기록 및 주문 스트림에서 얻은 데이터로 봉 차트와 호가 창을 구성해 데이터 서비스로 보낸다.
    - M3. 브로커는 데이터 서비스를 통해 실시간 시장 데이터를 읽고 이 시장 데이터를 고객에게 전달한다.

```mermaid
graph LR
    ME["체결 엔진"]
    MDP["시장 데이터 게시 서비스"]
    DS["데이터 서비스"]
    Broker["브로커"]

    %% M1. 체결 엔진 → 시장 데이터 게시 서비스
    ME -->|M1. 집행 기록 스트림| MDP

    %% M2. 시장 데이터 게시 서비스 → 데이터 서비스
    MDP -->|M2. 봉 차트/호가 창 데이터| DS

    %% M3. 브로커 → 데이터 서비스 → 고객
    DS -->|M3. 실시간 시장 데이터| Broker

```

- 마지막으로 아래는 보고 흐름(report flow)이다. 
    - R1. 보고 서비스는 주문 관리자로부터 주문 및 실행 기록에서 보고에 필요한 모든 필드를 종합한다.
    - R2. 종합해 만든 레코드를 데이터베이스에 기록한다.

```mermaid
graph LR
  OM["주문 관리자"]
  RS["보고 서비스"]
  DB["DB"]
  Seq["시퀸서"]
  ME["체결 엔진"]

  ME -->|집행 기록 전송| Seq
  Seq -->|집행 기록 전달| OM
  OM -->|R1. 주문 및 실행 기록| RS
  RS -->|R2. 종합 레코드| DB
```

### 거래 흐름

- 거래 흐름은 거래소의 중요 경로상에서 진행된다.
- 체결 엔진
  - 각 주식 심벌에 대한 주문서 내지 호가 창을 유지 관리한다.
    - 주문서 또는 호가 창은 특정 주식에 대한 매수/매도 주문 목록
  - 매수 주문과 매도 주문을 연결하는데 즉 주문 체결로 두 개의 집행 기록이 만들어진다.
  - 집행 기록 스트림을 시장 데이터로 배포한다.
  - 고가용성의 체결 엔진이 만드는 체결 순서는 결정론적이어야 한다.
- 시퀸서
  - 체결 엔진을 결정론적으로 만드는 핵심 구성 요소로 주문에 시퀸스 ID를 붙어 체결 엔진에 전달한다.
  - 입력 시퀸서와 출력 시퀸서 2개가 있으며 각각 ID를 통해 고유 순서를 유지한다.
  - 순서 ID를 찍는 이유는 다음과 같다.
    - 시의성 및 공정성
    - 빠른 복구 및 재싱
    - 정확히 1회 실행 보증
  - 시퀸서는 체결 엔진에 두 개 카프카 이벤트 스트림이 연결되어 있는 것과 비슷하다.
    - 하나는 입력되는 주문용, 하나는 출력될 집행 기록용
- 주문 관리자
  - 주문 관리자는 클라이언트 게이트웨이를 통해 주문 수신 후 다음을 수행한다.
    - 위험 점검 컴포넌트를 통해 위험성을 검토
    - 사용자 지갑을 통해 자금 확인
    - 주문을 시퀸서에 전달
  - 또한 주문 관리자는 시퀸서를 통해 체결 엔진으로부터 집행 기록을 받는다.
    - 그리고 다시 클라이언트 게이트웨이를 통해 브로커에 체결 주문을 반환한다.
  - 주문 관리자는 다양한 상태 변화를 관리해야 하기에 이벤트 소싱을 통해 설계된다.

- 클라이언트 게이트웨이
  - 인증, 유효성 검사, 처리율 제한, 정규화 등을 지원한다.
  - 중요 경로상에 놓이며 지연 시간에 민감해 가벼워야 한다.
  - 때문에 복잡한 기능은 체결 엔진이나 위험 점검 컴포넌트에 맡겨야 한다.
- 시장 데이터 게시 서비스(Market Data Publisher, MDP)
  - 체결 엔진에서 집행 기록을 스트림을 수신해 호가 창과 봉 차트를 만들어 낸다.
  - 시장 데이터(호가 창과 봉 차트)를 데이터 서비스로 전송하여 해당 서비스의 구독자가 사용할 수 있게 된다.
- 보고 흐름
  - 거래 이력, 세금 보고, 규정 준수 여부 보고, 결산 등의 기능을 제공한다.
  - 짧은 지연 보다는 정확성과 규정 준수가 핵심이다.
  - 입력으로 들어오는 주문과 결과로 나가는 집행 기록 모두에서 정보를 모아 속성(attributes)들을 구성하는 것이 일반적이다.
    - 들어오는 새 주문에는 주문 세부 정보가 존재
    - 나가는 집행 기록에는 주문 ID, 가격, 수량 및 집행 상태 등이 존재

### 데이터 모델

- 증권 거래소에는 세 가지 유형의 주요 데이터가 있다.
  - 상품, 주문 및 집행
  - 호가 창/주문서
  - 봉 차트
- 상품, 주문, 집행
  - 상품은 거래 대상 주식의 속성으로 정의된다.
    - 자주 변경되는 데이터는 아니고 주로 UI 표시를 위한 데이터다.
    - 아무 데이터베이스에나 저장 가능하며 캐시를 적용하기 좋다.
  - 주문은 매수/매도 실행 명령이다.
  - 집행 기록은 체결이 이루어진 결과다.
  - `Product ← Order → Execution`
- 호가 창
  - 증권 또는 금융 상품에 대한 매수/매도 주문 목록으로 가격 수준별로 정리되어 있다.
  - 체결 엔진이 빠른 주문 체결을 위해 사용하는 핵심 자료구조다.
  - 호가 창 자료구조는 다음 요구사항을 만족시킬 수 있어야 한다.
    - 일정한 조회 시간
    - 빠른 추가/취소/실행 속도 - 가급적 O(1) 시간 복잡도
    - 빠른 업데이트
    - 최고 매수 호가/최저 매도 호가 질의
    - 가격 수준 순회
  - 아래 코드는 호가 창의 구현 클래스다.
    - 하지만 `orders: List<Order>`는 주문에 대한 연산을 O(1)에 만족시키지 못한다. (이중 연결 리스트가 필요)

```kotlin
class PriceLevel(
	private val limitPrice: Price,
	private val totalVolume: Long,
	private val orders: List<Order>,
)

class Book<Side>(
	private val  side: Side,
	private val limitMap: Map<Price, PriceLevel>,
)

class OrderBook(
	private val buyBook: Book<Buy>,
	private val sellBook: Book<Sell>,
	private val bestBid: PriceLevel,
	private val bestOffer: PriceLevel,
	private val orderMap: Map<OrderID, Order>,
)
```

- 봉 차트
  - 시장 데이터 프로세서가 시장 데이터를 만들 때 호가 창과 함께 사용하는 자료구조
  - `Candlestick` 클래스와 `CandlestickChart` 클래스를 사용한다.
  - 하나의 봉이 커버하는 시간이 경과하면 다음 주기를 커버할 새 `Candlestick` 클래스 객체를 생성하여 `CandlestickChart` 내부 연결 리스트에 추가한다.
  - 봉 차트에서 많은 종목 가격 이력을 다양한 시간 간격으로 추적하려면 메모리 최적화가 필요하다.
    - 미리 메모리를 할당해 둔 링 버퍼에 봉을 보관하여 새 객체 할당 횟수를 줄일 수 있다.
    - 메모리에 두는 봉 개수를 제한하고 나머지는 디스크에 보관한다.

```kotlin
class Candlestick(
	private val openPrice: Long,
	private val closePrice: Long,
	private val highPrice: Long,
	private val lowPrice: Long,
	private val volume: Long,
	private val timestamp: Long,
	private val interval: Int,
)

class CandlestickChart(
	private val sticks: List<Candlestick>
)
```
