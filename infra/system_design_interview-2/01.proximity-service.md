# 1장 근접성 서비스
- 근접성 서비스
    - 현재 위치에서 가까운 시설을 찾는 데 이용된다.
    - ex) 구글맵

## 1단계: 문제 이해 및 설계 범위 확정

- 기능 요구사항
    - 사용자의 위치와 검색 반경 정보에 매치되는 사업장 목록 반환
    - 사업장 소유주가 사업장 정보를 추가, 삭제, 갱신할 수 있으나 실시간 반영될 필요는 없음
    - 고객은 사업장의 상세 정보를 살필 수 있어야 함
- 비기능 요구사항
    - 낮은 응답 지연 - 신속한 검색
    - 데이터 보호 - 사용자 위치 정보는 보호되어야 한다.
    - 고가용성 및 규모 확장성 - 트래픽이 급증해도 감당 가능해야 한다.
- 개략적 규모 측정
    - DAU 1억명
    - 등록된 사업장 수는 2억
- QPS (Query per Second) 계산
    - 1일 = 24시간 = 86400초이지만 대략 쉬운 계산을 위해 10^5로 올림하여 사용 예정
    - 한 사용자는 하루 5회 검색 시도한다고가정
    - 즉 QPS = (1억 * )5 / 10^5 = 5000

## 2단계: 개략적 설계안 제시 및 동의 구하기

### API 설계

다음 REST API가 필요할 것이다.

- 기준에 맞는 사업장 목록 반환 API
    - 검색 기준에 맞는 사업장 목록 반환
    - 위도, 경도, 반경 몇 미터인지를 파라미터로 넘김
- 사업장 관련 API
    - 특정 사업장 상세 정보 반환 API
    - 사업장 추가, 갱신, 삭제 API

### 데이터 모델

- 근접성 서비스는 쓰기 연산에 비해 읽기 연산의 빈도가 압도적으로 높다.
- 읽기 연산이 높은 시스템에선 MySQL 같은 관계형 데이터베이스가 바람직할 수 있다.
- 시스템의 핵심은 business 테이블과 지리적 위치 색인 테이블(geospatial index table)이다.
    - busniess 테이블엔 pk, 주소, 위치 정보, 위도, 경도 등 컬럼 존재

### 개략적 설계

```mermaid
graph TD;
    A[사용자] -->|서비스 요청| LB[로드 밸런서]
    LB -->|LBS 요청| B[LBS]
    LB -->|사업장 서비스 요청| D[사업장 서비스]
    B -->|읽기 연산| C1[사본 데이터베이스 1]
    B -->|읽기 연산| C2[사본 데이터베이스 2]
    B -->|읽기 연산| C3[사본 데이터베이스 3]
    D -->|추가/갱신/삭제 요청| E[주 데이터베이스]
    E -->|데이터 복제| C1
    E -->|데이터 복제| C2
    E -->|데이터 복제| C3
```

- 위치 기반 서비스 (LBS)
    - 주어진 위치와 반경 정보를 기반으로 주변 사업장을 검색
    - 읽기 요청만 빈번한 서비스로 QPS가 높다.
    - 무상태 서비스이므로 수평 확장이 쉽다.
- 사업장 서비스
    - 사업장 소유주가 사업장 정보를 생성, 갱신, 삭제하는데 이러한 쓰기 요청은 QPS가 높지 않다.
    - 고객이 사업장 정보를 조회할 때도 사용되는데 특정 시간대에 QPS가 높아진다.
- 데이터베이스 클러스터
    - 주-부(primary-secondary) 데이터베이스 형태로 구성
    - 주 데이터베이스에 쓰기, 부 데이터베이스에 읽기 요청을 처리시킬 수 있다.
    - 주 데이터베이스에 기록된 데이터가 부 데이터베이스로 복사된다.
    - 데이터 복제에는 시간 차이가 발생하지만 실시간성이 필요 없는 서비스에선 큰 문제가 되지 않는다.
- 규모 확장성
    - 사업장 서비스와 LBS 둘 다 무상태 서비스이기에 몰리는 트래픽에 서버를 추가하여 대응 가능하다.

### 주변 사업장 검색 알고리즘

- 지리적인 데이터 검색 시 단순한 색인으로는 큰 효율을 내기 힘들다.
  - 색인은 1차원 데이터를 검색할 때 효과적
  - 2차원 데이터를 검색하려면 각 1차원 검색 값을 모두 불러와 교집합을 구해야 한다.
  - ex) 위도와 경도 각각에 색인을 만들어 두어도 주어진 모든 위도, 경도를 검색한 후 교집합을 걸러내야 한다.
- 2차원 데이터를 위한 색인 방식엔 두 가지가 있는데 지도를 작은 영역으로 분할하고 고속 검색이 가능하도록 하는 것이 특징이다.
  - 해시 기반 방안: 균등 격자, 지오해시, 카르테시안 계층 등
  - 트리 기반 방안: 쿼드트리, 구글 S2, R 트리 등
- 균등 격자 (even grid)
  - 지도를 작은 격자로 나누는 단순한 접근법
  - 하나의 격자에 여러 사업장을 담을 수 있다.
  - 다만 사업장 분포가 균등하지 않다는 단점이 있다.
  - ex) 뉴욕엔 많은 사업장이 있겠지만 사막이나 바다에 사업장이 있을 리가 없기 때문

### 지오해시 (Geohash)

- 2차원의 위도 경도 데이터를 1차원의 문자열로 변환하며 균등 격자보다 나은 방안
- 비트를 하나씩 늘려가며 재귀적으로 세계를 더 작은 격자로 분할해 나간다.
- 위도와 경도를 이진수로 변환한 뒤, 이를 Base32 형식의 문자열로 인코딩
  - ex) 구글 본사 지오해시 (길이=6) - `1001 11010 01001 10001 11111 11110`
- 지오해시는 12단계 정밀도를 갖는다.
  - 최적 정밀도는 사용자가 지정한 반경으로 그린 원을 덮는 최소 크기 격자를 만드는 지오해시 길이를 구해야 한다.
- 지오해시의 격자 가장자리 이슈
  - 지오해시는 해시값의 공통 접두어가 긴 격자들이 서로 가깝게 놓이도록 보장한다.
  - 하지만 그 역은 참이 아닌데 아주 가까운 두 위치가 어떤 공통 접두어도 갖지 않을 수도 있다.
  - 이 문제 때문에 단순한 접두어 기반 SQL 질의문으로는 모든 주변 사업장을 가져올 수 없다.
  - 또한 두 지점이 공통 접두어를 가지더라도 다른 격자에 포함되어 있다면 검색에서 다른 격자 지점이 누락되기도 한다.
- 격자 가장자리 이슈를 해결하려면 현재 격자를 포함한 인접한 격자를 모두 탐색할 필요가 있다.
- 현재 격자와 주변 격자를 모두 살펴 보아도 표시할 데이터가 충분하지 않은 경우
  - 선택지 1: 부족하면 부족한대로 결과를 반환한다. 다만 사용자의 욕구를 만족시킬 수 없을 확률이 크다.
  - 선택지 2: 검색 반경을 키운다. 지오해시 값 마지막 비트를 삭제하여 얻은 새 지오해시 값으로 주변을 검색한다.

