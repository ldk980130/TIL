# 9장 S3와 유사한 객체 저장소
- S3는 AWS에서 제공하는 REST API 기반 인터페이스로 이용 가능한 객체 저장소다.

## 저장소 시스템 101

- 개략적으로 저장소 시스템엔 세 가지 부류가 있다.
- 블록 저장소
    - 블록 저장소는 원시 블록을 서버에 볼륨 형태로 제공하는 가장 유연하고 융통성 높은 저장소다.
    - HDD나 SSD처럼 서버에 물리적으로 연결되는 드라이브는 블록 저장소의 가장 흔한 형태다.
    - 원시 블록을 서버에 볼륨 형태로 제공하며 가장 유연한 저장소다.
    - 데이터베이스나 가상 머신 엔진 등은 원시 블록을 직접 제어하여 최대한의 성능을 끌어낸다.
- 파일 저장소
    - 파일 저장소는 블록 저장소 위에 구현되어 더 높은 추상화를 제공한다.
    - 데이터는 계층적인 디렉터리 안에 보관된다.
    - 파일 저장소를 사용하는 서버는 블록을 직접 제어/포맷하는 까다로움을 거치지 않아도 된다.
- 객체 저장소
    - 데이터 영속성과 대규모 애플리케이션을 지원하며 비용을 낮추기 위해 성능을 희생하는 특징이 있다.
    - 데이터 아카이브나 백업에 주로 쓰이며 모든 데이터를 수평적 구조의 객체로 보관한다. (계층적 디렉터리가 없음)
    - 데이터 접근은 REST API를 통한다.
    - ex) AWS S3, Azure Blob Storage

### 용어 정리

- 버킷(bucket)
    - 객체를 보관하는 논리적 컨테이너
    - 버킷 이름은 전역적으로 유일해야 한다.
    - S3에 데이터를 업로드하기 위해선 버킷부터 만들어야 한다.
- 객체(object)
    - 버킷에 저장하는 개별 데이터
    - 데이터(payload)와 메타데이터를 갖는다.
    - 메타데이터는 객체를 기술하는 이름-값 쌍이다.
- 버전(versioning)
    - 한 객체의 여러 버전을 같은 버킷 안에 둘 수 있게 하는 기능
    - 실수로 지웠거나 덮어 쓴 객체를 복구할 수 있도록 한다.
- URI(Uniform Resource Identifier)
    - 객체에 접근할 수 있도록 하는 REST API를 제공
    - 각 객체는 해당 API URI를 통해 고유하게 식별 가능하다.
- SLA(Service-Level Agreement)
    - 서비스 수준 협약은 서비스 제공자와 클라이언트 사이 맺어지는 계약이다.
    - AWS S3의 경우
        - 여러 가용 구역에 걸쳐 99.9999999%의 객체 내구성 제공
        - 한 가용 구역 전체가 소실되어도 데이터 복구 가능
        - 연간 99.9% 가용성 제공

## 1단계: 문제 이해 및 설계 범위 확정

- 기능 요구사항
  - 버킷 생성
  - 객체 업로드 및 다운로드
  - 객체 버전
  - 버킷 내 객체 목록 출력 기능
- 비기능 요구사항
  - 100PB 데이터
  - 식스 나인(six nines, 99.9999%) 수준의 데이터 내구성
  - 포 나인(99.99%) 수준의 서비스 가용성
  - 저장소 효올성: 높은 수준의 안정성과 성능은 보증하되 저장소 비용은 최대한 낮추어야 한다.
- 대략적인 규모 추정
  - 객체 저장소는 디스크 용량이나 초당 디스크 IO(IOPS)가 병목이 될 가능성이 높다.
  - 객체 크기의 분포를 잘 고려해야 한다.
    - ex) 객체 중 20%가 1MB 미만, 60%는 1~64MB, 나머지 20%는 64MB이상의 대형 객체
  - IOPS: 초당 100~150회 임의 데이터 탐색을 지원한다고 가정
  - 이러한 가정에 기반하여 시스템의 가용 객체 수를 가늠할 수 있다.

## 2단계: 개략적 설계안 제시 및 동의 구하기

### 객체 저장소의 속성

- 객체 불변성
  - 보관되는 객체들은 변경이 불가능하다.
  - 새 버전 객체로 대체될 순 있지만 값을 바꿀 순 없다.
- 키-값 저장소
  - 해당 객체의 URI를 사용하여 데이터를 가져올 수 있다.
- 저장은 1회, 읽기는 여러 번
  - 데이터 접근 패턴 측면에서 쓰기 1회, 읽기는 여러 번 발생한다.
- 소형 및 대형 객체 동시 지원
  - 다양한 크기 객체를 문제 없이 저장할 수 있다.
- 객체 저장소 설계 철학은 UNIX 파일 시스템 설계 철학과 유사하다.
  - UNIX의 경우 파일 저장 시 파일의 이름과 데이터는 같은 곳에 저장되지 않는다.
    - 파일 이름은 ‘아이노드(inode)’라는 자료구조에, 데이터는 디스크의 다른 위치에 들어간다.
    - 아이노드에는 실제 데이터가 보관되는 곳을 가리키는 포인터 목록이 저장된다.
  - 객체 저장소도 UNIX와 비슷하게 메타데이터와 객체 데이터가 별도로 저장된다.
    - 다만 메타데이터 저장소에는 포인터 대신 네트워크를 통해 객체를 식별하는 식별자(ID)가 보관된다.
  - 메타데이터와 실제 객체 데이터를 분리하면 설계가 단순해진다.
    - 객체는 불변이지만 메타데이터는 변경 가능
    - 두 컴포넌트를 독립적으로 구현 및 최적화가 가능한 것

### 개략적 설계안

```mermaid
graph LR
    User([사용자]) --> LB[로드밸런서]
    LB --> API[API 서비스]
    API --> IAM[IAM]
    API --> MDS
    MD --> MDB[(메타데이터 DB)]
    
    subgraph MDS[메타데이터 저장소]
	    MD[메타데이터 서비스]
	    MDB
    end
    
    API --> DS
    
    subgraph DS[데이터 저장소]
        DSS1[데이터 저장소 서비스] --> SN1[(저장소 노드)]
        DSS2[데이터 저장소 서비스] --> SN2[(저장소 노드)]
        DSS3[데이터 저장소 서비스] --> SN3[(저장소 노드)]
        
        %% 주 노드(Primary)에서 부 노드(Secondary)로의 요청
        DSS2 --> DSS1
        DSS2 --> DSS3
        
        %% 주 노드 표시
        class DSS2,SN2 primary
        class DSS1,SN1,DSS3,SN3 secondary
    end

```

- 로드밸런서: REST API에 대한 요청을 API 서버들에 분산하는 역할 담당
- API 서비스
  - 각 서비스에 대한 호출을 조율하는 역할을 담당
  - 무상태 서비스이기에 수평 확장 가능
- IAM 서비스: 인증, 권한 부여, 접근 제어 등 처리
- 데이터 저장소
  - 실제 데이터를 보관/읽어가는 장소
  - 모든 데이터 관련 연산은 객체 ID를 통한다.
- 메타데이터 저장소: 객체 메타데이터를 보관
