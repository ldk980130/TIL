# 4장 분산 메시지 큐
- 메시지 큐 사용의 이점
    - 결합도 완화(decoupling)
    - 규모 확장성 개선: 소비자 시스템 규모를 트래픽 부하에 맞춰 독립적으로 늘릴 수 있다.
    - 가용성 개선: 특정 컴포넌트에 장애가 발생해도 다른 컴포넌트는 서비스를 계속할 수 있다.
    - 성능 개선: 메시지 큐를 통해 비동기 통신이 쉽게 가능하고 생산자와 소비자는 서로를 기다릴 필요가 없다.

### 메시지 큐 대 이벤트 스트리밍 플랫폼

- 아파치 카프카(Kafaka)나 펄사(Pulsa)는 엄밀히 말하면 메시지 큐가 아닌 이벤트 스트리밍 플랫폼이다.
    - 데이터 장기 보관, 메시지 반복 소비 등의 부가 기능은 통상적으로 이벤트 스트리밍 플랫폼에서만 이용 가능하다.
- 하지만 메시지 큐(RocketMQ, RabbitMQ 등)의 기능이 점점 확장되며 경계가 점차 희미해지고 있다.
    - ex) RabbitMQ에서 반복적으로 소비 가능하고, 장기 보관이 가능한 스트리밍 기능이 옵션으로 제공된다.
- 이번 장에선 이벤트 스트리밍 플랫폼이 지원하는 부가 기능을 갖춘 분산 메시지 큐를 설계해볼 것이다.

## 1단계: 문제 이해 및 설계 범위 확정

- 기능 요구사항
    - 생산자는 메시지 큐에 메시지를 보낼 수 있다
    - 소비자는 메시지 큐를 통해 메시지를 수신할 수 있다.
    - 메시지는 반복적으로 수신할 수 있어야 하고, 단 한 번만 수신하도록 설정될 수 있어야 한다.
    - 오래된 이력 데이터는 삭제될 수 있다.
    - 메시지 크기는 킬로바이트 수준
    - 메시지가 생산된 순서대로 소비자에게 전달할 수 있어야 한다.
    - 메시지 전달 방식은 최소 한 번, 최대 한 번, 정확히 한 번 가운데 설정할 수 있어야 한다.
- 비기능 요구사항
    - 높은 대역폭과 낮은 전송 지연 가운데 하나 선택 가능
    - 규모 확장성 지원
    - 지속성 및 내구성
        - 데이터를 디스크에 지속적으로 보관
        - 데이터를 여러 노드에 복제

## 2단계: 계략적 설계안 제시 및 동의 구하기

- 메시지 큐는 생산자와 소비자 사이 결합을 느슨하게 하는 서비스
    - 생산자와 소비자의 독립적 운영 및 규모 확장을 가능하게 한다.
    - 클라이언트/서버 모델 관점에서 생산자와 소비자는 모두 클라이언트고 메시지 큐는 서버 역할을 한다.

### 메시지 모델

- 일대일 모델
    - 큐에 전송된 메시지는 오직 한 소비자만 소비
    - 소비자가 많을 순 있지만 오직 한 소비자만 메시지를 가져갈 수 있다.
    - 메시지가 소비되면 큐에 해당 메시지는 삭제된다. (데이터 보관을 지원하지 않음)
- 발행-구독 모델
    - 토픽(topic)
        - 메시지를 주제별로 정리하는 데 사용
        - 각 토픽은 메시지 큐 서비스 전반에 고유한 이름을 가진다.
    - 토픽에 전달된 메시지는 해당 토픽을 구독하는 모든 소비자에게 전달된다.

### 토픽, 파티션, 브로커

- 토픽 한 대로 감당하기 어려운 데이터 양이 쌓인다면 파티션(partition)을 활용할 수 있다.
  - 파티션은 토픽에 보낼 메시지의 작은 부분 집합이다.
  - 토픽을 여러 파티션으로 분할해 메시지를 모든 파티션에 균등하게 보낸다.
  - 즉 토픽 용량을 확장하려면 파티션 개수를 늘리면 된다.
- 파티션을 유지하는 서버는 브로커(broker)라 부른다.
- 각 토픽 파텨신은 FIFO(first in, first out) 큐처럼 동작한다.
- 같은 파티션 안에서 메시지 순서가 유지된다.
- 같은 키를 가진 모든 메시지는 같은 파티션으로 보내진다.
- 토픽을 구독하는 소비자는 하나 이상의 파티션에서 데이터를 소비한다.

### 소비자 그룹

- 토픽을 구독하는 소비자가 여럿인 경우 이 소비자들을 소비자 그룹(consumer group)이라 부른다.
- 하나의 소비자 그룹은 여러 토픽을 구독할 수 있고 오프셋을 별도로 관리한다.
- 같은 그룹 내 소비자는 메시지를 병렬로 소비할 수 있다.
- 메시지 순서를 보장하려면 어떤 파티션의 메시지는 한 그룹 안에서 오직 한 소비자만 읽을 수 있도록 제약을 추가해야 한다.
  - 다만 그룹 내 소비자 수가 구독하는 토픽의 파티션 수보다 크면 메시지를 받지 못하는 소비자가 생긴다.
  - 그래서 아래 다이어그램에서 소비자-4은 토픽 B의 메시지를 수신할 수 없다.

```mermaid
graph TB
    subgraph Topic A
        A1[파티션-1]
        A2[파티션-2]
    end
    subgraph Topic B
        B1[파티션-1]
    end
    
    subgraph Consumer Group 1
        C1_1[소비자-1]
        C1_2[소비자-2]
    end

    subgraph Consumer Group 2
        C2_1[소비자-3]
        C2_2[소비자-4]
    end

    A1 --> C1_1
    A2 --> C1_2
    A1 --> C2_1
    A2 --> C2_2
    
    B1 --> C2_1

```

- 그래서 파티션 수를 동적으로 늘리는 일을 피하기 위해 충분한 파티션을 미리 할당해두기도 한다.
  - 처리 용량을 늘리려면 소비자를 더 추가하면 된다.

### 계략적 설계안

- 클라이언트
  - 생산자: 메시지를 특정 토픽에 전송
  - 소비자 그룹: 토픽을 구독하고 메시지를 소비
- 핵심 서비스 및 저장소
  - 브로커: 파티션 유지
  - 저장소
    - 데이터 저장소: 메시지는 파티션 내 저장소에 보관
    - 상태 저장소: 소비자 상태를 저장
    - 메타데이터 저장소: 토픽 설정, 토픽 속성 등 저장
  - 조정 서비스
    - 서비스 디스커버리: 어떤 브로커가 살아있는지 탐색
    - 리더 선출: 브로커 가운데 하나를 리더로 선정해야 하며 한 클러스터에는 반드시 활성 리더가 하나 있어야 한다. 이 리더가 파티션 배치를 책임진다.
    - 아파치 주키퍼나 etd가 보텅 리더 선출 컴포넌트로 유명하다.
