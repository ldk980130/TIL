# 15장 구글 드라이브 설계

## 설계 범위 예시

- 기능 요구 사항
    - 파일 추가
    - 파일 다운로드
    - 여러 단말에 파일 동기화
    - 파일 갱신 이력 조회
    - 파일 공유
    - 파일이 편집되거나 삭제되거나 새롭게 공유되었을 때 알림 표시
- 비기능 요구사항
    - 안정성: 데이터 손실 방지
    - 빠른 동기화 속도: 동기화에 시간이 많이 걸리면 사용자가 불편함을 느낌
    - 네트워크 대역폭: 네트워크를 많이 사용하면 사용자는 좋아하지 않을 것
    - 규모 확장성: 많은 트래픽 처리
    - 높은 가용성: 일부 서버에 장애가 발생해도 시스템은 계속 사용 가능해야 한다.

## 개략적 추정치

- 가입 사용자는 오천만 명, DAU는 천만 명
- 모든 사용자에게 10GB 무료 저장공간 할당
- 메일 각 사용자가 평균 2개 파일 업로드, 각 파일 평균 크기는 500KB
- 읽기:쓰기 비율 - 1:1
- 필요한 저장공간 춍량 = 5천만 X 10GB = 500페타바이트(Petabyte)
- 업로드 API QPS = 1천만 X 2회 업로드 / 24시간 / 3600초 = 약 240
- 최대 QPS = QPS X 2 = 480

## 구글 드라이브 개략적 설계안

- 우선 아래와 같은 구성의 서버 한 대로 구성
    - 웹 서버 - 파일 업로드 및 다운로드 처리
        - 아파치 웹 서버 사용
    - 데이터베이스 - 사용자 데이터, 로그인 정보, 파일 메타데이터 보관
        - MySQL 서버 사용
    - 파일 저장소 시스템 - 파일 저장을 위한 1TB의 공간 사용
        - 서버 내에 `drive/`라는 디렉터리 생성
        - 네임스페이스라 불리는 하위 디렉터리를 둔다. (사용자별 파일 공간)

### 파일 업로드 API

- 파일 업로드 API
    - 단순 업로드: 파일 크기가 작을 때 사용
    - 이어 올리기: 파일 사이즈가 크고 네트워크 문제가 예상될 때 사용
- 이어 올리기 api 예) `api.example.com/files/upload?uploadType=resumable`
    - `uploadType`: resumable
    - `data`: 업로드할 로컬 파일
- 이어올리기 절차
    - 이어올리기 URL을 받기 위한 최초 요청 전송
    - 데이터를 업로드하고 업로드 상태 모니터링
    - 업로드 중 장애가 발생하면 장애 발생 시점부터 업로드 재시작

### 파일 다운로드 API

- 예) `api.example.com/files/download`
- 인자
    - `path`: 다운로드할 파일 경로

    ```json
    {
      "path": "/recipes/soup/best_soup.txt"
    }
    ```


### 파일 갱신 히스토리 API

- 예) `api.example.com/files/list_revisions`
- 인자
    - `path`: 갱신 히스토리를 가져올 파일 경로
    - `limit`: 히스토리 길이 최대치

    ```json
    {
      "path": "/recipes/soup/best_soup.txt",
      "limit": 20
    }
    ```


### 한 대 서버의 제약 극복

- AWS S3 이용
    - 파일 시스템 용량 한계 극복
    - AWS Simple Storage Service: 규모 확장성, 가용성, 보안을 제공하는 객체 저장소 서비스
    - 서로 다른 지역에 데이터를 다중화할 수 있다.
- 로드 밸런서 도입
    - 네트워크 트래픽 분산
    - 웹 서버 증설 가능
- 메타데이터 데이터베이스
    - DB를 파일 저장소 서버에서 분리하여 SPOF를 회피
    - 다중화 및 샤딩 정책을 적용하여 가용성과 확장성 확보

### 동기화 충돌

- 두 명 이상의 사용자가 같은 파일이나 폴더를 수정하려는 경우
- 충돌 해소 전략
    - 사용자1의 먼저 처리되는 변경은 성공으로 처리
    - 사용자2의 나중에 처리되는 변경은 충돌이 발생한 것으로 표시
- 충돌이 발생했을 경우 이 시스템에는 같은 파일의 두 버전이 존재
    - 서버에 있는 최신 버전
    - 사용자2 로컬에 있는 최신 버전
- 두 파일을 하나로 합칠지, 하나를 다른 파일로 대체할지 결정해야 한다.

### 개략적 설계 아키텍처

<img width=500 height=500 src="https://github.com/ldk980130/TIL/assets/78652144/43328959-60f8-4ebf-bf1e-30f3e4090a5d">

- 사용자 단말: 클라이언트
- 블록 저장소 서버
    - 파일 블록을 클라우드 저장소에 업로드하는 서버
    - 블록 저장소란 클라우드 환경에 데이터 파일을 저장하는 기술
    - 한 파일을 여러 블록으로 나눠 저장하며 각 블록은 독립적인 객체로 취급
    - 블록은 고유 해시값이 할당되며 해시값은 메타데이터 데이터베이스에 저장
    - 파일을 재구성하려면 블록들을 원래 순서대로 합쳐야 한다.
- 클라우드 저장소: 블록 단위로 나눠진 파일을 보관
- 아카이빙 저장소: 오래 사용되지 않은 비활성 데이터를 보관
- 로드 밸런서: 요청 분산
- API 서버: 파일 업로드 외에 거의 모든 것을 담당
- 메타데이터 데이터베이스: 사용자, 파일, 블록, 버전 등 정보 보관
- 메타데이터 캐시: 성능을 위해 자주 쓰이는 메타데이터 보관
- 알림 서비스: 특정 이벤트를 클라이언트에 통지
    - 발생/구독 프로토콜 기반
- 오프라인 사용자 백업 큐
    - 클라이언트가 접속 중이 아니라 파일 최신 상태를 확인 못할 때
    - 최신 정보를 이 큐에 두어 나중에 동기화될 수 있도록 조치
