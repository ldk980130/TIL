# 13장 검색어 자동 완성 시스템

## 설계 범위 예시

- 빠른 응답 속도
    - 사용자가 검색어를 입력함에 따라 자동완성 검색어도 충분히 빨라야 함
    - 100밀리초 이내
- 연관성
    - 사용자가 입력한 단어와 연관된 것이어야 한다.
- 정렬
    - 시스템 계산 결과는 인기도 등 순위 모델에 의해 정렬
- 고가용성
    - 시스템 일버에 장애가 발생하거나 느려져도 시스템은 계속 사용 가능해야 한다.

### 개략적 규모 측정

- DAU 천만 명
- 평균 한 사용자는 매일 10건의 검색을 수행
- 질의할 때마다 평균 20바이트 데이터를 입력
    - ASCII 인코딩 방법 사용 (1문자 = 1바이트)
    - 잘의문은 평균 4개 단어로 이루어지고 평균 5글자라 가정
- 글자를 입력할 때마다 클라이언트는 백엔드에 요청
    - 평균 1회 검색당 20건 요청이 백엔드로 전달
    - ex) dinner라 검색한다면
        - `search?q=d`
        - `search?q=di`
        - `…`
        - `search?q=dinne`
        - `search?q=dinner`
- 약 초당 24,000건 질의(QPS) 발생, 최대 QPS = 48,000
- 쿼리 중 20% 정도는 신규 검색어

## 검색어 자동완성 시스템 개략적 설계안

- 개략적으로 시스템은 두 부분으로 나뉜다.
    - 데이터 수집 서비스 - 사용자가 입력한 질의를 실히간으로 수집
        - 데이터가 많은 애플리케이션에서 실시간 시스템은 바람직하지 않다.
        - 추후 상세 설계에서 현실적인 안에서 교체할 예정
    - 질의 서비스 - 질의에 대해 인기 검색어를 정렬해 내놓는 서비스

### 데이터 수집 서비스

- 질의문과 사용 빈도를 저장하는 ‘빈도 테이블’이 있다 가정
- 사용자가 검색어를 검색할 때마다 질의문과 빈도가 갱신되어진다.

| query | frequency |
| --- | --- |
| twitch | 1 |
| twitter | 2 |

### 질의 서비스

- 빈도 테이블이 어느정도 채워진 상황에서 사용자가 질의를 하게 되면 top 5 검색어가 조회되어야 한다.
- 아래 쿼리를 통해 빈도수 상위 5개를 조회할 수 있다.

    ```sql
    SELECT * FROM frequency_table
    WHERE query LIKE 'prefix%'
    ORDER BY frequency DESC
    LIMIT 5
    ```

- 데이터 양이 적을 때는 괜찮지만 데이터가 많아지면 병목이 발생할 수 있다.

## 검색어 자동완성 시스템 상세 설계

- 상세 설계에서 필요한 컴포넌트
    - 트라이(trie) 자료구조
    - 데이터 수집 서비스
    - 질의 서비스

### 트라이 자료구조

- 트라이: 문자열들을 간략하게 저장할 수 있는 자료구조
    - 트리 형태의 자료구조
    - 루트 노드는 빈 문자열
    - 각 노드는 글자(character) 하나를 저장
    - 각 노드는 26개의(해당 글자 다음에 등장할 수 있는 모든 글자 개수) 자식 노드를 가질 수 있음
    - 각 노드는 하나의 단어 또는 접두어 문자열(prefix string)을 나타냄
- ex) 가령 아래의 빈도 테이블은 그림과 같이 트리로 나타낼 수 있다.


| query | freqeuncy |
| --- | --- |
| tree | 10 |
| try | 29 |
| true | 35 |
| toy | 14 |
| wish | 25 |
| win | 50 |

<img width=400 height=300 src="https://github.com/ldk980130/TIL/assets/78652144/1ab23007-782f-4e60-9756-3d2fe906e217">


### 트라이 자료구조를 활용한 구현

- 용어 정리
    - `p`: 접두어(prefix)의 길이
    - `n`: 트라이 안의 노드 개수
    - `c`: 주어진 노드의 자식 노드 개수
- 가장 많이 사용된 질의어 k개를 찾는 방법
    1. 해당 접두어를 표현하는 노드를 탐색 ,`O(p)`
    2. 해당 노드부터 하위 트리를 탐색하여 모든 유효 노드 탐색, `O(c)`
        1. 유효 노드란 유효한 검색 문자열을 구성하는 노드
    3. 요휴 노드들을 정렬하여 가장 인기있는 k개를 찾는다, `O(c log c)`
- 총 시간 복잡도 = `O(p) + O(c) + O(c log c)`
- 단 최약의 경우 k개를 얻기 위해 전체 트라이를 다 검색해야할 수도 있다.
    - 이를 해결하기 위한 두 가지 최적화 방법이 있다.

### 트라이 트리 탐색 최적화 1 - 접두어 최대 길이 제한

- 사용자가 긴 검색어를 입력하는 일은 거의 없다.
- 따라서 p값은 작은 정숫값(가령 50)이어도 충분
- 검색어 최대 길이를 제한하면 ‘접두어 노드를 찾는’ 시간 복잡도는 `O(1)`에 수렴할 수 있다.

### 트라이 트리 탐색 최적화 2 - 노드에 인기 검색어 캐시

- 각 노드에 k개 인기 검색어를 캐시해두면 전체 트라이 탐색을 방지할 수 있다.
- k는 보통 작은 값이기에 캐시 충분히 가능
- 단 저장 공간이 더 많이 필요하다는 단점도 있다.
    - 빠른 응답 속도가 중요할 때는 저장공간을 희생할만한 가치는 있다.
- 인기 검색어를 캐시해두면 접두어 노드를 찾는 순간 자식 노드를 탐색할 필요 없이 `O(1)` 시간에 정렬된 인기 검색어를 찾을 수 있다.

> 접두어 최대 길이를 제한하고, 노드에 인기 검색어를 캐시하면 전체 알고리즘 복잡도가 `O(1)`로 바뀌게 된다.
>
