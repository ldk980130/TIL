# 1장. 사용자 수에 따른 규모 확장성 

## 단일 서버

- 모든 컴포넌트가 단 한 대 서버에서 실행되는 간단한 시스템
- 웹, 앱, 데이터베이스, 캐시 등이 전부 한 대 서버에서 실행된다.

<img width=600 height=400 src="https://github.com/ldk980130/TIL/assets/78652144/c98ba802-27dd-4103-a444-7ab5f577d831"></img>

- 사용자 요청 처리 흐름
    1. 사용자는 도메인 주소를 이용하여 웹 사이트에 접속
    2. DNS 조회 결과로 IP 주소가 반환
    3. 해당 IP 주소로 HTTP 요청 전달
    4. 요청을 받은 웹 서버는 HTML 페이지나 JSON 형태의 응답을 반환

## 데이터베이스

- 사용자가 늘면 하나로 충분하지 않아 여러 서버를 두어야 한다.
- 하나는 웹/모바일 트리팩 처리용도, 하나는 데이터베이스용
    - 각각을 독립적으로 확장할 수 있다.

<img width=600 height=400 src="https://github.com/ldk980130/TIL/assets/78652144/bf97ae69-93d7-44ab-9195-43acce46a79f"></img>

### 어떤 데이터베이스를 사용할 것인가?

- 전통적인 관계형 데이터베이스 vs 비-관계형 데이터베이스
- 관계형 데이터베이스, RDBMS
    - MySQL, 오라클, PostgreSQL 등
    - 자료를 테이블과 열, 칼럼으로 표현
    - SQL로 여러 테이블의 데이터를 관계에 따라 조인하여 합칠 수 있다.
- 비 관계형 데이터베이스, NoSQL
    - CouchDB, Neo4j, Cassandra, HBase, Amazon DynamoDB 등
    - NoSQL은 또 다음 네 부류로 나눌 수 있다.
        - 키-값 저장소 (key-value store)
        - 그래프 저장소 (graph store)
        - 칼럼 저장소 (column store)
        - 문서 저장소 (document store)
    - 일반적으로 조인 연산은 지원하지 않는다.
- 대부분 관계형 데이터베이스가 최선이지만 비 관계형 데이터베이스가 필요할 수도 있다.
    - 아주 낮은 응답 지연시간(latency)이 요구됨
    - 다루는 데이터가 비정형이라 관계형 데이터가 아님
    - 데이터(JSON, YAML, XML 등)를 직렬화, 역직렬화할 수 있기만 하면 됨
    - 아주 많은 양의 데이터를 저장할 필요가 있음

## 수직적 규모 확장 vs 수평적 규모 확장

### 스케일 업(scale up), 수직적 규모 확장

- 서버에 고사양 자원을 추가하는 행위 (더 좋은 CPU, 더 많은 RAM)
- 트래픽 양이 적을 땐 수직적 확장이 좋은 선택
- 가장 큰 장점은 단순함
- 스케일 업 단점
    - 한 서버에 CPU나 메모리를 무한으로 증설할 수 없기에 한계가 존재
    - 자동 복구 방안이나 다중화 방안을 제시하지 않는다.

### 스케일 아웃(scale out), 수평적 규모 확장

- 더 많은 서버를 추가하여 성능을 개선하는 행위
- 대규모 애플리케이션을 지원할 때 적절

### 로드밸런서

- 로드밸런서는 부하 분산 집합에 속한 서버들에게 트래픽을 고르게 분산하는 역할을 한다.
- 로드밸런서 동작

  <img width=600 height=400 src="https://github.com/ldk980130/TIL/assets/78652144/f581c060-2a7f-48e9-8a06-4a83cf4fbf3c"></img>

    - 사용자는 로드밸런서의 public IP로 접속
    - 웹 서버는 클라이언트 접속을 직접 처리하지 않는다.
    - 보안을 위해 서버 간 통신에는 private IP를 사용
- 로드밸런서를 사용하면 장애 자동복구를 통해 가용성이 향상된다.
    - 서버 1이 다운되면 모든 트래픽은 서버 2로 전송될 수 있다.
    - 트래픽이 가파르게 증가했을 때 웹 서버 계층에 더 많은 서버를 추가하면 로드밸런서가 자동으로 트래픽을 분산시킨다.

### 데이터베이스 다중화

- 많은 DBMS가 다중화를 지원한다.
    - 보통 서버 사이에 master-slave 관계를 설정
    - 원본은 master 서버에, 사본은 slave 서버에 저장하는 방식
- 쓰기 연산은 master에서만 지원
- slave DB는 master에서 사본을 전달 받으며 읽기 연산만 지원
- 대부분 애플리케이션은 읽기 연산이 훨씬 많기에 통상 master보다 slave 수가 많다.

<img width=600 height=400 src="https://github.com/ldk980130/TIL/assets/78652144/5cb0f866-ef82-446a-9a42-9f15c0fb1f32"></img>

- 데이터베이스 다중화의 장점
    - 더 나은 성능 - 쓰기와 읽기 연산이 여러 DB 서버에 분산
    - 안정성 - 재해 등으로 DB 서버 일부가 다운되어도 데이터는 보존된다. (지역적으로 떨어진 장소에 다중화)
    - 가용성 - 하나의 DB 서버에 장애가 발생해도 다른 서버의 데이터로 서비스를 계속할 수 있다.
- 데이터베이스 다중화 장애 복구 시나리오
    - slave 서버가 한 대 뿐인데 다운된 경우라면 읽기 연산은 한시적으로 master로 전달되고 새로운 slave 서버가 장애 서버를 대체
    - slave 서버가 여러대인 경우에는 나머지 slave 서버에 읽기 연산이 분산되고 새로운 slave가 대체될 것이다.
    - master 서버가 한 대 뿐인데 다운된다면 slave 서버가 새로운 master 서버가 되고 새로운 slave를 추가한다.
        - 운영 상황에서는 slave 데이터가 최신 상태가 아아닐 수 있기에 복구 스크립트를 돌려서 추가해야 한다.
        - 다중 마스터(multi-masters)나 원형 다중화(circular replication)으로 해결할 수 있지만 훨씬 복잡하다.

## 캐시

캐시란 값비싼 연산 결과 또는 자주 참조되는 데이터를 메모리 안에 두고 뒤이은 요청이 보다 빨리 처리될 수 있도록 하는 저장소

### 캐시 계층

- 캐시 계층이란
    - 데이터가 잠시 보관되는 곳으로 DB보다 훨씬 빠르다.
    - 성능과 부하를 개선할 수 있다.
    - 독립적으로 확장시키는 것도 가능
- 읽기 주도형 캐시 전략 (read-through caching strategy)

  <img width=800 height=200 src="https://github.com/ldk980130/TIL/assets/78652144/34e1a5ca-34f1-49eb-a5b6-4531edfa69e2"></img>

    - 웹 서버는 캐시를 확인하여 응답디 저장되어 있다면 클라이언트에 바로 봔환
    - 캐시에 없는 경우 DB에 질의를 통해 데이터를 캐시에 저장한 뒤 클라이언트에 반환
- 대부분의 캐시 서버들이 일반적으로 널리 쓰이는 프로그래밍 언어로 API를 제공한다.

### 캐시 사용 시 유의할 점

- 캐시는 데이터 갱신은 자주 일어나지 않지만 참조는 빈번하게 일어난다면 고려해볼 만하다.
- 캐시는 데이터를 휘발성 메모리에 두므로 영속적으로 보관할 데이터를 캐시에 두는 것은 바람직하지 않다.
- 캐시에 저장된 데이터의 만료 정책을 마련해 두어야 한다.
    - 만료 정책이 없으면 캐시 데이터는 계속 커진다.
    - 만료가 너무 짧으면 DB를 너무 자주 읽어야 한다.
- 캐시 데이터와 지속적 저장소의 데이터의 일관성을 유지해야 한다.
    - 지속적 저장소와 캐시를 갱신하는 연산이 단일 트랜잭션으로 처리되지 않으면 일관성이 깨진다.
- 여러 지역에 걸쳐 캐시 서버를 분산시켜야 한다.
    - 캐시 서버를 한 대만 두는 경우 해당 서버는 단일 장애 지점(SPOF)가 되어버린다.
- 캐시 메모리 과할당을 고려해봐야 한다.
    - 캐시 메모리가 너무 작으면 엑세스 패턴에 따라 데이터가 자주 캐시에서 밀려나 성능이 떨어진다.
    - 캐시 메모리를 과할당하면 갑자기 캐시 데이터가 늘어났을 때 문제를 방지할 수 있다.
- 데이터 방출 정책을 고려해야 한다.
    - LRU(Least Recently Used): 마지막으로 사용된 시점이 가장 오래된 데이터를 내보내는 정책
    - LFU(Least Frequently Used): 사용된 빈도가 가장 낮은 데이터를 내보내는 정책
    - FIFO(First In First Out): 가장 먼저 캐시에 들어온 데이터를 내보내는 정책

## 콘텐츠 전송 네트워크 (CDN)

- CDN이란
    - 정적 콘텐츠를 전송할 수 있는 지리적으로 분산된 서버의 네트워크
    - 이미지, 비디오, CSS, JavaScript 파일 등을 캐시할 수 있다.
    - 간단하게 말하면 요청 경로, 쿼리 스트링, 쿠키, 요청 헤더 등 정보에 기반하여 HTML 페이지를 캐시하는 것
    - 웹 서버 대신 사용할 수 있다.
    - 캐시가 DB 부하를 줄여준다.
- 사용자가 웹사이트를 방문하면 그 사용자에게 가장 가까운 CDN 서버가 콘텐츠를 전달하게 된다.
- CDN도 읽기 주도형 캐시 전략처럼 동작한다.

### CDN 사용 시 고려해야 할 사항

- 비용
    - CDN은 보통 제 3 사업자에 의해 운영되어 데이터 전송 양에 따라 요금을 내게 된다.
    - 자주 사용되지 않는 콘텐츠 캐싱은 이득이 크지 않아 CDN을 사용하지 않는 것을 추천한다.
- 적절한 만료 시한 설정
    - 시의성이 중요한 콘텐츠의 경우 만료 시점이 중요하다.
    - 너무 길면 콘텐츠 신선도가 떨어지고, 너무 짧으면 원본 서버 접근 빈도가 늘어나 좋지 않다.
- CDN 장애 대처 방안
    - CDN 자체가 죽었을 때 웹사이트/애플리케이션이 어떻게 동작해야 하는지 고려해야 한다.
- 콘텐츠 무효화 방법 - 만료되지 않은 콘텐츠라 하더라도 CDN에서 제거할 수 있다.
    - CDN 서비스 사업자가 제공하는 API를 이용
    - 콘텐츠의 다른 버전을 서비스하도록 오브젝트 버저닝 이용
        - ex) `image.png?v=2`처럼 버전 정보를 지정
